// Code generated by ffjson <https://github.com/pquerna/ffjson>. DO NOT EDIT.
// source: types.go

package tgbotapi

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	fflib "github.com/pquerna/ffjson/fflib/v1"
)

// MarshalJSON marshal bytes to json - template
func (j *APIResponse) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *APIResponse) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.Ok {
		buf.WriteString(`{"ok":true`)
	} else {
		buf.WriteString(`{"ok":false`)
	}
	buf.WriteString(`,"result":`)

	{

		obj, err = j.Result.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"error_code":`)
	fflib.FormatBits2(buf, uint64(j.ErrorCode), 10, j.ErrorCode < 0)
	buf.WriteString(`,"description":`)
	fflib.WriteJsonString(buf, string(j.Description))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtAPIResponsebase = iota
	ffjtAPIResponsenosuchkey

	ffjtAPIResponseOk

	ffjtAPIResponseResult

	ffjtAPIResponseErrorCode

	ffjtAPIResponseDescription
)

var ffjKeyAPIResponseOk = []byte("ok")

var ffjKeyAPIResponseResult = []byte("result")

var ffjKeyAPIResponseErrorCode = []byte("error_code")

var ffjKeyAPIResponseDescription = []byte("description")

// UnmarshalJSON umarshall json - template of ffjson
func (j *APIResponse) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *APIResponse) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtAPIResponsebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtAPIResponsenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffjKeyAPIResponseDescription, kn) {
						currentKey = ffjtAPIResponseDescription
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyAPIResponseErrorCode, kn) {
						currentKey = ffjtAPIResponseErrorCode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffjKeyAPIResponseOk, kn) {
						currentKey = ffjtAPIResponseOk
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyAPIResponseResult, kn) {
						currentKey = ffjtAPIResponseResult
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyAPIResponseDescription, kn) {
					currentKey = ffjtAPIResponseDescription
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyAPIResponseErrorCode, kn) {
					currentKey = ffjtAPIResponseErrorCode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAPIResponseResult, kn) {
					currentKey = ffjtAPIResponseResult
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyAPIResponseOk, kn) {
					currentKey = ffjtAPIResponseOk
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtAPIResponsenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtAPIResponseOk:
					goto handle_Ok

				case ffjtAPIResponseResult:
					goto handle_Result

				case ffjtAPIResponseErrorCode:
					goto handle_ErrorCode

				case ffjtAPIResponseDescription:
					goto handle_Description

				case ffjtAPIResponsenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Ok:

	/* handler: j.Ok type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Ok = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Ok = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Result:

	/* handler: j.Result type=json.RawMessage kind=slice quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.Result.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ErrorCode:

	/* handler: j.ErrorCode type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ErrorCode = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Description:

	/* handler: j.Description type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Description = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Audio) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Audio) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"file_id":`)
	fflib.WriteJsonString(buf, string(j.FileID))
	buf.WriteString(`,"duration":`)
	fflib.FormatBits2(buf, uint64(j.Duration), 10, j.Duration < 0)
	buf.WriteString(`,"performer":`)
	fflib.WriteJsonString(buf, string(j.Performer))
	buf.WriteString(`,"title":`)
	fflib.WriteJsonString(buf, string(j.Title))
	buf.WriteString(`,"mime_type":`)
	fflib.WriteJsonString(buf, string(j.MimeType))
	buf.WriteString(`,"file_size":`)
	fflib.FormatBits2(buf, uint64(j.FileSize), 10, j.FileSize < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtAudiobase = iota
	ffjtAudionosuchkey

	ffjtAudioFileID

	ffjtAudioDuration

	ffjtAudioPerformer

	ffjtAudioTitle

	ffjtAudioMimeType

	ffjtAudioFileSize
)

var ffjKeyAudioFileID = []byte("file_id")

var ffjKeyAudioDuration = []byte("duration")

var ffjKeyAudioPerformer = []byte("performer")

var ffjKeyAudioTitle = []byte("title")

var ffjKeyAudioMimeType = []byte("mime_type")

var ffjKeyAudioFileSize = []byte("file_size")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Audio) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Audio) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtAudiobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtAudionosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffjKeyAudioDuration, kn) {
						currentKey = ffjtAudioDuration
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyAudioFileID, kn) {
						currentKey = ffjtAudioFileID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyAudioFileSize, kn) {
						currentKey = ffjtAudioFileSize
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyAudioMimeType, kn) {
						currentKey = ffjtAudioMimeType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyAudioPerformer, kn) {
						currentKey = ffjtAudioPerformer
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyAudioTitle, kn) {
						currentKey = ffjtAudioTitle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyAudioFileSize, kn) {
					currentKey = ffjtAudioFileSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyAudioMimeType, kn) {
					currentKey = ffjtAudioMimeType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAudioTitle, kn) {
					currentKey = ffjtAudioTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAudioPerformer, kn) {
					currentKey = ffjtAudioPerformer
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyAudioDuration, kn) {
					currentKey = ffjtAudioDuration
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyAudioFileID, kn) {
					currentKey = ffjtAudioFileID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtAudionosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtAudioFileID:
					goto handle_FileID

				case ffjtAudioDuration:
					goto handle_Duration

				case ffjtAudioPerformer:
					goto handle_Performer

				case ffjtAudioTitle:
					goto handle_Title

				case ffjtAudioMimeType:
					goto handle_MimeType

				case ffjtAudioFileSize:
					goto handle_FileSize

				case ffjtAudionosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_FileID:

	/* handler: j.FileID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Duration:

	/* handler: j.Duration type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Duration = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Performer:

	/* handler: j.Performer type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Performer = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MimeType:

	/* handler: j.MimeType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.MimeType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileSize:

	/* handler: j.FileSize type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.FileSize = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *CallbackGame) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *CallbackGame) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{}`)
	return nil
}

const (
	ffjtCallbackGamebase = iota
	ffjtCallbackGamenosuchkey
)

// UnmarshalJSON umarshall json - template of ffjson
func (j *CallbackGame) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *CallbackGame) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtCallbackGamebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtCallbackGamenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				}

				currentKey = ffjtCallbackGamenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtCallbackGamenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Chat) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Chat) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"id":`)
	fflib.FormatBits2(buf, uint64(j.ID), 10, j.ID < 0)
	buf.WriteString(`,"type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"title":`)
	fflib.WriteJsonString(buf, string(j.Title))
	buf.WriteString(`,"username":`)
	fflib.WriteJsonString(buf, string(j.UserName))
	buf.WriteString(`,"first_name":`)
	fflib.WriteJsonString(buf, string(j.FirstName))
	buf.WriteString(`,"last_name":`)
	fflib.WriteJsonString(buf, string(j.LastName))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtChatbase = iota
	ffjtChatnosuchkey

	ffjtChatID

	ffjtChatType

	ffjtChatTitle

	ffjtChatUserName

	ffjtChatFirstName

	ffjtChatLastName
)

var ffjKeyChatID = []byte("id")

var ffjKeyChatType = []byte("type")

var ffjKeyChatTitle = []byte("title")

var ffjKeyChatUserName = []byte("username")

var ffjKeyChatFirstName = []byte("first_name")

var ffjKeyChatLastName = []byte("last_name")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Chat) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Chat) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtChatbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtChatnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffjKeyChatFirstName, kn) {
						currentKey = ffjtChatFirstName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyChatID, kn) {
						currentKey = ffjtChatID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyChatLastName, kn) {
						currentKey = ffjtChatLastName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyChatType, kn) {
						currentKey = ffjtChatType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatTitle, kn) {
						currentKey = ffjtChatTitle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyChatUserName, kn) {
						currentKey = ffjtChatUserName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyChatLastName, kn) {
					currentKey = ffjtChatLastName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatFirstName, kn) {
					currentKey = ffjtChatFirstName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatUserName, kn) {
					currentKey = ffjtChatUserName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChatTitle, kn) {
					currentKey = ffjtChatTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChatType, kn) {
					currentKey = ffjtChatType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChatID, kn) {
					currentKey = ffjtChatID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtChatnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtChatID:
					goto handle_ID

				case ffjtChatType:
					goto handle_Type

				case ffjtChatTitle:
					goto handle_Title

				case ffjtChatUserName:
					goto handle_UserName

				case ffjtChatFirstName:
					goto handle_FirstName

				case ffjtChatLastName:
					goto handle_LastName

				case ffjtChatnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: j.ID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UserName:

	/* handler: j.UserName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.UserName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FirstName:

	/* handler: j.FirstName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FirstName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LastName:

	/* handler: j.LastName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.LastName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ChatAdministratorRights) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ChatAdministratorRights) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if j.IsAnonymous != false {
		if j.IsAnonymous {
			buf.WriteString(`"is_anonymous":true`)
		} else {
			buf.WriteString(`"is_anonymous":false`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtChatAdministratorRightsbase = iota
	ffjtChatAdministratorRightsnosuchkey

	ffjtChatAdministratorRightsIsAnonymous
)

var ffjKeyChatAdministratorRightsIsAnonymous = []byte("is_anonymous")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ChatAdministratorRights) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ChatAdministratorRights) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtChatAdministratorRightsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtChatAdministratorRightsnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'i':

					if bytes.Equal(ffjKeyChatAdministratorRightsIsAnonymous, kn) {
						currentKey = ffjtChatAdministratorRightsIsAnonymous
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyChatAdministratorRightsIsAnonymous, kn) {
					currentKey = ffjtChatAdministratorRightsIsAnonymous
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtChatAdministratorRightsnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtChatAdministratorRightsIsAnonymous:
					goto handle_IsAnonymous

				case ffjtChatAdministratorRightsnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_IsAnonymous:

	/* handler: j.IsAnonymous type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.IsAnonymous = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.IsAnonymous = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ChatMember) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ChatMember) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if j.IsBot != false {
		if j.IsBot {
			buf.WriteString(`"is_bot":true`)
		} else {
			buf.WriteString(`"is_bot":false`)
		}
		buf.WriteByte(',')
	}
	buf.WriteString(`"id":`)
	fflib.FormatBits2(buf, uint64(j.ID), 10, j.ID < 0)
	buf.WriteByte(',')
	if len(j.FirstName) != 0 {
		buf.WriteString(`"first_name":`)
		fflib.WriteJsonString(buf, string(j.FirstName))
		buf.WriteByte(',')
	}
	if len(j.LastName) != 0 {
		buf.WriteString(`"last_name":`)
		fflib.WriteJsonString(buf, string(j.LastName))
		buf.WriteByte(',')
	}
	if len(j.UserName) != 0 {
		buf.WriteString(`"username":`)
		fflib.WriteJsonString(buf, string(j.UserName))
		buf.WriteByte(',')
	}
	if len(j.LanguageCode) != 0 {
		buf.WriteString(`"language_code":`)
		fflib.WriteJsonString(buf, string(j.LanguageCode))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtChatMemberbase = iota
	ffjtChatMembernosuchkey

	ffjtChatMemberIsBot

	ffjtChatMemberID

	ffjtChatMemberFirstName

	ffjtChatMemberLastName

	ffjtChatMemberUserName

	ffjtChatMemberLanguageCode
)

var ffjKeyChatMemberIsBot = []byte("is_bot")

var ffjKeyChatMemberID = []byte("id")

var ffjKeyChatMemberFirstName = []byte("first_name")

var ffjKeyChatMemberLastName = []byte("last_name")

var ffjKeyChatMemberUserName = []byte("username")

var ffjKeyChatMemberLanguageCode = []byte("language_code")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ChatMember) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ChatMember) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtChatMemberbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtChatMembernosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffjKeyChatMemberFirstName, kn) {
						currentKey = ffjtChatMemberFirstName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyChatMemberIsBot, kn) {
						currentKey = ffjtChatMemberIsBot
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatMemberID, kn) {
						currentKey = ffjtChatMemberID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyChatMemberLastName, kn) {
						currentKey = ffjtChatMemberLastName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyChatMemberLanguageCode, kn) {
						currentKey = ffjtChatMemberLanguageCode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyChatMemberUserName, kn) {
						currentKey = ffjtChatMemberUserName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyChatMemberLanguageCode, kn) {
					currentKey = ffjtChatMemberLanguageCode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatMemberUserName, kn) {
					currentKey = ffjtChatMemberUserName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatMemberLastName, kn) {
					currentKey = ffjtChatMemberLastName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatMemberFirstName, kn) {
					currentKey = ffjtChatMemberFirstName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChatMemberID, kn) {
					currentKey = ffjtChatMemberID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChatMemberIsBot, kn) {
					currentKey = ffjtChatMemberIsBot
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtChatMembernosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtChatMemberIsBot:
					goto handle_IsBot

				case ffjtChatMemberID:
					goto handle_ID

				case ffjtChatMemberFirstName:
					goto handle_FirstName

				case ffjtChatMemberLastName:
					goto handle_LastName

				case ffjtChatMemberUserName:
					goto handle_UserName

				case ffjtChatMemberLanguageCode:
					goto handle_LanguageCode

				case ffjtChatMembernosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_IsBot:

	/* handler: j.IsBot type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.IsBot = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.IsBot = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: j.ID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FirstName:

	/* handler: j.FirstName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FirstName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LastName:

	/* handler: j.LastName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.LastName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UserName:

	/* handler: j.UserName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.UserName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LanguageCode:

	/* handler: j.LanguageCode type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.LanguageCode = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ChosenInlineResult) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ChosenInlineResult) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"result_id":`)
	fflib.WriteJsonString(buf, string(j.ResultID))
	if j.From != nil {
		buf.WriteString(`,"from":`)

		{

			err = j.From.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"from":null`)
	}
	if j.Location != nil {
		buf.WriteString(`,"location":`)

		{

			err = j.Location.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"location":null`)
	}
	buf.WriteString(`,"inline_message_id":`)
	fflib.WriteJsonString(buf, string(j.InlineMessageID))
	buf.WriteString(`,"query":`)
	fflib.WriteJsonString(buf, string(j.Query))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtChosenInlineResultbase = iota
	ffjtChosenInlineResultnosuchkey

	ffjtChosenInlineResultResultID

	ffjtChosenInlineResultFrom

	ffjtChosenInlineResultLocation

	ffjtChosenInlineResultInlineMessageID

	ffjtChosenInlineResultQuery
)

var ffjKeyChosenInlineResultResultID = []byte("result_id")

var ffjKeyChosenInlineResultFrom = []byte("from")

var ffjKeyChosenInlineResultLocation = []byte("location")

var ffjKeyChosenInlineResultInlineMessageID = []byte("inline_message_id")

var ffjKeyChosenInlineResultQuery = []byte("query")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ChosenInlineResult) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ChosenInlineResult) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtChosenInlineResultbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtChosenInlineResultnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffjKeyChosenInlineResultFrom, kn) {
						currentKey = ffjtChosenInlineResultFrom
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyChosenInlineResultInlineMessageID, kn) {
						currentKey = ffjtChosenInlineResultInlineMessageID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyChosenInlineResultLocation, kn) {
						currentKey = ffjtChosenInlineResultLocation
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'q':

					if bytes.Equal(ffjKeyChosenInlineResultQuery, kn) {
						currentKey = ffjtChosenInlineResultQuery
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyChosenInlineResultResultID, kn) {
						currentKey = ffjtChosenInlineResultResultID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyChosenInlineResultQuery, kn) {
					currentKey = ffjtChosenInlineResultQuery
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChosenInlineResultInlineMessageID, kn) {
					currentKey = ffjtChosenInlineResultInlineMessageID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChosenInlineResultLocation, kn) {
					currentKey = ffjtChosenInlineResultLocation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyChosenInlineResultFrom, kn) {
					currentKey = ffjtChosenInlineResultFrom
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyChosenInlineResultResultID, kn) {
					currentKey = ffjtChosenInlineResultResultID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtChosenInlineResultnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtChosenInlineResultResultID:
					goto handle_ResultID

				case ffjtChosenInlineResultFrom:
					goto handle_From

				case ffjtChosenInlineResultLocation:
					goto handle_Location

				case ffjtChosenInlineResultInlineMessageID:
					goto handle_InlineMessageID

				case ffjtChosenInlineResultQuery:
					goto handle_Query

				case ffjtChosenInlineResultnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ResultID:

	/* handler: j.ResultID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ResultID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_From:

	/* handler: j.From type=tgbotapi.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.From = nil

		} else {

			if j.From == nil {
				j.From = new(User)
			}

			err = j.From.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Location:

	/* handler: j.Location type=tgbotapi.Location kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Location = nil

		} else {

			if j.Location == nil {
				j.Location = new(Location)
			}

			err = j.Location.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InlineMessageID:

	/* handler: j.InlineMessageID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.InlineMessageID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Query:

	/* handler: j.Query type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Query = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Contact) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Contact) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "phone_number":`)
	fflib.WriteJsonString(buf, string(j.PhoneNumber))
	buf.WriteString(`,"first_name":`)
	fflib.WriteJsonString(buf, string(j.FirstName))
	buf.WriteByte(',')
	if len(j.LastName) != 0 {
		buf.WriteString(`"last_name":`)
		fflib.WriteJsonString(buf, string(j.LastName))
		buf.WriteByte(',')
	}
	if j.UserID != 0 {
		buf.WriteString(`"user_id":`)
		fflib.FormatBits2(buf, uint64(j.UserID), 10, j.UserID < 0)
		buf.WriteByte(',')
	}
	if len(j.VCard) != 0 {
		buf.WriteString(`"vcard":`)
		fflib.WriteJsonString(buf, string(j.VCard))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtContactbase = iota
	ffjtContactnosuchkey

	ffjtContactPhoneNumber

	ffjtContactFirstName

	ffjtContactLastName

	ffjtContactUserID

	ffjtContactVCard
)

var ffjKeyContactPhoneNumber = []byte("phone_number")

var ffjKeyContactFirstName = []byte("first_name")

var ffjKeyContactLastName = []byte("last_name")

var ffjKeyContactUserID = []byte("user_id")

var ffjKeyContactVCard = []byte("vcard")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Contact) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Contact) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtContactbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtContactnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffjKeyContactFirstName, kn) {
						currentKey = ffjtContactFirstName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyContactLastName, kn) {
						currentKey = ffjtContactLastName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyContactPhoneNumber, kn) {
						currentKey = ffjtContactPhoneNumber
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyContactUserID, kn) {
						currentKey = ffjtContactUserID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffjKeyContactVCard, kn) {
						currentKey = ffjtContactVCard
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyContactVCard, kn) {
					currentKey = ffjtContactVCard
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContactUserID, kn) {
					currentKey = ffjtContactUserID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContactLastName, kn) {
					currentKey = ffjtContactLastName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContactFirstName, kn) {
					currentKey = ffjtContactFirstName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyContactPhoneNumber, kn) {
					currentKey = ffjtContactPhoneNumber
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtContactnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtContactPhoneNumber:
					goto handle_PhoneNumber

				case ffjtContactFirstName:
					goto handle_FirstName

				case ffjtContactLastName:
					goto handle_LastName

				case ffjtContactUserID:
					goto handle_UserID

				case ffjtContactVCard:
					goto handle_VCard

				case ffjtContactnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_PhoneNumber:

	/* handler: j.PhoneNumber type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.PhoneNumber = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FirstName:

	/* handler: j.FirstName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FirstName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LastName:

	/* handler: j.LastName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.LastName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UserID:

	/* handler: j.UserID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.UserID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VCard:

	/* handler: j.VCard type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.VCard = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *CopyTextButton) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *CopyTextButton) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"text":`)
	fflib.WriteJsonString(buf, string(j.Text))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtCopyTextButtonbase = iota
	ffjtCopyTextButtonnosuchkey

	ffjtCopyTextButtonText
)

var ffjKeyCopyTextButtonText = []byte("text")

// UnmarshalJSON umarshall json - template of ffjson
func (j *CopyTextButton) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *CopyTextButton) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtCopyTextButtonbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtCopyTextButtonnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 't':

					if bytes.Equal(ffjKeyCopyTextButtonText, kn) {
						currentKey = ffjtCopyTextButtonText
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyCopyTextButtonText, kn) {
					currentKey = ffjtCopyTextButtonText
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtCopyTextButtonnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtCopyTextButtonText:
					goto handle_Text

				case ffjtCopyTextButtonnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Text:

	/* handler: j.Text type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Text = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Document) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Document) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "file_id":`)
	fflib.WriteJsonString(buf, string(j.FileID))
	buf.WriteByte(',')
	if j.Thumbnail != nil {
		if true {
			buf.WriteString(`"thumb":`)

			{

				err = j.Thumbnail.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(j.FileName) != 0 {
		buf.WriteString(`"file_name":`)
		fflib.WriteJsonString(buf, string(j.FileName))
		buf.WriteByte(',')
	}
	if len(j.MimeType) != 0 {
		buf.WriteString(`"mime_type":`)
		fflib.WriteJsonString(buf, string(j.MimeType))
		buf.WriteByte(',')
	}
	if j.FileSize != 0 {
		buf.WriteString(`"file_size":`)
		fflib.FormatBits2(buf, uint64(j.FileSize), 10, j.FileSize < 0)
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtDocumentbase = iota
	ffjtDocumentnosuchkey

	ffjtDocumentFileID

	ffjtDocumentThumbnail

	ffjtDocumentFileName

	ffjtDocumentMimeType

	ffjtDocumentFileSize
)

var ffjKeyDocumentFileID = []byte("file_id")

var ffjKeyDocumentThumbnail = []byte("thumb")

var ffjKeyDocumentFileName = []byte("file_name")

var ffjKeyDocumentMimeType = []byte("mime_type")

var ffjKeyDocumentFileSize = []byte("file_size")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Document) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Document) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtDocumentbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtDocumentnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffjKeyDocumentFileID, kn) {
						currentKey = ffjtDocumentFileID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDocumentFileName, kn) {
						currentKey = ffjtDocumentFileName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyDocumentFileSize, kn) {
						currentKey = ffjtDocumentFileSize
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyDocumentMimeType, kn) {
						currentKey = ffjtDocumentMimeType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyDocumentThumbnail, kn) {
						currentKey = ffjtDocumentThumbnail
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyDocumentFileSize, kn) {
					currentKey = ffjtDocumentFileSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyDocumentMimeType, kn) {
					currentKey = ffjtDocumentMimeType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyDocumentFileName, kn) {
					currentKey = ffjtDocumentFileName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyDocumentThumbnail, kn) {
					currentKey = ffjtDocumentThumbnail
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyDocumentFileID, kn) {
					currentKey = ffjtDocumentFileID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtDocumentnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtDocumentFileID:
					goto handle_FileID

				case ffjtDocumentThumbnail:
					goto handle_Thumbnail

				case ffjtDocumentFileName:
					goto handle_FileName

				case ffjtDocumentMimeType:
					goto handle_MimeType

				case ffjtDocumentFileSize:
					goto handle_FileSize

				case ffjtDocumentnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_FileID:

	/* handler: j.FileID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Thumbnail:

	/* handler: j.Thumbnail type=tgbotapi.PhotoSize kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Thumbnail = nil

		} else {

			if j.Thumbnail == nil {
				j.Thumbnail = new(PhotoSize)
			}

			err = j.Thumbnail.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileName:

	/* handler: j.FileName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MimeType:

	/* handler: j.MimeType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.MimeType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileSize:

	/* handler: j.FileSize type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.FileSize = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *File) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *File) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "file_id":`)
	fflib.WriteJsonString(buf, string(j.FileID))
	buf.WriteByte(',')
	if j.FileSize != 0 {
		buf.WriteString(`"file_size":`)
		fflib.FormatBits2(buf, uint64(j.FileSize), 10, j.FileSize < 0)
		buf.WriteByte(',')
	}
	if len(j.FilePath) != 0 {
		buf.WriteString(`"file_path":`)
		fflib.WriteJsonString(buf, string(j.FilePath))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtFilebase = iota
	ffjtFilenosuchkey

	ffjtFileFileID

	ffjtFileFileSize

	ffjtFileFilePath
)

var ffjKeyFileFileID = []byte("file_id")

var ffjKeyFileFileSize = []byte("file_size")

var ffjKeyFileFilePath = []byte("file_path")

// UnmarshalJSON umarshall json - template of ffjson
func (j *File) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *File) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtFilebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtFilenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffjKeyFileFileID, kn) {
						currentKey = ffjtFileFileID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFileFileSize, kn) {
						currentKey = ffjtFileFileSize
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFileFilePath, kn) {
						currentKey = ffjtFileFilePath
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyFileFilePath, kn) {
					currentKey = ffjtFileFilePath
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFileFileSize, kn) {
					currentKey = ffjtFileFileSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyFileFileID, kn) {
					currentKey = ffjtFileFileID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtFilenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtFileFileID:
					goto handle_FileID

				case ffjtFileFileSize:
					goto handle_FileSize

				case ffjtFileFilePath:
					goto handle_FilePath

				case ffjtFilenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_FileID:

	/* handler: j.FileID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileSize:

	/* handler: j.FileSize type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.FileSize = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FilePath:

	/* handler: j.FilePath type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FilePath = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ForceReply) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ForceReply) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.ForceReply {
		buf.WriteString(`{ "force_reply":true`)
	} else {
		buf.WriteString(`{ "force_reply":false`)
	}
	buf.WriteByte(',')
	if j.Selective != false {
		if j.Selective {
			buf.WriteString(`"selective":true`)
		} else {
			buf.WriteString(`"selective":false`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtForceReplybase = iota
	ffjtForceReplynosuchkey

	ffjtForceReplyForceReply

	ffjtForceReplySelective
)

var ffjKeyForceReplyForceReply = []byte("force_reply")

var ffjKeyForceReplySelective = []byte("selective")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ForceReply) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ForceReply) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtForceReplybase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtForceReplynosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffjKeyForceReplyForceReply, kn) {
						currentKey = ffjtForceReplyForceReply
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyForceReplySelective, kn) {
						currentKey = ffjtForceReplySelective
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyForceReplySelective, kn) {
					currentKey = ffjtForceReplySelective
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyForceReplyForceReply, kn) {
					currentKey = ffjtForceReplyForceReply
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtForceReplynosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtForceReplyForceReply:
					goto handle_ForceReply

				case ffjtForceReplySelective:
					goto handle_Selective

				case ffjtForceReplynosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ForceReply:

	/* handler: j.ForceReply type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.ForceReply = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.ForceReply = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Selective:

	/* handler: j.Selective type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Selective = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Selective = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *GroupChat) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *GroupChat) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"id":`)
	fflib.FormatBits2(buf, uint64(j.ID), 10, j.ID < 0)
	buf.WriteString(`,"title":`)
	fflib.WriteJsonString(buf, string(j.Title))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtGroupChatbase = iota
	ffjtGroupChatnosuchkey

	ffjtGroupChatID

	ffjtGroupChatTitle
)

var ffjKeyGroupChatID = []byte("id")

var ffjKeyGroupChatTitle = []byte("title")

// UnmarshalJSON umarshall json - template of ffjson
func (j *GroupChat) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *GroupChat) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtGroupChatbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtGroupChatnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'i':

					if bytes.Equal(ffjKeyGroupChatID, kn) {
						currentKey = ffjtGroupChatID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyGroupChatTitle, kn) {
						currentKey = ffjtGroupChatTitle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyGroupChatTitle, kn) {
					currentKey = ffjtGroupChatTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyGroupChatID, kn) {
					currentKey = ffjtGroupChatID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtGroupChatnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtGroupChatID:
					goto handle_ID

				case ffjtGroupChatTitle:
					goto handle_Title

				case ffjtGroupChatnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: j.ID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InlineKeyboardButton) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InlineKeyboardButton) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "text":`)
	fflib.WriteJsonString(buf, string(j.Text))
	buf.WriteByte(',')
	if len(j.URL) != 0 {
		buf.WriteString(`"url":`)
		fflib.WriteJsonString(buf, string(j.URL))
		buf.WriteByte(',')
	}
	if len(j.CallbackData) != 0 {
		buf.WriteString(`"callback_data":`)
		fflib.WriteJsonString(buf, string(j.CallbackData))
		buf.WriteByte(',')
	}
	if j.WebApp != nil {
		if true {
			buf.WriteString(`"web_app":`)

			{

				err = j.WebApp.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.LoginUrl != nil {
		if true {
			buf.WriteString(`"login_url":`)

			{

				err = j.LoginUrl.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.SwitchInlineQuery != nil {
		if true {
			buf.WriteString(`"switch_inline_query":`)
			fflib.WriteJsonString(buf, string(*j.SwitchInlineQuery))
			buf.WriteByte(',')
		}
	}
	if j.SwitchInlineQueryCurrentChat != nil {
		if true {
			buf.WriteString(`"switch_inline_query_current_chat":`)
			fflib.WriteJsonString(buf, string(*j.SwitchInlineQueryCurrentChat))
			buf.WriteByte(',')
		}
	}
	if j.SwitchInlineQueryChosenChat != nil {
		if true {
			buf.WriteString(`"switch_inline_query_chosen_chat":`)

			{

				err = j.SwitchInlineQueryChosenChat.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.CopyText != nil {
		if true {
			buf.WriteString(`"copy_text":`)

			{

				err = j.CopyText.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.CallbackGame != nil {
		if true {
			buf.WriteString(`"callback_game":`)

			{

				err = j.CallbackGame.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.Pay != false {
		if j.Pay {
			buf.WriteString(`"pay":true`)
		} else {
			buf.WriteString(`"pay":false`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInlineKeyboardButtonbase = iota
	ffjtInlineKeyboardButtonnosuchkey

	ffjtInlineKeyboardButtonText

	ffjtInlineKeyboardButtonURL

	ffjtInlineKeyboardButtonCallbackData

	ffjtInlineKeyboardButtonWebApp

	ffjtInlineKeyboardButtonLoginUrl

	ffjtInlineKeyboardButtonSwitchInlineQuery

	ffjtInlineKeyboardButtonSwitchInlineQueryCurrentChat

	ffjtInlineKeyboardButtonSwitchInlineQueryChosenChat

	ffjtInlineKeyboardButtonCopyText

	ffjtInlineKeyboardButtonCallbackGame

	ffjtInlineKeyboardButtonPay
)

var ffjKeyInlineKeyboardButtonText = []byte("text")

var ffjKeyInlineKeyboardButtonURL = []byte("url")

var ffjKeyInlineKeyboardButtonCallbackData = []byte("callback_data")

var ffjKeyInlineKeyboardButtonWebApp = []byte("web_app")

var ffjKeyInlineKeyboardButtonLoginUrl = []byte("login_url")

var ffjKeyInlineKeyboardButtonSwitchInlineQuery = []byte("switch_inline_query")

var ffjKeyInlineKeyboardButtonSwitchInlineQueryCurrentChat = []byte("switch_inline_query_current_chat")

var ffjKeyInlineKeyboardButtonSwitchInlineQueryChosenChat = []byte("switch_inline_query_chosen_chat")

var ffjKeyInlineKeyboardButtonCopyText = []byte("copy_text")

var ffjKeyInlineKeyboardButtonCallbackGame = []byte("callback_game")

var ffjKeyInlineKeyboardButtonPay = []byte("pay")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InlineKeyboardButton) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InlineKeyboardButton) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInlineKeyboardButtonbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInlineKeyboardButtonnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyInlineKeyboardButtonCallbackData, kn) {
						currentKey = ffjtInlineKeyboardButtonCallbackData
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineKeyboardButtonCopyText, kn) {
						currentKey = ffjtInlineKeyboardButtonCopyText
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineKeyboardButtonCallbackGame, kn) {
						currentKey = ffjtInlineKeyboardButtonCallbackGame
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyInlineKeyboardButtonLoginUrl, kn) {
						currentKey = ffjtInlineKeyboardButtonLoginUrl
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyInlineKeyboardButtonPay, kn) {
						currentKey = ffjtInlineKeyboardButtonPay
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyInlineKeyboardButtonSwitchInlineQuery, kn) {
						currentKey = ffjtInlineKeyboardButtonSwitchInlineQuery
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineKeyboardButtonSwitchInlineQueryCurrentChat, kn) {
						currentKey = ffjtInlineKeyboardButtonSwitchInlineQueryCurrentChat
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineKeyboardButtonSwitchInlineQueryChosenChat, kn) {
						currentKey = ffjtInlineKeyboardButtonSwitchInlineQueryChosenChat
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyInlineKeyboardButtonText, kn) {
						currentKey = ffjtInlineKeyboardButtonText
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyInlineKeyboardButtonURL, kn) {
						currentKey = ffjtInlineKeyboardButtonURL
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'w':

					if bytes.Equal(ffjKeyInlineKeyboardButtonWebApp, kn) {
						currentKey = ffjtInlineKeyboardButtonWebApp
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineKeyboardButtonPay, kn) {
					currentKey = ffjtInlineKeyboardButtonPay
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineKeyboardButtonCallbackGame, kn) {
					currentKey = ffjtInlineKeyboardButtonCallbackGame
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineKeyboardButtonCopyText, kn) {
					currentKey = ffjtInlineKeyboardButtonCopyText
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineKeyboardButtonSwitchInlineQueryChosenChat, kn) {
					currentKey = ffjtInlineKeyboardButtonSwitchInlineQueryChosenChat
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineKeyboardButtonSwitchInlineQueryCurrentChat, kn) {
					currentKey = ffjtInlineKeyboardButtonSwitchInlineQueryCurrentChat
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineKeyboardButtonSwitchInlineQuery, kn) {
					currentKey = ffjtInlineKeyboardButtonSwitchInlineQuery
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineKeyboardButtonLoginUrl, kn) {
					currentKey = ffjtInlineKeyboardButtonLoginUrl
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineKeyboardButtonWebApp, kn) {
					currentKey = ffjtInlineKeyboardButtonWebApp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineKeyboardButtonCallbackData, kn) {
					currentKey = ffjtInlineKeyboardButtonCallbackData
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineKeyboardButtonURL, kn) {
					currentKey = ffjtInlineKeyboardButtonURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineKeyboardButtonText, kn) {
					currentKey = ffjtInlineKeyboardButtonText
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInlineKeyboardButtonnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInlineKeyboardButtonText:
					goto handle_Text

				case ffjtInlineKeyboardButtonURL:
					goto handle_URL

				case ffjtInlineKeyboardButtonCallbackData:
					goto handle_CallbackData

				case ffjtInlineKeyboardButtonWebApp:
					goto handle_WebApp

				case ffjtInlineKeyboardButtonLoginUrl:
					goto handle_LoginUrl

				case ffjtInlineKeyboardButtonSwitchInlineQuery:
					goto handle_SwitchInlineQuery

				case ffjtInlineKeyboardButtonSwitchInlineQueryCurrentChat:
					goto handle_SwitchInlineQueryCurrentChat

				case ffjtInlineKeyboardButtonSwitchInlineQueryChosenChat:
					goto handle_SwitchInlineQueryChosenChat

				case ffjtInlineKeyboardButtonCopyText:
					goto handle_CopyText

				case ffjtInlineKeyboardButtonCallbackGame:
					goto handle_CallbackGame

				case ffjtInlineKeyboardButtonPay:
					goto handle_Pay

				case ffjtInlineKeyboardButtonnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Text:

	/* handler: j.Text type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Text = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_URL:

	/* handler: j.URL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.URL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CallbackData:

	/* handler: j.CallbackData type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.CallbackData = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_WebApp:

	/* handler: j.WebApp type=tgbotapi.WebAppInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.WebApp = nil

		} else {

			if j.WebApp == nil {
				j.WebApp = new(WebAppInfo)
			}

			err = j.WebApp.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LoginUrl:

	/* handler: j.LoginUrl type=tgbotapi.LoginUrl kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.LoginUrl = nil

		} else {

			if j.LoginUrl == nil {
				j.LoginUrl = new(LoginUrl)
			}

			err = j.LoginUrl.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SwitchInlineQuery:

	/* handler: j.SwitchInlineQuery type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.SwitchInlineQuery = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.SwitchInlineQuery = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SwitchInlineQueryCurrentChat:

	/* handler: j.SwitchInlineQueryCurrentChat type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			j.SwitchInlineQueryCurrentChat = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			j.SwitchInlineQueryCurrentChat = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SwitchInlineQueryChosenChat:

	/* handler: j.SwitchInlineQueryChosenChat type=tgbotapi.SwitchInlineQueryChosenChat kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.SwitchInlineQueryChosenChat = nil

		} else {

			if j.SwitchInlineQueryChosenChat == nil {
				j.SwitchInlineQueryChosenChat = new(SwitchInlineQueryChosenChat)
			}

			err = j.SwitchInlineQueryChosenChat.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CopyText:

	/* handler: j.CopyText type=tgbotapi.CopyTextButton kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.CopyText = nil

		} else {

			if j.CopyText == nil {
				j.CopyText = new(CopyTextButton)
			}

			err = j.CopyText.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CallbackGame:

	/* handler: j.CallbackGame type=tgbotapi.CallbackGame kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.CallbackGame = nil

		} else {

			if j.CallbackGame == nil {
				j.CallbackGame = new(CallbackGame)
			}

			err = j.CallbackGame.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Pay:

	/* handler: j.Pay type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Pay = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Pay = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InlineKeyboardMarkup) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InlineKeyboardMarkup) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"inline_keyboard":`)
	if j.InlineKeyboard != nil {
		buf.WriteString(`[`)
		for i, v := range j.InlineKeyboard {
			if i != 0 {
				buf.WriteString(`,`)
			}
			if v != nil {
				buf.WriteString(`[`)
				for i, v := range v {
					if i != 0 {
						buf.WriteString(`,`)
					}

					{

						err = v.MarshalJSONBuf(buf)
						if err != nil {
							return err
						}

					}
				}
				buf.WriteString(`]`)
			} else {
				buf.WriteString(`null`)
			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInlineKeyboardMarkupbase = iota
	ffjtInlineKeyboardMarkupnosuchkey

	ffjtInlineKeyboardMarkupInlineKeyboard
)

var ffjKeyInlineKeyboardMarkupInlineKeyboard = []byte("inline_keyboard")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InlineKeyboardMarkup) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InlineKeyboardMarkup) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInlineKeyboardMarkupbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInlineKeyboardMarkupnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'i':

					if bytes.Equal(ffjKeyInlineKeyboardMarkupInlineKeyboard, kn) {
						currentKey = ffjtInlineKeyboardMarkupInlineKeyboard
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyInlineKeyboardMarkupInlineKeyboard, kn) {
					currentKey = ffjtInlineKeyboardMarkupInlineKeyboard
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInlineKeyboardMarkupnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInlineKeyboardMarkupInlineKeyboard:
					goto handle_InlineKeyboard

				case ffjtInlineKeyboardMarkupnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_InlineKeyboard:

	/* handler: j.InlineKeyboard type=[][]tgbotapi.InlineKeyboardButton kind=slice quoted=false*/

	{
		/* Falling back. type=[][]tgbotapi.InlineKeyboardButton kind=slice */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.InlineKeyboard)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *KeyboardButton) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *KeyboardButton) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "text":`)
	fflib.WriteJsonString(buf, string(j.Text))
	buf.WriteByte(',')
	if j.RequestUsers != nil {
		if true {
			buf.WriteString(`"request_users":`)

			{

				err = j.RequestUsers.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.RequestChat != nil {
		if true {
			buf.WriteString(`"request_chat":`)

			{

				err = j.RequestChat.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.RequestContact {
		buf.WriteString(`"request_contact":true`)
	} else {
		buf.WriteString(`"request_contact":false`)
	}
	if j.RequestLocation {
		buf.WriteString(`,"request_location":true`)
	} else {
		buf.WriteString(`,"request_location":false`)
	}
	buf.WriteByte(',')
	if j.RequestPoll != nil {
		if true {
			buf.WriteString(`"request_poll":`)

			{

				err = j.RequestPoll.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.Webapp != nil {
		if true {
			buf.WriteString(`"web_app":`)

			{

				err = j.Webapp.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtKeyboardButtonbase = iota
	ffjtKeyboardButtonnosuchkey

	ffjtKeyboardButtonText

	ffjtKeyboardButtonRequestUsers

	ffjtKeyboardButtonRequestChat

	ffjtKeyboardButtonRequestContact

	ffjtKeyboardButtonRequestLocation

	ffjtKeyboardButtonRequestPoll

	ffjtKeyboardButtonWebapp
)

var ffjKeyKeyboardButtonText = []byte("text")

var ffjKeyKeyboardButtonRequestUsers = []byte("request_users")

var ffjKeyKeyboardButtonRequestChat = []byte("request_chat")

var ffjKeyKeyboardButtonRequestContact = []byte("request_contact")

var ffjKeyKeyboardButtonRequestLocation = []byte("request_location")

var ffjKeyKeyboardButtonRequestPoll = []byte("request_poll")

var ffjKeyKeyboardButtonWebapp = []byte("web_app")

// UnmarshalJSON umarshall json - template of ffjson
func (j *KeyboardButton) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *KeyboardButton) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtKeyboardButtonbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtKeyboardButtonnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'r':

					if bytes.Equal(ffjKeyKeyboardButtonRequestUsers, kn) {
						currentKey = ffjtKeyboardButtonRequestUsers
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyKeyboardButtonRequestChat, kn) {
						currentKey = ffjtKeyboardButtonRequestChat
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyKeyboardButtonRequestContact, kn) {
						currentKey = ffjtKeyboardButtonRequestContact
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyKeyboardButtonRequestLocation, kn) {
						currentKey = ffjtKeyboardButtonRequestLocation
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyKeyboardButtonRequestPoll, kn) {
						currentKey = ffjtKeyboardButtonRequestPoll
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyKeyboardButtonText, kn) {
						currentKey = ffjtKeyboardButtonText
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'w':

					if bytes.Equal(ffjKeyKeyboardButtonWebapp, kn) {
						currentKey = ffjtKeyboardButtonWebapp
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyKeyboardButtonWebapp, kn) {
					currentKey = ffjtKeyboardButtonWebapp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyKeyboardButtonRequestPoll, kn) {
					currentKey = ffjtKeyboardButtonRequestPoll
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyKeyboardButtonRequestLocation, kn) {
					currentKey = ffjtKeyboardButtonRequestLocation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyKeyboardButtonRequestContact, kn) {
					currentKey = ffjtKeyboardButtonRequestContact
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyKeyboardButtonRequestChat, kn) {
					currentKey = ffjtKeyboardButtonRequestChat
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyKeyboardButtonRequestUsers, kn) {
					currentKey = ffjtKeyboardButtonRequestUsers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyKeyboardButtonText, kn) {
					currentKey = ffjtKeyboardButtonText
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtKeyboardButtonnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtKeyboardButtonText:
					goto handle_Text

				case ffjtKeyboardButtonRequestUsers:
					goto handle_RequestUsers

				case ffjtKeyboardButtonRequestChat:
					goto handle_RequestChat

				case ffjtKeyboardButtonRequestContact:
					goto handle_RequestContact

				case ffjtKeyboardButtonRequestLocation:
					goto handle_RequestLocation

				case ffjtKeyboardButtonRequestPoll:
					goto handle_RequestPoll

				case ffjtKeyboardButtonWebapp:
					goto handle_Webapp

				case ffjtKeyboardButtonnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Text:

	/* handler: j.Text type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Text = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RequestUsers:

	/* handler: j.RequestUsers type=tgbotapi.KeyboardButtonRequestUsers kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.RequestUsers = nil

		} else {

			if j.RequestUsers == nil {
				j.RequestUsers = new(KeyboardButtonRequestUsers)
			}

			err = j.RequestUsers.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RequestChat:

	/* handler: j.RequestChat type=tgbotapi.KeyboardButtonRequestChat kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.RequestChat = nil

		} else {

			if j.RequestChat == nil {
				j.RequestChat = new(KeyboardButtonRequestChat)
			}

			err = j.RequestChat.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RequestContact:

	/* handler: j.RequestContact type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.RequestContact = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.RequestContact = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RequestLocation:

	/* handler: j.RequestLocation type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.RequestLocation = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.RequestLocation = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RequestPoll:

	/* handler: j.RequestPoll type=tgbotapi.KeyboardButtonPollType kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.RequestPoll = nil

		} else {

			if j.RequestPoll == nil {
				j.RequestPoll = new(KeyboardButtonPollType)
			}

			err = j.RequestPoll.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Webapp:

	/* handler: j.Webapp type=tgbotapi.WebAppInfo kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Webapp = nil

		} else {

			if j.Webapp == nil {
				j.Webapp = new(WebAppInfo)
			}

			err = j.Webapp.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *KeyboardButtonPollType) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *KeyboardButtonPollType) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(j.Type) != 0 {
		buf.WriteString(`"type":`)
		fflib.WriteJsonString(buf, string(j.Type))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtKeyboardButtonPollTypebase = iota
	ffjtKeyboardButtonPollTypenosuchkey

	ffjtKeyboardButtonPollTypeType
)

var ffjKeyKeyboardButtonPollTypeType = []byte("type")

// UnmarshalJSON umarshall json - template of ffjson
func (j *KeyboardButtonPollType) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *KeyboardButtonPollType) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtKeyboardButtonPollTypebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtKeyboardButtonPollTypenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 't':

					if bytes.Equal(ffjKeyKeyboardButtonPollTypeType, kn) {
						currentKey = ffjtKeyboardButtonPollTypeType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyKeyboardButtonPollTypeType, kn) {
					currentKey = ffjtKeyboardButtonPollTypeType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtKeyboardButtonPollTypenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtKeyboardButtonPollTypeType:
					goto handle_Type

				case ffjtKeyboardButtonPollTypenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *KeyboardButtonRequestChat) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *KeyboardButtonRequestChat) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "request_id":`)
	fflib.FormatBits2(buf, uint64(j.RequestID), 10, j.RequestID < 0)
	if j.ChatIsChannel {
		buf.WriteString(`,"chat_is_channel":true`)
	} else {
		buf.WriteString(`,"chat_is_channel":false`)
	}
	buf.WriteByte(',')
	if j.ChatIsForum != false {
		if j.ChatIsForum {
			buf.WriteString(`"chat_is_forum":true`)
		} else {
			buf.WriteString(`"chat_is_forum":false`)
		}
		buf.WriteByte(',')
	}
	if j.ChatHasUsername != false {
		if j.ChatHasUsername {
			buf.WriteString(`"chat_has_username":true`)
		} else {
			buf.WriteString(`"chat_has_username":false`)
		}
		buf.WriteByte(',')
	}
	if j.ChatIsCreated != false {
		if j.ChatIsCreated {
			buf.WriteString(`"chat_is_created":true`)
		} else {
			buf.WriteString(`"chat_is_created":false`)
		}
		buf.WriteByte(',')
	}
	if j.UserAdministratorRights != nil {
		if true {
			buf.WriteString(`"user_administrator_rights":`)

			{

				err = j.UserAdministratorRights.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.BotAdministratorRights != nil {
		if true {
			buf.WriteString(`"bot_administrator_rights":`)

			{

				err = j.BotAdministratorRights.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.BotIsMember != false {
		if j.BotIsMember {
			buf.WriteString(`"bot_is_member":true`)
		} else {
			buf.WriteString(`"bot_is_member":false`)
		}
		buf.WriteByte(',')
	}
	if j.RequestTitle != false {
		if j.RequestTitle {
			buf.WriteString(`"request_title":true`)
		} else {
			buf.WriteString(`"request_title":false`)
		}
		buf.WriteByte(',')
	}
	if j.RequestUsername != false {
		if j.RequestUsername {
			buf.WriteString(`"request_username":true`)
		} else {
			buf.WriteString(`"request_username":false`)
		}
		buf.WriteByte(',')
	}
	if j.RequestPhoto != false {
		if j.RequestPhoto {
			buf.WriteString(`"request_photo":true`)
		} else {
			buf.WriteString(`"request_photo":false`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtKeyboardButtonRequestChatbase = iota
	ffjtKeyboardButtonRequestChatnosuchkey

	ffjtKeyboardButtonRequestChatRequestID

	ffjtKeyboardButtonRequestChatChatIsChannel

	ffjtKeyboardButtonRequestChatChatIsForum

	ffjtKeyboardButtonRequestChatChatHasUsername

	ffjtKeyboardButtonRequestChatChatIsCreated

	ffjtKeyboardButtonRequestChatUserAdministratorRights

	ffjtKeyboardButtonRequestChatBotAdministratorRights

	ffjtKeyboardButtonRequestChatBotIsMember

	ffjtKeyboardButtonRequestChatRequestTitle

	ffjtKeyboardButtonRequestChatRequestUsername

	ffjtKeyboardButtonRequestChatRequestPhoto
)

var ffjKeyKeyboardButtonRequestChatRequestID = []byte("request_id")

var ffjKeyKeyboardButtonRequestChatChatIsChannel = []byte("chat_is_channel")

var ffjKeyKeyboardButtonRequestChatChatIsForum = []byte("chat_is_forum")

var ffjKeyKeyboardButtonRequestChatChatHasUsername = []byte("chat_has_username")

var ffjKeyKeyboardButtonRequestChatChatIsCreated = []byte("chat_is_created")

var ffjKeyKeyboardButtonRequestChatUserAdministratorRights = []byte("user_administrator_rights")

var ffjKeyKeyboardButtonRequestChatBotAdministratorRights = []byte("bot_administrator_rights")

var ffjKeyKeyboardButtonRequestChatBotIsMember = []byte("bot_is_member")

var ffjKeyKeyboardButtonRequestChatRequestTitle = []byte("request_title")

var ffjKeyKeyboardButtonRequestChatRequestUsername = []byte("request_username")

var ffjKeyKeyboardButtonRequestChatRequestPhoto = []byte("request_photo")

// UnmarshalJSON umarshall json - template of ffjson
func (j *KeyboardButtonRequestChat) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *KeyboardButtonRequestChat) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtKeyboardButtonRequestChatbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtKeyboardButtonRequestChatnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'b':

					if bytes.Equal(ffjKeyKeyboardButtonRequestChatBotAdministratorRights, kn) {
						currentKey = ffjtKeyboardButtonRequestChatBotAdministratorRights
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyKeyboardButtonRequestChatBotIsMember, kn) {
						currentKey = ffjtKeyboardButtonRequestChatBotIsMember
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyKeyboardButtonRequestChatChatIsChannel, kn) {
						currentKey = ffjtKeyboardButtonRequestChatChatIsChannel
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyKeyboardButtonRequestChatChatIsForum, kn) {
						currentKey = ffjtKeyboardButtonRequestChatChatIsForum
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyKeyboardButtonRequestChatChatHasUsername, kn) {
						currentKey = ffjtKeyboardButtonRequestChatChatHasUsername
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyKeyboardButtonRequestChatChatIsCreated, kn) {
						currentKey = ffjtKeyboardButtonRequestChatChatIsCreated
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyKeyboardButtonRequestChatRequestID, kn) {
						currentKey = ffjtKeyboardButtonRequestChatRequestID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyKeyboardButtonRequestChatRequestTitle, kn) {
						currentKey = ffjtKeyboardButtonRequestChatRequestTitle
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyKeyboardButtonRequestChatRequestUsername, kn) {
						currentKey = ffjtKeyboardButtonRequestChatRequestUsername
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyKeyboardButtonRequestChatRequestPhoto, kn) {
						currentKey = ffjtKeyboardButtonRequestChatRequestPhoto
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyKeyboardButtonRequestChatUserAdministratorRights, kn) {
						currentKey = ffjtKeyboardButtonRequestChatUserAdministratorRights
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyKeyboardButtonRequestChatRequestPhoto, kn) {
					currentKey = ffjtKeyboardButtonRequestChatRequestPhoto
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyKeyboardButtonRequestChatRequestUsername, kn) {
					currentKey = ffjtKeyboardButtonRequestChatRequestUsername
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyKeyboardButtonRequestChatRequestTitle, kn) {
					currentKey = ffjtKeyboardButtonRequestChatRequestTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyKeyboardButtonRequestChatBotIsMember, kn) {
					currentKey = ffjtKeyboardButtonRequestChatBotIsMember
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyKeyboardButtonRequestChatBotAdministratorRights, kn) {
					currentKey = ffjtKeyboardButtonRequestChatBotAdministratorRights
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyKeyboardButtonRequestChatUserAdministratorRights, kn) {
					currentKey = ffjtKeyboardButtonRequestChatUserAdministratorRights
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyKeyboardButtonRequestChatChatIsCreated, kn) {
					currentKey = ffjtKeyboardButtonRequestChatChatIsCreated
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyKeyboardButtonRequestChatChatHasUsername, kn) {
					currentKey = ffjtKeyboardButtonRequestChatChatHasUsername
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyKeyboardButtonRequestChatChatIsForum, kn) {
					currentKey = ffjtKeyboardButtonRequestChatChatIsForum
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyKeyboardButtonRequestChatChatIsChannel, kn) {
					currentKey = ffjtKeyboardButtonRequestChatChatIsChannel
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyKeyboardButtonRequestChatRequestID, kn) {
					currentKey = ffjtKeyboardButtonRequestChatRequestID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtKeyboardButtonRequestChatnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtKeyboardButtonRequestChatRequestID:
					goto handle_RequestID

				case ffjtKeyboardButtonRequestChatChatIsChannel:
					goto handle_ChatIsChannel

				case ffjtKeyboardButtonRequestChatChatIsForum:
					goto handle_ChatIsForum

				case ffjtKeyboardButtonRequestChatChatHasUsername:
					goto handle_ChatHasUsername

				case ffjtKeyboardButtonRequestChatChatIsCreated:
					goto handle_ChatIsCreated

				case ffjtKeyboardButtonRequestChatUserAdministratorRights:
					goto handle_UserAdministratorRights

				case ffjtKeyboardButtonRequestChatBotAdministratorRights:
					goto handle_BotAdministratorRights

				case ffjtKeyboardButtonRequestChatBotIsMember:
					goto handle_BotIsMember

				case ffjtKeyboardButtonRequestChatRequestTitle:
					goto handle_RequestTitle

				case ffjtKeyboardButtonRequestChatRequestUsername:
					goto handle_RequestUsername

				case ffjtKeyboardButtonRequestChatRequestPhoto:
					goto handle_RequestPhoto

				case ffjtKeyboardButtonRequestChatnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_RequestID:

	/* handler: j.RequestID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.RequestID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChatIsChannel:

	/* handler: j.ChatIsChannel type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.ChatIsChannel = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.ChatIsChannel = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChatIsForum:

	/* handler: j.ChatIsForum type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.ChatIsForum = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.ChatIsForum = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChatHasUsername:

	/* handler: j.ChatHasUsername type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.ChatHasUsername = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.ChatHasUsername = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChatIsCreated:

	/* handler: j.ChatIsCreated type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.ChatIsCreated = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.ChatIsCreated = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UserAdministratorRights:

	/* handler: j.UserAdministratorRights type=tgbotapi.ChatAdministratorRights kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.UserAdministratorRights = nil

		} else {

			if j.UserAdministratorRights == nil {
				j.UserAdministratorRights = new(ChatAdministratorRights)
			}

			err = j.UserAdministratorRights.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BotAdministratorRights:

	/* handler: j.BotAdministratorRights type=tgbotapi.ChatAdministratorRights kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.BotAdministratorRights = nil

		} else {

			if j.BotAdministratorRights == nil {
				j.BotAdministratorRights = new(ChatAdministratorRights)
			}

			err = j.BotAdministratorRights.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BotIsMember:

	/* handler: j.BotIsMember type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.BotIsMember = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.BotIsMember = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RequestTitle:

	/* handler: j.RequestTitle type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.RequestTitle = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.RequestTitle = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RequestUsername:

	/* handler: j.RequestUsername type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.RequestUsername = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.RequestUsername = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RequestPhoto:

	/* handler: j.RequestPhoto type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.RequestPhoto = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.RequestPhoto = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *KeyboardButtonRequestUsers) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *KeyboardButtonRequestUsers) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "request_id":`)
	fflib.FormatBits2(buf, uint64(j.RequestID), 10, j.RequestID < 0)
	buf.WriteByte(',')
	if j.UserIsBot != false {
		if j.UserIsBot {
			buf.WriteString(`"user_is_bot":true`)
		} else {
			buf.WriteString(`"user_is_bot":false`)
		}
		buf.WriteByte(',')
	}
	if j.UserIsPremium != false {
		if j.UserIsPremium {
			buf.WriteString(`"user_is_premium":true`)
		} else {
			buf.WriteString(`"user_is_premium":false`)
		}
		buf.WriteByte(',')
	}
	if j.MaxQuantity != 0 {
		buf.WriteString(`"max_quantity":`)
		fflib.FormatBits2(buf, uint64(j.MaxQuantity), 10, j.MaxQuantity < 0)
		buf.WriteByte(',')
	}
	if j.RequestName != false {
		if j.RequestName {
			buf.WriteString(`"request_name":true`)
		} else {
			buf.WriteString(`"request_name":false`)
		}
		buf.WriteByte(',')
	}
	if j.RequestUsername != false {
		if j.RequestUsername {
			buf.WriteString(`"request_username":true`)
		} else {
			buf.WriteString(`"request_username":false`)
		}
		buf.WriteByte(',')
	}
	if j.RequestPhoto != false {
		if j.RequestPhoto {
			buf.WriteString(`"request_photo":true`)
		} else {
			buf.WriteString(`"request_photo":false`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtKeyboardButtonRequestUsersbase = iota
	ffjtKeyboardButtonRequestUsersnosuchkey

	ffjtKeyboardButtonRequestUsersRequestID

	ffjtKeyboardButtonRequestUsersUserIsBot

	ffjtKeyboardButtonRequestUsersUserIsPremium

	ffjtKeyboardButtonRequestUsersMaxQuantity

	ffjtKeyboardButtonRequestUsersRequestName

	ffjtKeyboardButtonRequestUsersRequestUsername

	ffjtKeyboardButtonRequestUsersRequestPhoto
)

var ffjKeyKeyboardButtonRequestUsersRequestID = []byte("request_id")

var ffjKeyKeyboardButtonRequestUsersUserIsBot = []byte("user_is_bot")

var ffjKeyKeyboardButtonRequestUsersUserIsPremium = []byte("user_is_premium")

var ffjKeyKeyboardButtonRequestUsersMaxQuantity = []byte("max_quantity")

var ffjKeyKeyboardButtonRequestUsersRequestName = []byte("request_name")

var ffjKeyKeyboardButtonRequestUsersRequestUsername = []byte("request_username")

var ffjKeyKeyboardButtonRequestUsersRequestPhoto = []byte("request_photo")

// UnmarshalJSON umarshall json - template of ffjson
func (j *KeyboardButtonRequestUsers) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *KeyboardButtonRequestUsers) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtKeyboardButtonRequestUsersbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtKeyboardButtonRequestUsersnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'm':

					if bytes.Equal(ffjKeyKeyboardButtonRequestUsersMaxQuantity, kn) {
						currentKey = ffjtKeyboardButtonRequestUsersMaxQuantity
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyKeyboardButtonRequestUsersRequestID, kn) {
						currentKey = ffjtKeyboardButtonRequestUsersRequestID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyKeyboardButtonRequestUsersRequestName, kn) {
						currentKey = ffjtKeyboardButtonRequestUsersRequestName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyKeyboardButtonRequestUsersRequestUsername, kn) {
						currentKey = ffjtKeyboardButtonRequestUsersRequestUsername
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyKeyboardButtonRequestUsersRequestPhoto, kn) {
						currentKey = ffjtKeyboardButtonRequestUsersRequestPhoto
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyKeyboardButtonRequestUsersUserIsBot, kn) {
						currentKey = ffjtKeyboardButtonRequestUsersUserIsBot
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyKeyboardButtonRequestUsersUserIsPremium, kn) {
						currentKey = ffjtKeyboardButtonRequestUsersUserIsPremium
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyKeyboardButtonRequestUsersRequestPhoto, kn) {
					currentKey = ffjtKeyboardButtonRequestUsersRequestPhoto
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyKeyboardButtonRequestUsersRequestUsername, kn) {
					currentKey = ffjtKeyboardButtonRequestUsersRequestUsername
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyKeyboardButtonRequestUsersRequestName, kn) {
					currentKey = ffjtKeyboardButtonRequestUsersRequestName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyKeyboardButtonRequestUsersMaxQuantity, kn) {
					currentKey = ffjtKeyboardButtonRequestUsersMaxQuantity
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyKeyboardButtonRequestUsersUserIsPremium, kn) {
					currentKey = ffjtKeyboardButtonRequestUsersUserIsPremium
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyKeyboardButtonRequestUsersUserIsBot, kn) {
					currentKey = ffjtKeyboardButtonRequestUsersUserIsBot
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyKeyboardButtonRequestUsersRequestID, kn) {
					currentKey = ffjtKeyboardButtonRequestUsersRequestID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtKeyboardButtonRequestUsersnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtKeyboardButtonRequestUsersRequestID:
					goto handle_RequestID

				case ffjtKeyboardButtonRequestUsersUserIsBot:
					goto handle_UserIsBot

				case ffjtKeyboardButtonRequestUsersUserIsPremium:
					goto handle_UserIsPremium

				case ffjtKeyboardButtonRequestUsersMaxQuantity:
					goto handle_MaxQuantity

				case ffjtKeyboardButtonRequestUsersRequestName:
					goto handle_RequestName

				case ffjtKeyboardButtonRequestUsersRequestUsername:
					goto handle_RequestUsername

				case ffjtKeyboardButtonRequestUsersRequestPhoto:
					goto handle_RequestPhoto

				case ffjtKeyboardButtonRequestUsersnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_RequestID:

	/* handler: j.RequestID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.RequestID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UserIsBot:

	/* handler: j.UserIsBot type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.UserIsBot = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.UserIsBot = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UserIsPremium:

	/* handler: j.UserIsPremium type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.UserIsPremium = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.UserIsPremium = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MaxQuantity:

	/* handler: j.MaxQuantity type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.MaxQuantity = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RequestName:

	/* handler: j.RequestName type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.RequestName = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.RequestName = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RequestUsername:

	/* handler: j.RequestUsername type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.RequestUsername = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.RequestUsername = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RequestPhoto:

	/* handler: j.RequestPhoto type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.RequestPhoto = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.RequestPhoto = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Location) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Location) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"longitude":`)
	fflib.AppendFloat(buf, float64(j.Longitude), 'g', -1, 64)
	buf.WriteString(`,"latitude":`)
	fflib.AppendFloat(buf, float64(j.Latitude), 'g', -1, 64)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtLocationbase = iota
	ffjtLocationnosuchkey

	ffjtLocationLongitude

	ffjtLocationLatitude
)

var ffjKeyLocationLongitude = []byte("longitude")

var ffjKeyLocationLatitude = []byte("latitude")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Location) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Location) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtLocationbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtLocationnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'l':

					if bytes.Equal(ffjKeyLocationLongitude, kn) {
						currentKey = ffjtLocationLongitude
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyLocationLatitude, kn) {
						currentKey = ffjtLocationLatitude
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyLocationLatitude, kn) {
					currentKey = ffjtLocationLatitude
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyLocationLongitude, kn) {
					currentKey = ffjtLocationLongitude
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtLocationnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtLocationLongitude:
					goto handle_Longitude

				case ffjtLocationLatitude:
					goto handle_Latitude

				case ffjtLocationnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Longitude:

	/* handler: j.Longitude type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Longitude = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Latitude:

	/* handler: j.Latitude type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Latitude = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *LoginUrl) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *LoginUrl) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "url":`)
	fflib.WriteJsonString(buf, string(j.Url))
	buf.WriteByte(',')
	if len(j.ForwardText) != 0 {
		buf.WriteString(`"forward_text":`)
		fflib.WriteJsonString(buf, string(j.ForwardText))
		buf.WriteByte(',')
	}
	if len(j.BotUsername) != 0 {
		buf.WriteString(`"bot_username":`)
		fflib.WriteJsonString(buf, string(j.BotUsername))
		buf.WriteByte(',')
	}
	if j.RequestWriteAccess != false {
		if j.RequestWriteAccess {
			buf.WriteString(`"request_write_access":true`)
		} else {
			buf.WriteString(`"request_write_access":false`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtLoginUrlbase = iota
	ffjtLoginUrlnosuchkey

	ffjtLoginUrlUrl

	ffjtLoginUrlForwardText

	ffjtLoginUrlBotUsername

	ffjtLoginUrlRequestWriteAccess
)

var ffjKeyLoginUrlUrl = []byte("url")

var ffjKeyLoginUrlForwardText = []byte("forward_text")

var ffjKeyLoginUrlBotUsername = []byte("bot_username")

var ffjKeyLoginUrlRequestWriteAccess = []byte("request_write_access")

// UnmarshalJSON umarshall json - template of ffjson
func (j *LoginUrl) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *LoginUrl) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtLoginUrlbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtLoginUrlnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'b':

					if bytes.Equal(ffjKeyLoginUrlBotUsername, kn) {
						currentKey = ffjtLoginUrlBotUsername
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyLoginUrlForwardText, kn) {
						currentKey = ffjtLoginUrlForwardText
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyLoginUrlRequestWriteAccess, kn) {
						currentKey = ffjtLoginUrlRequestWriteAccess
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyLoginUrlUrl, kn) {
						currentKey = ffjtLoginUrlUrl
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyLoginUrlRequestWriteAccess, kn) {
					currentKey = ffjtLoginUrlRequestWriteAccess
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyLoginUrlBotUsername, kn) {
					currentKey = ffjtLoginUrlBotUsername
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyLoginUrlForwardText, kn) {
					currentKey = ffjtLoginUrlForwardText
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyLoginUrlUrl, kn) {
					currentKey = ffjtLoginUrlUrl
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtLoginUrlnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtLoginUrlUrl:
					goto handle_Url

				case ffjtLoginUrlForwardText:
					goto handle_ForwardText

				case ffjtLoginUrlBotUsername:
					goto handle_BotUsername

				case ffjtLoginUrlRequestWriteAccess:
					goto handle_RequestWriteAccess

				case ffjtLoginUrlnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Url:

	/* handler: j.Url type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Url = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ForwardText:

	/* handler: j.ForwardText type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ForwardText = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BotUsername:

	/* handler: j.BotUsername type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.BotUsername = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RequestWriteAccess:

	/* handler: j.RequestWriteAccess type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.RequestWriteAccess = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.RequestWriteAccess = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *MessageEntity) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *MessageEntity) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"offset":`)
	fflib.FormatBits2(buf, uint64(j.Offset), 10, j.Offset < 0)
	buf.WriteString(`,"length":`)
	fflib.FormatBits2(buf, uint64(j.Length), 10, j.Length < 0)
	buf.WriteByte(',')
	if len(j.URL) != 0 {
		buf.WriteString(`"url":`)
		fflib.WriteJsonString(buf, string(j.URL))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtMessageEntitybase = iota
	ffjtMessageEntitynosuchkey

	ffjtMessageEntityType

	ffjtMessageEntityOffset

	ffjtMessageEntityLength

	ffjtMessageEntityURL
)

var ffjKeyMessageEntityType = []byte("type")

var ffjKeyMessageEntityOffset = []byte("offset")

var ffjKeyMessageEntityLength = []byte("length")

var ffjKeyMessageEntityURL = []byte("url")

// UnmarshalJSON umarshall json - template of ffjson
func (j *MessageEntity) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *MessageEntity) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtMessageEntitybase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtMessageEntitynosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'l':

					if bytes.Equal(ffjKeyMessageEntityLength, kn) {
						currentKey = ffjtMessageEntityLength
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffjKeyMessageEntityOffset, kn) {
						currentKey = ffjtMessageEntityOffset
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyMessageEntityType, kn) {
						currentKey = ffjtMessageEntityType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyMessageEntityURL, kn) {
						currentKey = ffjtMessageEntityURL
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageEntityURL, kn) {
					currentKey = ffjtMessageEntityURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageEntityLength, kn) {
					currentKey = ffjtMessageEntityLength
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageEntityOffset, kn) {
					currentKey = ffjtMessageEntityOffset
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageEntityType, kn) {
					currentKey = ffjtMessageEntityType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtMessageEntitynosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtMessageEntityType:
					goto handle_Type

				case ffjtMessageEntityOffset:
					goto handle_Offset

				case ffjtMessageEntityLength:
					goto handle_Length

				case ffjtMessageEntityURL:
					goto handle_URL

				case ffjtMessageEntitynosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Offset:

	/* handler: j.Offset type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Offset = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Length:

	/* handler: j.Length type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Length = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_URL:

	/* handler: j.URL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.URL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ReplyKeyboardHide) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ReplyKeyboardHide) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.HideKeyboard {
		buf.WriteString(`{ "hide_keyboard":true`)
	} else {
		buf.WriteString(`{ "hide_keyboard":false`)
	}
	buf.WriteByte(',')
	if j.Selective != false {
		if j.Selective {
			buf.WriteString(`"selective":true`)
		} else {
			buf.WriteString(`"selective":false`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtReplyKeyboardHidebase = iota
	ffjtReplyKeyboardHidenosuchkey

	ffjtReplyKeyboardHideHideKeyboard

	ffjtReplyKeyboardHideSelective
)

var ffjKeyReplyKeyboardHideHideKeyboard = []byte("hide_keyboard")

var ffjKeyReplyKeyboardHideSelective = []byte("selective")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ReplyKeyboardHide) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ReplyKeyboardHide) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtReplyKeyboardHidebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtReplyKeyboardHidenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'h':

					if bytes.Equal(ffjKeyReplyKeyboardHideHideKeyboard, kn) {
						currentKey = ffjtReplyKeyboardHideHideKeyboard
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyReplyKeyboardHideSelective, kn) {
						currentKey = ffjtReplyKeyboardHideSelective
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyReplyKeyboardHideSelective, kn) {
					currentKey = ffjtReplyKeyboardHideSelective
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyReplyKeyboardHideHideKeyboard, kn) {
					currentKey = ffjtReplyKeyboardHideHideKeyboard
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtReplyKeyboardHidenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtReplyKeyboardHideHideKeyboard:
					goto handle_HideKeyboard

				case ffjtReplyKeyboardHideSelective:
					goto handle_Selective

				case ffjtReplyKeyboardHidenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_HideKeyboard:

	/* handler: j.HideKeyboard type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.HideKeyboard = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.HideKeyboard = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Selective:

	/* handler: j.Selective type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Selective = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Selective = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ReplyKeyboardMarkup) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ReplyKeyboardMarkup) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "keyboard":`)
	if j.Keyboard != nil {
		buf.WriteString(`[`)
		for i, v := range j.Keyboard {
			if i != 0 {
				buf.WriteString(`,`)
			}
			if v != nil {
				buf.WriteString(`[`)
				for i, v := range v {
					if i != 0 {
						buf.WriteString(`,`)
					}

					{

						err = v.MarshalJSONBuf(buf)
						if err != nil {
							return err
						}

					}
				}
				buf.WriteString(`]`)
			} else {
				buf.WriteString(`null`)
			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if j.ResizeKeyboard != false {
		if j.ResizeKeyboard {
			buf.WriteString(`"resize_keyboard":true`)
		} else {
			buf.WriteString(`"resize_keyboard":false`)
		}
		buf.WriteByte(',')
	}
	if j.OneTimeKeyboard != false {
		if j.OneTimeKeyboard {
			buf.WriteString(`"one_time_keyboard":true`)
		} else {
			buf.WriteString(`"one_time_keyboard":false`)
		}
		buf.WriteByte(',')
	}
	if j.Selective != false {
		if j.Selective {
			buf.WriteString(`"selective":true`)
		} else {
			buf.WriteString(`"selective":false`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtReplyKeyboardMarkupbase = iota
	ffjtReplyKeyboardMarkupnosuchkey

	ffjtReplyKeyboardMarkupKeyboard

	ffjtReplyKeyboardMarkupResizeKeyboard

	ffjtReplyKeyboardMarkupOneTimeKeyboard

	ffjtReplyKeyboardMarkupSelective
)

var ffjKeyReplyKeyboardMarkupKeyboard = []byte("keyboard")

var ffjKeyReplyKeyboardMarkupResizeKeyboard = []byte("resize_keyboard")

var ffjKeyReplyKeyboardMarkupOneTimeKeyboard = []byte("one_time_keyboard")

var ffjKeyReplyKeyboardMarkupSelective = []byte("selective")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ReplyKeyboardMarkup) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ReplyKeyboardMarkup) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtReplyKeyboardMarkupbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtReplyKeyboardMarkupnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'k':

					if bytes.Equal(ffjKeyReplyKeyboardMarkupKeyboard, kn) {
						currentKey = ffjtReplyKeyboardMarkupKeyboard
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffjKeyReplyKeyboardMarkupOneTimeKeyboard, kn) {
						currentKey = ffjtReplyKeyboardMarkupOneTimeKeyboard
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyReplyKeyboardMarkupResizeKeyboard, kn) {
						currentKey = ffjtReplyKeyboardMarkupResizeKeyboard
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyReplyKeyboardMarkupSelective, kn) {
						currentKey = ffjtReplyKeyboardMarkupSelective
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyReplyKeyboardMarkupSelective, kn) {
					currentKey = ffjtReplyKeyboardMarkupSelective
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyReplyKeyboardMarkupOneTimeKeyboard, kn) {
					currentKey = ffjtReplyKeyboardMarkupOneTimeKeyboard
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyReplyKeyboardMarkupResizeKeyboard, kn) {
					currentKey = ffjtReplyKeyboardMarkupResizeKeyboard
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyReplyKeyboardMarkupKeyboard, kn) {
					currentKey = ffjtReplyKeyboardMarkupKeyboard
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtReplyKeyboardMarkupnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtReplyKeyboardMarkupKeyboard:
					goto handle_Keyboard

				case ffjtReplyKeyboardMarkupResizeKeyboard:
					goto handle_ResizeKeyboard

				case ffjtReplyKeyboardMarkupOneTimeKeyboard:
					goto handle_OneTimeKeyboard

				case ffjtReplyKeyboardMarkupSelective:
					goto handle_Selective

				case ffjtReplyKeyboardMarkupnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Keyboard:

	/* handler: j.Keyboard type=[][]tgbotapi.KeyboardButton kind=slice quoted=false*/

	{
		/* Falling back. type=[][]tgbotapi.KeyboardButton kind=slice */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.Keyboard)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ResizeKeyboard:

	/* handler: j.ResizeKeyboard type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.ResizeKeyboard = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.ResizeKeyboard = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OneTimeKeyboard:

	/* handler: j.OneTimeKeyboard type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.OneTimeKeyboard = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.OneTimeKeyboard = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Selective:

	/* handler: j.Selective type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Selective = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Selective = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Sticker) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Sticker) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "file_id":`)
	fflib.WriteJsonString(buf, string(j.FileID))
	buf.WriteString(`,"width":`)
	fflib.FormatBits2(buf, uint64(j.Width), 10, j.Width < 0)
	buf.WriteString(`,"height":`)
	fflib.FormatBits2(buf, uint64(j.Height), 10, j.Height < 0)
	buf.WriteByte(',')
	if j.Thumbnail != nil {
		if true {
			buf.WriteString(`"thumb":`)

			{

				err = j.Thumbnail.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if j.FileSize != 0 {
		buf.WriteString(`"file_size":`)
		fflib.FormatBits2(buf, uint64(j.FileSize), 10, j.FileSize < 0)
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtStickerbase = iota
	ffjtStickernosuchkey

	ffjtStickerFileID

	ffjtStickerWidth

	ffjtStickerHeight

	ffjtStickerThumbnail

	ffjtStickerFileSize
)

var ffjKeyStickerFileID = []byte("file_id")

var ffjKeyStickerWidth = []byte("width")

var ffjKeyStickerHeight = []byte("height")

var ffjKeyStickerThumbnail = []byte("thumb")

var ffjKeyStickerFileSize = []byte("file_size")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Sticker) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Sticker) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtStickerbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtStickernosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffjKeyStickerFileID, kn) {
						currentKey = ffjtStickerFileID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyStickerFileSize, kn) {
						currentKey = ffjtStickerFileSize
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffjKeyStickerHeight, kn) {
						currentKey = ffjtStickerHeight
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyStickerThumbnail, kn) {
						currentKey = ffjtStickerThumbnail
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'w':

					if bytes.Equal(ffjKeyStickerWidth, kn) {
						currentKey = ffjtStickerWidth
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyStickerFileSize, kn) {
					currentKey = ffjtStickerFileSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyStickerThumbnail, kn) {
					currentKey = ffjtStickerThumbnail
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyStickerHeight, kn) {
					currentKey = ffjtStickerHeight
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyStickerWidth, kn) {
					currentKey = ffjtStickerWidth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyStickerFileID, kn) {
					currentKey = ffjtStickerFileID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtStickernosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtStickerFileID:
					goto handle_FileID

				case ffjtStickerWidth:
					goto handle_Width

				case ffjtStickerHeight:
					goto handle_Height

				case ffjtStickerThumbnail:
					goto handle_Thumbnail

				case ffjtStickerFileSize:
					goto handle_FileSize

				case ffjtStickernosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_FileID:

	/* handler: j.FileID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Width:

	/* handler: j.Width type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Width = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Height:

	/* handler: j.Height type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Height = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Thumbnail:

	/* handler: j.Thumbnail type=tgbotapi.PhotoSize kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Thumbnail = nil

		} else {

			if j.Thumbnail == nil {
				j.Thumbnail = new(PhotoSize)
			}

			err = j.Thumbnail.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileSize:

	/* handler: j.FileSize type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.FileSize = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *SwitchInlineQueryChosenChat) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *SwitchInlineQueryChosenChat) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(j.Query) != 0 {
		buf.WriteString(`"query":`)
		fflib.WriteJsonString(buf, string(j.Query))
		buf.WriteByte(',')
	}
	if j.AllowUserChats != false {
		if j.AllowUserChats {
			buf.WriteString(`"allow_user_chats":true`)
		} else {
			buf.WriteString(`"allow_user_chats":false`)
		}
		buf.WriteByte(',')
	}
	if j.AllowBotChats != false {
		if j.AllowBotChats {
			buf.WriteString(`"allow_bot_chats":true`)
		} else {
			buf.WriteString(`"allow_bot_chats":false`)
		}
		buf.WriteByte(',')
	}
	if j.AllowGroupChats != false {
		if j.AllowGroupChats {
			buf.WriteString(`"allow_group_chats":true`)
		} else {
			buf.WriteString(`"allow_group_chats":false`)
		}
		buf.WriteByte(',')
	}
	if j.AllowChannelChats != false {
		if j.AllowChannelChats {
			buf.WriteString(`"allow_channel_chats":true`)
		} else {
			buf.WriteString(`"allow_channel_chats":false`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtSwitchInlineQueryChosenChatbase = iota
	ffjtSwitchInlineQueryChosenChatnosuchkey

	ffjtSwitchInlineQueryChosenChatQuery

	ffjtSwitchInlineQueryChosenChatAllowUserChats

	ffjtSwitchInlineQueryChosenChatAllowBotChats

	ffjtSwitchInlineQueryChosenChatAllowGroupChats

	ffjtSwitchInlineQueryChosenChatAllowChannelChats
)

var ffjKeySwitchInlineQueryChosenChatQuery = []byte("query")

var ffjKeySwitchInlineQueryChosenChatAllowUserChats = []byte("allow_user_chats")

var ffjKeySwitchInlineQueryChosenChatAllowBotChats = []byte("allow_bot_chats")

var ffjKeySwitchInlineQueryChosenChatAllowGroupChats = []byte("allow_group_chats")

var ffjKeySwitchInlineQueryChosenChatAllowChannelChats = []byte("allow_channel_chats")

// UnmarshalJSON umarshall json - template of ffjson
func (j *SwitchInlineQueryChosenChat) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *SwitchInlineQueryChosenChat) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtSwitchInlineQueryChosenChatbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtSwitchInlineQueryChosenChatnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeySwitchInlineQueryChosenChatAllowUserChats, kn) {
						currentKey = ffjtSwitchInlineQueryChosenChatAllowUserChats
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeySwitchInlineQueryChosenChatAllowBotChats, kn) {
						currentKey = ffjtSwitchInlineQueryChosenChatAllowBotChats
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeySwitchInlineQueryChosenChatAllowGroupChats, kn) {
						currentKey = ffjtSwitchInlineQueryChosenChatAllowGroupChats
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeySwitchInlineQueryChosenChatAllowChannelChats, kn) {
						currentKey = ffjtSwitchInlineQueryChosenChatAllowChannelChats
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'q':

					if bytes.Equal(ffjKeySwitchInlineQueryChosenChatQuery, kn) {
						currentKey = ffjtSwitchInlineQueryChosenChatQuery
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeySwitchInlineQueryChosenChatAllowChannelChats, kn) {
					currentKey = ffjtSwitchInlineQueryChosenChatAllowChannelChats
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySwitchInlineQueryChosenChatAllowGroupChats, kn) {
					currentKey = ffjtSwitchInlineQueryChosenChatAllowGroupChats
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySwitchInlineQueryChosenChatAllowBotChats, kn) {
					currentKey = ffjtSwitchInlineQueryChosenChatAllowBotChats
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeySwitchInlineQueryChosenChatAllowUserChats, kn) {
					currentKey = ffjtSwitchInlineQueryChosenChatAllowUserChats
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeySwitchInlineQueryChosenChatQuery, kn) {
					currentKey = ffjtSwitchInlineQueryChosenChatQuery
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtSwitchInlineQueryChosenChatnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtSwitchInlineQueryChosenChatQuery:
					goto handle_Query

				case ffjtSwitchInlineQueryChosenChatAllowUserChats:
					goto handle_AllowUserChats

				case ffjtSwitchInlineQueryChosenChatAllowBotChats:
					goto handle_AllowBotChats

				case ffjtSwitchInlineQueryChosenChatAllowGroupChats:
					goto handle_AllowGroupChats

				case ffjtSwitchInlineQueryChosenChatAllowChannelChats:
					goto handle_AllowChannelChats

				case ffjtSwitchInlineQueryChosenChatnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Query:

	/* handler: j.Query type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Query = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AllowUserChats:

	/* handler: j.AllowUserChats type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.AllowUserChats = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.AllowUserChats = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AllowBotChats:

	/* handler: j.AllowBotChats type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.AllowBotChats = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.AllowBotChats = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AllowGroupChats:

	/* handler: j.AllowGroupChats type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.AllowGroupChats = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.AllowGroupChats = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AllowChannelChats:

	/* handler: j.AllowChannelChats type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.AllowChannelChats = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.AllowChannelChats = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *User) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *User) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "id":`)
	fflib.FormatBits2(buf, uint64(j.ID), 10, j.ID < 0)
	buf.WriteByte(',')
	if len(j.FirstName) != 0 {
		buf.WriteString(`"first_name":`)
		fflib.WriteJsonString(buf, string(j.FirstName))
		buf.WriteByte(',')
	}
	if len(j.LastName) != 0 {
		buf.WriteString(`"last_name":`)
		fflib.WriteJsonString(buf, string(j.LastName))
		buf.WriteByte(',')
	}
	if len(j.UserName) != 0 {
		buf.WriteString(`"username":`)
		fflib.WriteJsonString(buf, string(j.UserName))
		buf.WriteByte(',')
	}
	if len(j.LanguageCode) != 0 {
		buf.WriteString(`"language_code":`)
		fflib.WriteJsonString(buf, string(j.LanguageCode))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtUserbase = iota
	ffjtUsernosuchkey

	ffjtUserID

	ffjtUserFirstName

	ffjtUserLastName

	ffjtUserUserName

	ffjtUserLanguageCode
)

var ffjKeyUserID = []byte("id")

var ffjKeyUserFirstName = []byte("first_name")

var ffjKeyUserLastName = []byte("last_name")

var ffjKeyUserUserName = []byte("username")

var ffjKeyUserLanguageCode = []byte("language_code")

// UnmarshalJSON umarshall json - template of ffjson
func (j *User) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *User) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtUserbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtUsernosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffjKeyUserFirstName, kn) {
						currentKey = ffjtUserFirstName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyUserID, kn) {
						currentKey = ffjtUserID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyUserLastName, kn) {
						currentKey = ffjtUserLastName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyUserLanguageCode, kn) {
						currentKey = ffjtUserLanguageCode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyUserUserName, kn) {
						currentKey = ffjtUserUserName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyUserLanguageCode, kn) {
					currentKey = ffjtUserLanguageCode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserUserName, kn) {
					currentKey = ffjtUserUserName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserLastName, kn) {
					currentKey = ffjtUserLastName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyUserFirstName, kn) {
					currentKey = ffjtUserFirstName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyUserID, kn) {
					currentKey = ffjtUserID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtUsernosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtUserID:
					goto handle_ID

				case ffjtUserFirstName:
					goto handle_FirstName

				case ffjtUserLastName:
					goto handle_LastName

				case ffjtUserUserName:
					goto handle_UserName

				case ffjtUserLanguageCode:
					goto handle_LanguageCode

				case ffjtUsernosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: j.ID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FirstName:

	/* handler: j.FirstName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FirstName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LastName:

	/* handler: j.LastName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.LastName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UserName:

	/* handler: j.UserName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.UserName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LanguageCode:

	/* handler: j.LanguageCode type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.LanguageCode = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *UserProfilePhotos) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *UserProfilePhotos) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"total_count":`)
	fflib.FormatBits2(buf, uint64(j.TotalCount), 10, j.TotalCount < 0)
	buf.WriteString(`,"photos":`)
	if j.Photos != nil {
		buf.WriteString(`[`)
		for i, v := range j.Photos {
			if i != 0 {
				buf.WriteString(`,`)
			}
			if v != nil {
				buf.WriteString(`[`)
				for i, v := range v {
					if i != 0 {
						buf.WriteString(`,`)
					}

					{

						err = v.MarshalJSONBuf(buf)
						if err != nil {
							return err
						}

					}
				}
				buf.WriteString(`]`)
			} else {
				buf.WriteString(`null`)
			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffjtUserProfilePhotosbase = iota
	ffjtUserProfilePhotosnosuchkey

	ffjtUserProfilePhotosTotalCount

	ffjtUserProfilePhotosPhotos
)

var ffjKeyUserProfilePhotosTotalCount = []byte("total_count")

var ffjKeyUserProfilePhotosPhotos = []byte("photos")

// UnmarshalJSON umarshall json - template of ffjson
func (j *UserProfilePhotos) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *UserProfilePhotos) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtUserProfilePhotosbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtUserProfilePhotosnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'p':

					if bytes.Equal(ffjKeyUserProfilePhotosPhotos, kn) {
						currentKey = ffjtUserProfilePhotosPhotos
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyUserProfilePhotosTotalCount, kn) {
						currentKey = ffjtUserProfilePhotosTotalCount
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyUserProfilePhotosPhotos, kn) {
					currentKey = ffjtUserProfilePhotosPhotos
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyUserProfilePhotosTotalCount, kn) {
					currentKey = ffjtUserProfilePhotosTotalCount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtUserProfilePhotosnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtUserProfilePhotosTotalCount:
					goto handle_TotalCount

				case ffjtUserProfilePhotosPhotos:
					goto handle_Photos

				case ffjtUserProfilePhotosnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_TotalCount:

	/* handler: j.TotalCount type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.TotalCount = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Photos:

	/* handler: j.Photos type=[][]tgbotapi.PhotoSize kind=slice quoted=false*/

	{
		/* Falling back. type=[][]tgbotapi.PhotoSize kind=slice */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.Photos)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Venue) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Venue) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "location":`)

	{

		err = j.Location.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"title":`)
	fflib.WriteJsonString(buf, string(j.Title))
	buf.WriteString(`,"address":`)
	fflib.WriteJsonString(buf, string(j.Address))
	buf.WriteByte(',')
	if len(j.FoursquareID) != 0 {
		buf.WriteString(`"foursquare_id":`)
		fflib.WriteJsonString(buf, string(j.FoursquareID))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtVenuebase = iota
	ffjtVenuenosuchkey

	ffjtVenueLocation

	ffjtVenueTitle

	ffjtVenueAddress

	ffjtVenueFoursquareID
)

var ffjKeyVenueLocation = []byte("location")

var ffjKeyVenueTitle = []byte("title")

var ffjKeyVenueAddress = []byte("address")

var ffjKeyVenueFoursquareID = []byte("foursquare_id")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Venue) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Venue) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtVenuebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtVenuenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyVenueAddress, kn) {
						currentKey = ffjtVenueAddress
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyVenueFoursquareID, kn) {
						currentKey = ffjtVenueFoursquareID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyVenueLocation, kn) {
						currentKey = ffjtVenueLocation
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyVenueTitle, kn) {
						currentKey = ffjtVenueTitle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyVenueFoursquareID, kn) {
					currentKey = ffjtVenueFoursquareID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyVenueAddress, kn) {
					currentKey = ffjtVenueAddress
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyVenueTitle, kn) {
					currentKey = ffjtVenueTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyVenueLocation, kn) {
					currentKey = ffjtVenueLocation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtVenuenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtVenueLocation:
					goto handle_Location

				case ffjtVenueTitle:
					goto handle_Title

				case ffjtVenueAddress:
					goto handle_Address

				case ffjtVenueFoursquareID:
					goto handle_FoursquareID

				case ffjtVenuenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Location:

	/* handler: j.Location type=tgbotapi.Location kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			err = j.Location.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Address:

	/* handler: j.Address type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Address = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FoursquareID:

	/* handler: j.FoursquareID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FoursquareID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Video) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Video) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "file_id":`)
	fflib.WriteJsonString(buf, string(j.FileID))
	buf.WriteString(`,"width":`)
	fflib.FormatBits2(buf, uint64(j.Width), 10, j.Width < 0)
	buf.WriteString(`,"height":`)
	fflib.FormatBits2(buf, uint64(j.Height), 10, j.Height < 0)
	buf.WriteString(`,"duration":`)
	fflib.FormatBits2(buf, uint64(j.Duration), 10, j.Duration < 0)
	buf.WriteByte(',')
	if j.Thumbnail != nil {
		if true {
			buf.WriteString(`"thumb":`)

			{

				err = j.Thumbnail.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(j.MimeType) != 0 {
		buf.WriteString(`"mime_type":`)
		fflib.WriteJsonString(buf, string(j.MimeType))
		buf.WriteByte(',')
	}
	if j.FileSize != 0 {
		buf.WriteString(`"file_size":`)
		fflib.FormatBits2(buf, uint64(j.FileSize), 10, j.FileSize < 0)
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtVideobase = iota
	ffjtVideonosuchkey

	ffjtVideoFileID

	ffjtVideoWidth

	ffjtVideoHeight

	ffjtVideoDuration

	ffjtVideoThumbnail

	ffjtVideoMimeType

	ffjtVideoFileSize
)

var ffjKeyVideoFileID = []byte("file_id")

var ffjKeyVideoWidth = []byte("width")

var ffjKeyVideoHeight = []byte("height")

var ffjKeyVideoDuration = []byte("duration")

var ffjKeyVideoThumbnail = []byte("thumb")

var ffjKeyVideoMimeType = []byte("mime_type")

var ffjKeyVideoFileSize = []byte("file_size")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Video) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Video) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtVideobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtVideonosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffjKeyVideoDuration, kn) {
						currentKey = ffjtVideoDuration
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyVideoFileID, kn) {
						currentKey = ffjtVideoFileID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyVideoFileSize, kn) {
						currentKey = ffjtVideoFileSize
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffjKeyVideoHeight, kn) {
						currentKey = ffjtVideoHeight
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyVideoMimeType, kn) {
						currentKey = ffjtVideoMimeType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyVideoThumbnail, kn) {
						currentKey = ffjtVideoThumbnail
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'w':

					if bytes.Equal(ffjKeyVideoWidth, kn) {
						currentKey = ffjtVideoWidth
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyVideoFileSize, kn) {
					currentKey = ffjtVideoFileSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyVideoMimeType, kn) {
					currentKey = ffjtVideoMimeType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyVideoThumbnail, kn) {
					currentKey = ffjtVideoThumbnail
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyVideoDuration, kn) {
					currentKey = ffjtVideoDuration
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyVideoHeight, kn) {
					currentKey = ffjtVideoHeight
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyVideoWidth, kn) {
					currentKey = ffjtVideoWidth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyVideoFileID, kn) {
					currentKey = ffjtVideoFileID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtVideonosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtVideoFileID:
					goto handle_FileID

				case ffjtVideoWidth:
					goto handle_Width

				case ffjtVideoHeight:
					goto handle_Height

				case ffjtVideoDuration:
					goto handle_Duration

				case ffjtVideoThumbnail:
					goto handle_Thumbnail

				case ffjtVideoMimeType:
					goto handle_MimeType

				case ffjtVideoFileSize:
					goto handle_FileSize

				case ffjtVideonosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_FileID:

	/* handler: j.FileID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Width:

	/* handler: j.Width type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Width = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Height:

	/* handler: j.Height type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Height = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Duration:

	/* handler: j.Duration type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Duration = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Thumbnail:

	/* handler: j.Thumbnail type=tgbotapi.PhotoSize kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.Thumbnail = nil

		} else {

			if j.Thumbnail == nil {
				j.Thumbnail = new(PhotoSize)
			}

			err = j.Thumbnail.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MimeType:

	/* handler: j.MimeType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.MimeType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileSize:

	/* handler: j.FileSize type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.FileSize = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *Voice) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Voice) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "file_id":`)
	fflib.WriteJsonString(buf, string(j.FileID))
	buf.WriteString(`,"duration":`)
	fflib.FormatBits2(buf, uint64(j.Duration), 10, j.Duration < 0)
	buf.WriteByte(',')
	if len(j.MimeType) != 0 {
		buf.WriteString(`"mime_type":`)
		fflib.WriteJsonString(buf, string(j.MimeType))
		buf.WriteByte(',')
	}
	if j.FileSize != 0 {
		buf.WriteString(`"file_size":`)
		fflib.FormatBits2(buf, uint64(j.FileSize), 10, j.FileSize < 0)
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtVoicebase = iota
	ffjtVoicenosuchkey

	ffjtVoiceFileID

	ffjtVoiceDuration

	ffjtVoiceMimeType

	ffjtVoiceFileSize
)

var ffjKeyVoiceFileID = []byte("file_id")

var ffjKeyVoiceDuration = []byte("duration")

var ffjKeyVoiceMimeType = []byte("mime_type")

var ffjKeyVoiceFileSize = []byte("file_size")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Voice) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Voice) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtVoicebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtVoicenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffjKeyVoiceDuration, kn) {
						currentKey = ffjtVoiceDuration
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyVoiceFileID, kn) {
						currentKey = ffjtVoiceFileID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyVoiceFileSize, kn) {
						currentKey = ffjtVoiceFileSize
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyVoiceMimeType, kn) {
						currentKey = ffjtVoiceMimeType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyVoiceFileSize, kn) {
					currentKey = ffjtVoiceFileSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyVoiceMimeType, kn) {
					currentKey = ffjtVoiceMimeType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyVoiceDuration, kn) {
					currentKey = ffjtVoiceDuration
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyVoiceFileID, kn) {
					currentKey = ffjtVoiceFileID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtVoicenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtVoiceFileID:
					goto handle_FileID

				case ffjtVoiceDuration:
					goto handle_Duration

				case ffjtVoiceMimeType:
					goto handle_MimeType

				case ffjtVoiceFileSize:
					goto handle_FileSize

				case ffjtVoicenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_FileID:

	/* handler: j.FileID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FileID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Duration:

	/* handler: j.Duration type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Duration = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MimeType:

	/* handler: j.MimeType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.MimeType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileSize:

	/* handler: j.FileSize type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.FileSize = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *WebAppInfo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *WebAppInfo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"url":`)
	fflib.WriteJsonString(buf, string(j.Url))
	buf.WriteByte('}')
	return nil
}

const (
	ffjtWebAppInfobase = iota
	ffjtWebAppInfonosuchkey

	ffjtWebAppInfoUrl
)

var ffjKeyWebAppInfoUrl = []byte("url")

// UnmarshalJSON umarshall json - template of ffjson
func (j *WebAppInfo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *WebAppInfo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtWebAppInfobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtWebAppInfonosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'u':

					if bytes.Equal(ffjKeyWebAppInfoUrl, kn) {
						currentKey = ffjtWebAppInfoUrl
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyWebAppInfoUrl, kn) {
					currentKey = ffjtWebAppInfoUrl
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtWebAppInfonosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtWebAppInfoUrl:
					goto handle_Url

				case ffjtWebAppInfonosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Url:

	/* handler: j.Url type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Url = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}
