// Code generated by ffjson <https://github.com/pquerna/ffjson>. DO NOT EDIT.
// source: message.go

package tgbotapi

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	fflib "github.com/pquerna/ffjson/fflib/v1"
)

// MarshalJSON marshal bytes to json - template
func (j *Message) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Message) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "message_id":`)
	fflib.FormatBits2(buf, uint64(j.MessageID), 10, j.MessageID < 0)
	buf.WriteByte(',')
	if j.From != nil {
		if true {
			/* Struct fall back. type=tgbotapi.User kind=struct */
			buf.WriteString(`"from":`)
			err = buf.Encode(j.From)
			if err != nil {
				return err
			}
			buf.WriteByte(',')
		}
	}
	buf.WriteString(`"date":`)
	fflib.FormatBits2(buf, uint64(j.Date), 10, j.Date < 0)
	buf.WriteByte(',')
	if j.Chat != nil {
		if true {
			/* Struct fall back. type=tgbotapi.Chat kind=struct */
			buf.WriteString(`"chat":`)
			err = buf.Encode(j.Chat)
			if err != nil {
				return err
			}
			buf.WriteByte(',')
		}
	}
	if j.UserShared != nil {
		if true {
			/* Struct fall back. type=tgbotapi.UserShared kind=struct */
			buf.WriteString(`"user_shared":`)
			err = buf.Encode(j.UserShared)
			if err != nil {
				return err
			}
			buf.WriteByte(',')
		}
	}
	if j.UsersShared != nil {
		if true {
			/* Struct fall back. type=tgbotapi.UsersShared kind=struct */
			buf.WriteString(`"users_shared":`)
			err = buf.Encode(j.UsersShared)
			if err != nil {
				return err
			}
			buf.WriteByte(',')
		}
	}
	if j.ForwardFrom != nil {
		if true {
			/* Struct fall back. type=tgbotapi.User kind=struct */
			buf.WriteString(`"forward_from":`)
			err = buf.Encode(j.ForwardFrom)
			if err != nil {
				return err
			}
			buf.WriteByte(',')
		}
	}
	if j.ForwardDate != 0 {
		buf.WriteString(`"forward_date":`)
		fflib.FormatBits2(buf, uint64(j.ForwardDate), 10, j.ForwardDate < 0)
		buf.WriteByte(',')
	}
	if j.ReplyToMessage != nil {
		if true {
			buf.WriteString(`"reply_to_message":`)

			{

				err = j.ReplyToMessage.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(j.Text) != 0 {
		buf.WriteString(`"text":`)
		fflib.WriteJsonString(buf, string(j.Text))
		buf.WriteByte(',')
	}
	if j.Entities != nil {
		if true {
			buf.WriteString(`"entities":`)
			if j.Entities != nil {
				buf.WriteString(`[`)
				for i, v := range *j.Entities {
					if i != 0 {
						buf.WriteString(`,`)
					}
					/* Struct fall back. type=tgbotapi.MessageEntity kind=struct */
					err = buf.Encode(&v)
					if err != nil {
						return err
					}
				}
				buf.WriteString(`]`)
			} else {
				buf.WriteString(`null`)
			}
			buf.WriteByte(',')
		}
	}
	if j.Audio != nil {
		if true {
			/* Struct fall back. type=tgbotapi.Audio kind=struct */
			buf.WriteString(`"audio":`)
			err = buf.Encode(j.Audio)
			if err != nil {
				return err
			}
			buf.WriteByte(',')
		}
	}
	if j.Document != nil {
		if true {
			/* Struct fall back. type=tgbotapi.Document kind=struct */
			buf.WriteString(`"document":`)
			err = buf.Encode(j.Document)
			if err != nil {
				return err
			}
			buf.WriteByte(',')
		}
	}
	if j.Photo != nil {
		if true {
			buf.WriteString(`"photo":`)
			if j.Photo != nil {
				buf.WriteString(`[`)
				for i, v := range *j.Photo {
					if i != 0 {
						buf.WriteString(`,`)
					}
					/* Struct fall back. type=tgbotapi.PhotoSize kind=struct */
					err = buf.Encode(&v)
					if err != nil {
						return err
					}
				}
				buf.WriteString(`]`)
			} else {
				buf.WriteString(`null`)
			}
			buf.WriteByte(',')
		}
	}
	if j.Sticker != nil {
		if true {
			/* Struct fall back. type=tgbotapi.Sticker kind=struct */
			buf.WriteString(`"sticker":`)
			err = buf.Encode(j.Sticker)
			if err != nil {
				return err
			}
			buf.WriteByte(',')
		}
	}
	if j.Video != nil {
		if true {
			/* Struct fall back. type=tgbotapi.Video kind=struct */
			buf.WriteString(`"video":`)
			err = buf.Encode(j.Video)
			if err != nil {
				return err
			}
			buf.WriteByte(',')
		}
	}
	if j.Voice != nil {
		if true {
			/* Struct fall back. type=tgbotapi.Voice kind=struct */
			buf.WriteString(`"voice":`)
			err = buf.Encode(j.Voice)
			if err != nil {
				return err
			}
			buf.WriteByte(',')
		}
	}
	if len(j.Caption) != 0 {
		buf.WriteString(`"caption":`)
		fflib.WriteJsonString(buf, string(j.Caption))
		buf.WriteByte(',')
	}
	if j.Contact != nil {
		if true {
			/* Struct fall back. type=tgbotapi.Contact kind=struct */
			buf.WriteString(`"contact":`)
			err = buf.Encode(j.Contact)
			if err != nil {
				return err
			}
			buf.WriteByte(',')
		}
	}
	if j.Location != nil {
		if true {
			/* Struct fall back. type=tgbotapi.Location kind=struct */
			buf.WriteString(`"location":`)
			err = buf.Encode(j.Location)
			if err != nil {
				return err
			}
			buf.WriteByte(',')
		}
	}
	if j.Venue != nil {
		if true {
			/* Struct fall back. type=tgbotapi.Venue kind=struct */
			buf.WriteString(`"venue":`)
			err = buf.Encode(j.Venue)
			if err != nil {
				return err
			}
			buf.WriteByte(',')
		}
	}
	if j.NewChatParticipant != nil {
		if true {
			/* Struct fall back. type=tgbotapi.ChatMember kind=struct */
			buf.WriteString(`"new_chat_participant":`)
			err = buf.Encode(j.NewChatParticipant)
			if err != nil {
				return err
			}
			buf.WriteByte(',')
		}
	}
	if j.NewChatMember != nil {
		if true {
			/* Struct fall back. type=tgbotapi.ChatMember kind=struct */
			buf.WriteString(`"new_chat_member":`)
			err = buf.Encode(j.NewChatMember)
			if err != nil {
				return err
			}
			buf.WriteByte(',')
		}
	}
	if len(j.NewChatMembers) != 0 {
		buf.WriteString(`"new_chat_members":`)
		if j.NewChatMembers != nil {
			buf.WriteString(`[`)
			for i, v := range j.NewChatMembers {
				if i != 0 {
					buf.WriteString(`,`)
				}
				/* Struct fall back. type=tgbotapi.ChatMember kind=struct */
				err = buf.Encode(&v)
				if err != nil {
					return err
				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if j.LeftChatMember != nil {
		if true {
			/* Struct fall back. type=tgbotapi.ChatMember kind=struct */
			buf.WriteString(`"left_chat_member":`)
			err = buf.Encode(j.LeftChatMember)
			if err != nil {
				return err
			}
			buf.WriteByte(',')
		}
	}
	if len(j.NewChatTitle) != 0 {
		buf.WriteString(`"new_chat_title":`)
		fflib.WriteJsonString(buf, string(j.NewChatTitle))
		buf.WriteByte(',')
	}
	if j.NewChatPhoto != nil {
		if true {
			buf.WriteString(`"new_chat_photo":`)
			if j.NewChatPhoto != nil {
				buf.WriteString(`[`)
				for i, v := range *j.NewChatPhoto {
					if i != 0 {
						buf.WriteString(`,`)
					}
					/* Struct fall back. type=tgbotapi.PhotoSize kind=struct */
					err = buf.Encode(&v)
					if err != nil {
						return err
					}
				}
				buf.WriteString(`]`)
			} else {
				buf.WriteString(`null`)
			}
			buf.WriteByte(',')
		}
	}
	if j.DeleteChatPhoto != false {
		if j.DeleteChatPhoto {
			buf.WriteString(`"delete_chat_photo":true`)
		} else {
			buf.WriteString(`"delete_chat_photo":false`)
		}
		buf.WriteByte(',')
	}
	if j.GroupChatCreated != false {
		if j.GroupChatCreated {
			buf.WriteString(`"group_chat_created":true`)
		} else {
			buf.WriteString(`"group_chat_created":false`)
		}
		buf.WriteByte(',')
	}
	if j.SuperGroupChatCreated != false {
		if j.SuperGroupChatCreated {
			buf.WriteString(`"supergroup_chat_created":true`)
		} else {
			buf.WriteString(`"supergroup_chat_created":false`)
		}
		buf.WriteByte(',')
	}
	if j.ChannelChatCreated != false {
		if j.ChannelChatCreated {
			buf.WriteString(`"channel_chat_created":true`)
		} else {
			buf.WriteString(`"channel_chat_created":false`)
		}
		buf.WriteByte(',')
	}
	if j.MigrateToChatID != 0 {
		buf.WriteString(`"migrate_to_chat_id":`)
		fflib.FormatBits2(buf, uint64(j.MigrateToChatID), 10, j.MigrateToChatID < 0)
		buf.WriteByte(',')
	}
	if j.MigrateFromChatID != 0 {
		buf.WriteString(`"migrate_from_chat_id":`)
		fflib.FormatBits2(buf, uint64(j.MigrateFromChatID), 10, j.MigrateFromChatID < 0)
		buf.WriteByte(',')
	}
	if j.PinnedMessage != nil {
		if true {
			buf.WriteString(`"pinned_message":`)

			{

				err = j.PinnedMessage.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtMessagebase = iota
	ffjtMessagenosuchkey

	ffjtMessageMessageID

	ffjtMessageFrom

	ffjtMessageDate

	ffjtMessageChat

	ffjtMessageUserShared

	ffjtMessageUsersShared

	ffjtMessageForwardFrom

	ffjtMessageForwardDate

	ffjtMessageReplyToMessage

	ffjtMessageText

	ffjtMessageEntities

	ffjtMessageAudio

	ffjtMessageDocument

	ffjtMessagePhoto

	ffjtMessageSticker

	ffjtMessageVideo

	ffjtMessageVoice

	ffjtMessageCaption

	ffjtMessageContact

	ffjtMessageLocation

	ffjtMessageVenue

	ffjtMessageNewChatParticipant

	ffjtMessageNewChatMember

	ffjtMessageNewChatMembers

	ffjtMessageLeftChatMember

	ffjtMessageNewChatTitle

	ffjtMessageNewChatPhoto

	ffjtMessageDeleteChatPhoto

	ffjtMessageGroupChatCreated

	ffjtMessageSuperGroupChatCreated

	ffjtMessageChannelChatCreated

	ffjtMessageMigrateToChatID

	ffjtMessageMigrateFromChatID

	ffjtMessagePinnedMessage
)

var ffjKeyMessageMessageID = []byte("message_id")

var ffjKeyMessageFrom = []byte("from")

var ffjKeyMessageDate = []byte("date")

var ffjKeyMessageChat = []byte("chat")

var ffjKeyMessageUserShared = []byte("user_shared")

var ffjKeyMessageUsersShared = []byte("users_shared")

var ffjKeyMessageForwardFrom = []byte("forward_from")

var ffjKeyMessageForwardDate = []byte("forward_date")

var ffjKeyMessageReplyToMessage = []byte("reply_to_message")

var ffjKeyMessageText = []byte("text")

var ffjKeyMessageEntities = []byte("entities")

var ffjKeyMessageAudio = []byte("audio")

var ffjKeyMessageDocument = []byte("document")

var ffjKeyMessagePhoto = []byte("photo")

var ffjKeyMessageSticker = []byte("sticker")

var ffjKeyMessageVideo = []byte("video")

var ffjKeyMessageVoice = []byte("voice")

var ffjKeyMessageCaption = []byte("caption")

var ffjKeyMessageContact = []byte("contact")

var ffjKeyMessageLocation = []byte("location")

var ffjKeyMessageVenue = []byte("venue")

var ffjKeyMessageNewChatParticipant = []byte("new_chat_participant")

var ffjKeyMessageNewChatMember = []byte("new_chat_member")

var ffjKeyMessageNewChatMembers = []byte("new_chat_members")

var ffjKeyMessageLeftChatMember = []byte("left_chat_member")

var ffjKeyMessageNewChatTitle = []byte("new_chat_title")

var ffjKeyMessageNewChatPhoto = []byte("new_chat_photo")

var ffjKeyMessageDeleteChatPhoto = []byte("delete_chat_photo")

var ffjKeyMessageGroupChatCreated = []byte("group_chat_created")

var ffjKeyMessageSuperGroupChatCreated = []byte("supergroup_chat_created")

var ffjKeyMessageChannelChatCreated = []byte("channel_chat_created")

var ffjKeyMessageMigrateToChatID = []byte("migrate_to_chat_id")

var ffjKeyMessageMigrateFromChatID = []byte("migrate_from_chat_id")

var ffjKeyMessagePinnedMessage = []byte("pinned_message")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Message) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Message) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtMessagebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtMessagenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyMessageAudio, kn) {
						currentKey = ffjtMessageAudio
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyMessageChat, kn) {
						currentKey = ffjtMessageChat
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageCaption, kn) {
						currentKey = ffjtMessageCaption
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageContact, kn) {
						currentKey = ffjtMessageContact
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageChannelChatCreated, kn) {
						currentKey = ffjtMessageChannelChatCreated
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyMessageDate, kn) {
						currentKey = ffjtMessageDate
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageDocument, kn) {
						currentKey = ffjtMessageDocument
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageDeleteChatPhoto, kn) {
						currentKey = ffjtMessageDeleteChatPhoto
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyMessageEntities, kn) {
						currentKey = ffjtMessageEntities
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyMessageFrom, kn) {
						currentKey = ffjtMessageFrom
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageForwardFrom, kn) {
						currentKey = ffjtMessageForwardFrom
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageForwardDate, kn) {
						currentKey = ffjtMessageForwardDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyMessageGroupChatCreated, kn) {
						currentKey = ffjtMessageGroupChatCreated
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyMessageLocation, kn) {
						currentKey = ffjtMessageLocation
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageLeftChatMember, kn) {
						currentKey = ffjtMessageLeftChatMember
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyMessageMessageID, kn) {
						currentKey = ffjtMessageMessageID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageMigrateToChatID, kn) {
						currentKey = ffjtMessageMigrateToChatID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageMigrateFromChatID, kn) {
						currentKey = ffjtMessageMigrateFromChatID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyMessageNewChatParticipant, kn) {
						currentKey = ffjtMessageNewChatParticipant
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageNewChatMember, kn) {
						currentKey = ffjtMessageNewChatMember
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageNewChatMembers, kn) {
						currentKey = ffjtMessageNewChatMembers
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageNewChatTitle, kn) {
						currentKey = ffjtMessageNewChatTitle
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageNewChatPhoto, kn) {
						currentKey = ffjtMessageNewChatPhoto
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyMessagePhoto, kn) {
						currentKey = ffjtMessagePhoto
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessagePinnedMessage, kn) {
						currentKey = ffjtMessagePinnedMessage
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyMessageReplyToMessage, kn) {
						currentKey = ffjtMessageReplyToMessage
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyMessageSticker, kn) {
						currentKey = ffjtMessageSticker
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageSuperGroupChatCreated, kn) {
						currentKey = ffjtMessageSuperGroupChatCreated
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyMessageText, kn) {
						currentKey = ffjtMessageText
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyMessageUserShared, kn) {
						currentKey = ffjtMessageUserShared
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageUsersShared, kn) {
						currentKey = ffjtMessageUsersShared
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffjKeyMessageVideo, kn) {
						currentKey = ffjtMessageVideo
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageVoice, kn) {
						currentKey = ffjtMessageVoice
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyMessageVenue, kn) {
						currentKey = ffjtMessageVenue
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyMessagePinnedMessage, kn) {
					currentKey = ffjtMessagePinnedMessage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageMigrateFromChatID, kn) {
					currentKey = ffjtMessageMigrateFromChatID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageMigrateToChatID, kn) {
					currentKey = ffjtMessageMigrateToChatID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageChannelChatCreated, kn) {
					currentKey = ffjtMessageChannelChatCreated
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageSuperGroupChatCreated, kn) {
					currentKey = ffjtMessageSuperGroupChatCreated
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageGroupChatCreated, kn) {
					currentKey = ffjtMessageGroupChatCreated
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageDeleteChatPhoto, kn) {
					currentKey = ffjtMessageDeleteChatPhoto
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageNewChatPhoto, kn) {
					currentKey = ffjtMessageNewChatPhoto
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageNewChatTitle, kn) {
					currentKey = ffjtMessageNewChatTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageLeftChatMember, kn) {
					currentKey = ffjtMessageLeftChatMember
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageNewChatMembers, kn) {
					currentKey = ffjtMessageNewChatMembers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageNewChatMember, kn) {
					currentKey = ffjtMessageNewChatMember
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageNewChatParticipant, kn) {
					currentKey = ffjtMessageNewChatParticipant
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageVenue, kn) {
					currentKey = ffjtMessageVenue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageLocation, kn) {
					currentKey = ffjtMessageLocation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageContact, kn) {
					currentKey = ffjtMessageContact
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageCaption, kn) {
					currentKey = ffjtMessageCaption
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageVoice, kn) {
					currentKey = ffjtMessageVoice
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageVideo, kn) {
					currentKey = ffjtMessageVideo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageSticker, kn) {
					currentKey = ffjtMessageSticker
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessagePhoto, kn) {
					currentKey = ffjtMessagePhoto
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageDocument, kn) {
					currentKey = ffjtMessageDocument
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageAudio, kn) {
					currentKey = ffjtMessageAudio
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageEntities, kn) {
					currentKey = ffjtMessageEntities
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageText, kn) {
					currentKey = ffjtMessageText
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageReplyToMessage, kn) {
					currentKey = ffjtMessageReplyToMessage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageForwardDate, kn) {
					currentKey = ffjtMessageForwardDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyMessageForwardFrom, kn) {
					currentKey = ffjtMessageForwardFrom
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageUsersShared, kn) {
					currentKey = ffjtMessageUsersShared
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageUserShared, kn) {
					currentKey = ffjtMessageUserShared
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageChat, kn) {
					currentKey = ffjtMessageChat
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageDate, kn) {
					currentKey = ffjtMessageDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyMessageFrom, kn) {
					currentKey = ffjtMessageFrom
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyMessageMessageID, kn) {
					currentKey = ffjtMessageMessageID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtMessagenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtMessageMessageID:
					goto handle_MessageID

				case ffjtMessageFrom:
					goto handle_From

				case ffjtMessageDate:
					goto handle_Date

				case ffjtMessageChat:
					goto handle_Chat

				case ffjtMessageUserShared:
					goto handle_UserShared

				case ffjtMessageUsersShared:
					goto handle_UsersShared

				case ffjtMessageForwardFrom:
					goto handle_ForwardFrom

				case ffjtMessageForwardDate:
					goto handle_ForwardDate

				case ffjtMessageReplyToMessage:
					goto handle_ReplyToMessage

				case ffjtMessageText:
					goto handle_Text

				case ffjtMessageEntities:
					goto handle_Entities

				case ffjtMessageAudio:
					goto handle_Audio

				case ffjtMessageDocument:
					goto handle_Document

				case ffjtMessagePhoto:
					goto handle_Photo

				case ffjtMessageSticker:
					goto handle_Sticker

				case ffjtMessageVideo:
					goto handle_Video

				case ffjtMessageVoice:
					goto handle_Voice

				case ffjtMessageCaption:
					goto handle_Caption

				case ffjtMessageContact:
					goto handle_Contact

				case ffjtMessageLocation:
					goto handle_Location

				case ffjtMessageVenue:
					goto handle_Venue

				case ffjtMessageNewChatParticipant:
					goto handle_NewChatParticipant

				case ffjtMessageNewChatMember:
					goto handle_NewChatMember

				case ffjtMessageNewChatMembers:
					goto handle_NewChatMembers

				case ffjtMessageLeftChatMember:
					goto handle_LeftChatMember

				case ffjtMessageNewChatTitle:
					goto handle_NewChatTitle

				case ffjtMessageNewChatPhoto:
					goto handle_NewChatPhoto

				case ffjtMessageDeleteChatPhoto:
					goto handle_DeleteChatPhoto

				case ffjtMessageGroupChatCreated:
					goto handle_GroupChatCreated

				case ffjtMessageSuperGroupChatCreated:
					goto handle_SuperGroupChatCreated

				case ffjtMessageChannelChatCreated:
					goto handle_ChannelChatCreated

				case ffjtMessageMigrateToChatID:
					goto handle_MigrateToChatID

				case ffjtMessageMigrateFromChatID:
					goto handle_MigrateFromChatID

				case ffjtMessagePinnedMessage:
					goto handle_PinnedMessage

				case ffjtMessagenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_MessageID:

	/* handler: j.MessageID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.MessageID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_From:

	/* handler: j.From type=tgbotapi.User kind=struct quoted=false*/

	{
		/* Falling back. type=tgbotapi.User kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.From)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Date:

	/* handler: j.Date type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Date = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Chat:

	/* handler: j.Chat type=tgbotapi.Chat kind=struct quoted=false*/

	{
		/* Falling back. type=tgbotapi.Chat kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.Chat)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UserShared:

	/* handler: j.UserShared type=tgbotapi.UserShared kind=struct quoted=false*/

	{
		/* Falling back. type=tgbotapi.UserShared kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.UserShared)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UsersShared:

	/* handler: j.UsersShared type=tgbotapi.UsersShared kind=struct quoted=false*/

	{
		/* Falling back. type=tgbotapi.UsersShared kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.UsersShared)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ForwardFrom:

	/* handler: j.ForwardFrom type=tgbotapi.User kind=struct quoted=false*/

	{
		/* Falling back. type=tgbotapi.User kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.ForwardFrom)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ForwardDate:

	/* handler: j.ForwardDate type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ForwardDate = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyToMessage:

	/* handler: j.ReplyToMessage type=tgbotapi.Message kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ReplyToMessage = nil

		} else {

			if j.ReplyToMessage == nil {
				j.ReplyToMessage = new(Message)
			}

			err = j.ReplyToMessage.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Text:

	/* handler: j.Text type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Text = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Entities:

	/* handler: j.Entities type=[]tgbotapi.MessageEntity kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Entities = nil
		} else {

			j.Entities = &[]MessageEntity{}

			wantVal := true

			for {

				var tmpJEntities MessageEntity

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJEntities type=tgbotapi.MessageEntity kind=struct quoted=false*/

				{
					/* Falling back. type=tgbotapi.MessageEntity kind=struct */
					tbuf, err := fs.CaptureField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}

					err = json.Unmarshal(tbuf, &tmpJEntities)
					if err != nil {
						return fs.WrapErr(err)
					}
				}

				*j.Entities = append(*j.Entities, tmpJEntities)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Audio:

	/* handler: j.Audio type=tgbotapi.Audio kind=struct quoted=false*/

	{
		/* Falling back. type=tgbotapi.Audio kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.Audio)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Document:

	/* handler: j.Document type=tgbotapi.Document kind=struct quoted=false*/

	{
		/* Falling back. type=tgbotapi.Document kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.Document)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Photo:

	/* handler: j.Photo type=[]tgbotapi.PhotoSize kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Photo = nil
		} else {

			j.Photo = &[]PhotoSize{}

			wantVal := true

			for {

				var tmpJPhoto PhotoSize

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJPhoto type=tgbotapi.PhotoSize kind=struct quoted=false*/

				{
					/* Falling back. type=tgbotapi.PhotoSize kind=struct */
					tbuf, err := fs.CaptureField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}

					err = json.Unmarshal(tbuf, &tmpJPhoto)
					if err != nil {
						return fs.WrapErr(err)
					}
				}

				*j.Photo = append(*j.Photo, tmpJPhoto)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Sticker:

	/* handler: j.Sticker type=tgbotapi.Sticker kind=struct quoted=false*/

	{
		/* Falling back. type=tgbotapi.Sticker kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.Sticker)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Video:

	/* handler: j.Video type=tgbotapi.Video kind=struct quoted=false*/

	{
		/* Falling back. type=tgbotapi.Video kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.Video)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Voice:

	/* handler: j.Voice type=tgbotapi.Voice kind=struct quoted=false*/

	{
		/* Falling back. type=tgbotapi.Voice kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.Voice)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Caption:

	/* handler: j.Caption type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Caption = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Contact:

	/* handler: j.Contact type=tgbotapi.Contact kind=struct quoted=false*/

	{
		/* Falling back. type=tgbotapi.Contact kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.Contact)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Location:

	/* handler: j.Location type=tgbotapi.Location kind=struct quoted=false*/

	{
		/* Falling back. type=tgbotapi.Location kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.Location)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Venue:

	/* handler: j.Venue type=tgbotapi.Venue kind=struct quoted=false*/

	{
		/* Falling back. type=tgbotapi.Venue kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.Venue)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NewChatParticipant:

	/* handler: j.NewChatParticipant type=tgbotapi.ChatMember kind=struct quoted=false*/

	{
		/* Falling back. type=tgbotapi.ChatMember kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.NewChatParticipant)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NewChatMember:

	/* handler: j.NewChatMember type=tgbotapi.ChatMember kind=struct quoted=false*/

	{
		/* Falling back. type=tgbotapi.ChatMember kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.NewChatMember)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NewChatMembers:

	/* handler: j.NewChatMembers type=[]tgbotapi.ChatMember kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.NewChatMembers = nil
		} else {

			j.NewChatMembers = []ChatMember{}

			wantVal := true

			for {

				var tmpJNewChatMembers ChatMember

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJNewChatMembers type=tgbotapi.ChatMember kind=struct quoted=false*/

				{
					/* Falling back. type=tgbotapi.ChatMember kind=struct */
					tbuf, err := fs.CaptureField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}

					err = json.Unmarshal(tbuf, &tmpJNewChatMembers)
					if err != nil {
						return fs.WrapErr(err)
					}
				}

				j.NewChatMembers = append(j.NewChatMembers, tmpJNewChatMembers)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LeftChatMember:

	/* handler: j.LeftChatMember type=tgbotapi.ChatMember kind=struct quoted=false*/

	{
		/* Falling back. type=tgbotapi.ChatMember kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.LeftChatMember)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NewChatTitle:

	/* handler: j.NewChatTitle type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.NewChatTitle = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NewChatPhoto:

	/* handler: j.NewChatPhoto type=[]tgbotapi.PhotoSize kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.NewChatPhoto = nil
		} else {

			j.NewChatPhoto = &[]PhotoSize{}

			wantVal := true

			for {

				var tmpJNewChatPhoto PhotoSize

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJNewChatPhoto type=tgbotapi.PhotoSize kind=struct quoted=false*/

				{
					/* Falling back. type=tgbotapi.PhotoSize kind=struct */
					tbuf, err := fs.CaptureField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}

					err = json.Unmarshal(tbuf, &tmpJNewChatPhoto)
					if err != nil {
						return fs.WrapErr(err)
					}
				}

				*j.NewChatPhoto = append(*j.NewChatPhoto, tmpJNewChatPhoto)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DeleteChatPhoto:

	/* handler: j.DeleteChatPhoto type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.DeleteChatPhoto = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.DeleteChatPhoto = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GroupChatCreated:

	/* handler: j.GroupChatCreated type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.GroupChatCreated = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.GroupChatCreated = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SuperGroupChatCreated:

	/* handler: j.SuperGroupChatCreated type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.SuperGroupChatCreated = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.SuperGroupChatCreated = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChannelChatCreated:

	/* handler: j.ChannelChatCreated type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.ChannelChatCreated = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.ChannelChatCreated = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MigrateToChatID:

	/* handler: j.MigrateToChatID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.MigrateToChatID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MigrateFromChatID:

	/* handler: j.MigrateFromChatID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.MigrateFromChatID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PinnedMessage:

	/* handler: j.PinnedMessage type=tgbotapi.Message kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.PinnedMessage = nil

		} else {

			if j.PinnedMessage == nil {
				j.PinnedMessage = new(Message)
			}

			err = j.PinnedMessage.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}
