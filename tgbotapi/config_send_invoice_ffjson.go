// Code generated by ffjson <https://github.com/pquerna/ffjson>. DO NOT EDIT.
// source: config_send_invoice.go

package tgbotapi

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	fflib "github.com/pquerna/ffjson/fflib/v1"
)

// MarshalJSON marshal bytes to json - template
func (j *InvoiceConfig) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InvoiceConfig) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "title":`)
	fflib.WriteJsonString(buf, string(j.Title))
	buf.WriteString(`,"description":`)
	fflib.WriteJsonString(buf, string(j.Description))
	buf.WriteString(`,"payload":`)
	fflib.WriteJsonString(buf, string(j.Payload))
	buf.WriteByte(',')
	if len(j.ProviderToken) != 0 {
		buf.WriteString(`"provider_token":`)
		fflib.WriteJsonString(buf, string(j.ProviderToken))
		buf.WriteByte(',')
	}
	buf.WriteString(`"currency":`)
	fflib.WriteJsonString(buf, string(j.Currency))
	buf.WriteString(`,"prices":`)
	if j.Prices != nil {
		buf.WriteString(`[`)
		for i, v := range j.Prices {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if j.MaxTipAmount != 0 {
		buf.WriteString(`"max_tip_amount":`)
		fflib.FormatBits2(buf, uint64(j.MaxTipAmount), 10, j.MaxTipAmount < 0)
		buf.WriteByte(',')
	}
	if len(j.SuggestedTipAmounts) != 0 {
		buf.WriteString(`"suggested_tip_amounts":`)
		if j.SuggestedTipAmounts != nil {
			buf.WriteString(`[`)
			for i, v := range j.SuggestedTipAmounts {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.FormatBits2(buf, uint64(v), 10, v < 0)
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.StartParameter) != 0 {
		buf.WriteString(`"start_parameter":`)
		fflib.WriteJsonString(buf, string(j.StartParameter))
		buf.WriteByte(',')
	}
	if len(j.ProviderData) != 0 {
		buf.WriteString(`"provider_data":`)
		fflib.WriteJsonString(buf, string(j.ProviderData))
		buf.WriteByte(',')
	}
	if len(j.PhotoURL) != 0 {
		buf.WriteString(`"photo_url":`)
		fflib.WriteJsonString(buf, string(j.PhotoURL))
		buf.WriteByte(',')
	}
	if j.PhotoSize != 0 {
		buf.WriteString(`"photo_size":`)
		fflib.FormatBits2(buf, uint64(j.PhotoSize), 10, j.PhotoSize < 0)
		buf.WriteByte(',')
	}
	if j.PhotoWidth != 0 {
		buf.WriteString(`"photo_width":`)
		fflib.FormatBits2(buf, uint64(j.PhotoWidth), 10, j.PhotoWidth < 0)
		buf.WriteByte(',')
	}
	if j.PhotoHeight != 0 {
		buf.WriteString(`"photo_height":`)
		fflib.FormatBits2(buf, uint64(j.PhotoHeight), 10, j.PhotoHeight < 0)
		buf.WriteByte(',')
	}
	if j.NeedName != false {
		if j.NeedName {
			buf.WriteString(`"need_name":true`)
		} else {
			buf.WriteString(`"need_name":false`)
		}
		buf.WriteByte(',')
	}
	if j.NeedPhoneNumber != false {
		if j.NeedPhoneNumber {
			buf.WriteString(`"need_phone_number":true`)
		} else {
			buf.WriteString(`"need_phone_number":false`)
		}
		buf.WriteByte(',')
	}
	if j.NeedEmail != false {
		if j.NeedEmail {
			buf.WriteString(`"need_email":true`)
		} else {
			buf.WriteString(`"need_email":false`)
		}
		buf.WriteByte(',')
	}
	if j.NeedShippingAddress != false {
		if j.NeedShippingAddress {
			buf.WriteString(`"need_shipping_address":true`)
		} else {
			buf.WriteString(`"need_shipping_address":false`)
		}
		buf.WriteByte(',')
	}
	if j.SendPhoneNumberToProvider != false {
		if j.SendPhoneNumberToProvider {
			buf.WriteString(`"send_phone_number_to_provider":true`)
		} else {
			buf.WriteString(`"send_phone_number_to_provider":false`)
		}
		buf.WriteByte(',')
	}
	if j.SendEmailToProvider != false {
		if j.SendEmailToProvider {
			buf.WriteString(`"send_email_to_provider":true`)
		} else {
			buf.WriteString(`"send_email_to_provider":false`)
		}
		buf.WriteByte(',')
	}
	if j.IsFlexible != false {
		if j.IsFlexible {
			buf.WriteString(`"is_flexible":true`)
		} else {
			buf.WriteString(`"is_flexible":false`)
		}
		buf.WriteByte(',')
	}
	if j.ChatID != 0 {
		buf.WriteString(`"chat_id":`)
		fflib.FormatBits2(buf, uint64(j.ChatID), 10, j.ChatID < 0)
		buf.WriteByte(',')
	}
	if len(j.ChannelUsername) != 0 {
		buf.WriteString(`"channel_username":`)
		fflib.WriteJsonString(buf, string(j.ChannelUsername))
		buf.WriteByte(',')
	}
	if j.ReplyToMessageID != 0 {
		buf.WriteString(`"reply_to_message_id":`)
		fflib.FormatBits2(buf, uint64(j.ReplyToMessageID), 10, j.ReplyToMessageID < 0)
		buf.WriteByte(',')
	}
	if j.ReplyMarkup != nil {
		buf.WriteString(`"reply_markup":`)
		/* Interface types must use runtime reflection. type=interface {} kind=interface */
		err = buf.Encode(j.ReplyMarkup)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	if j.DisableNotification != false {
		if j.DisableNotification {
			buf.WriteString(`"disable_notification":true`)
		} else {
			buf.WriteString(`"disable_notification":false`)
		}
		buf.WriteByte(',')
	}
	if j.ProtectContent != false {
		if j.ProtectContent {
			buf.WriteString(`"protect_content":true`)
		} else {
			buf.WriteString(`"protect_content":false`)
		}
		buf.WriteByte(',')
	}
	if j.MessageThreadID != 0 {
		buf.WriteString(`"message_thread_id":`)
		fflib.FormatBits2(buf, uint64(j.MessageThreadID), 10, j.MessageThreadID < 0)
		buf.WriteByte(',')
	}
	if len(j.MessageEffectID) != 0 {
		buf.WriteString(`"message_effect_id":`)
		fflib.WriteJsonString(buf, string(j.MessageEffectID))
		buf.WriteByte(',')
	}
	if j.AllowPaidBroadcast != false {
		if j.AllowPaidBroadcast {
			buf.WriteString(`"allow_paid_broadcast":true`)
		} else {
			buf.WriteString(`"allow_paid_broadcast":false`)
		}
		buf.WriteByte(',')
	}
	if j.ReplyParameters != nil {
		if true {
			buf.WriteString(`"reply_parameters":`)

			{

				err = j.ReplyParameters.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInvoiceConfigbase = iota
	ffjtInvoiceConfignosuchkey

	ffjtInvoiceConfigTitle

	ffjtInvoiceConfigDescription

	ffjtInvoiceConfigPayload

	ffjtInvoiceConfigProviderToken

	ffjtInvoiceConfigCurrency

	ffjtInvoiceConfigPrices

	ffjtInvoiceConfigMaxTipAmount

	ffjtInvoiceConfigSuggestedTipAmounts

	ffjtInvoiceConfigStartParameter

	ffjtInvoiceConfigProviderData

	ffjtInvoiceConfigPhotoURL

	ffjtInvoiceConfigPhotoSize

	ffjtInvoiceConfigPhotoWidth

	ffjtInvoiceConfigPhotoHeight

	ffjtInvoiceConfigNeedName

	ffjtInvoiceConfigNeedPhoneNumber

	ffjtInvoiceConfigNeedEmail

	ffjtInvoiceConfigNeedShippingAddress

	ffjtInvoiceConfigSendPhoneNumberToProvider

	ffjtInvoiceConfigSendEmailToProvider

	ffjtInvoiceConfigIsFlexible

	ffjtInvoiceConfigChatID

	ffjtInvoiceConfigChannelUsername

	ffjtInvoiceConfigReplyToMessageID

	ffjtInvoiceConfigReplyMarkup

	ffjtInvoiceConfigDisableNotification

	ffjtInvoiceConfigProtectContent

	ffjtInvoiceConfigMessageThreadID

	ffjtInvoiceConfigMessageEffectID

	ffjtInvoiceConfigAllowPaidBroadcast

	ffjtInvoiceConfigReplyParameters
)

var ffjKeyInvoiceConfigTitle = []byte("title")

var ffjKeyInvoiceConfigDescription = []byte("description")

var ffjKeyInvoiceConfigPayload = []byte("payload")

var ffjKeyInvoiceConfigProviderToken = []byte("provider_token")

var ffjKeyInvoiceConfigCurrency = []byte("currency")

var ffjKeyInvoiceConfigPrices = []byte("prices")

var ffjKeyInvoiceConfigMaxTipAmount = []byte("max_tip_amount")

var ffjKeyInvoiceConfigSuggestedTipAmounts = []byte("suggested_tip_amounts")

var ffjKeyInvoiceConfigStartParameter = []byte("start_parameter")

var ffjKeyInvoiceConfigProviderData = []byte("provider_data")

var ffjKeyInvoiceConfigPhotoURL = []byte("photo_url")

var ffjKeyInvoiceConfigPhotoSize = []byte("photo_size")

var ffjKeyInvoiceConfigPhotoWidth = []byte("photo_width")

var ffjKeyInvoiceConfigPhotoHeight = []byte("photo_height")

var ffjKeyInvoiceConfigNeedName = []byte("need_name")

var ffjKeyInvoiceConfigNeedPhoneNumber = []byte("need_phone_number")

var ffjKeyInvoiceConfigNeedEmail = []byte("need_email")

var ffjKeyInvoiceConfigNeedShippingAddress = []byte("need_shipping_address")

var ffjKeyInvoiceConfigSendPhoneNumberToProvider = []byte("send_phone_number_to_provider")

var ffjKeyInvoiceConfigSendEmailToProvider = []byte("send_email_to_provider")

var ffjKeyInvoiceConfigIsFlexible = []byte("is_flexible")

var ffjKeyInvoiceConfigChatID = []byte("chat_id")

var ffjKeyInvoiceConfigChannelUsername = []byte("channel_username")

var ffjKeyInvoiceConfigReplyToMessageID = []byte("reply_to_message_id")

var ffjKeyInvoiceConfigReplyMarkup = []byte("reply_markup")

var ffjKeyInvoiceConfigDisableNotification = []byte("disable_notification")

var ffjKeyInvoiceConfigProtectContent = []byte("protect_content")

var ffjKeyInvoiceConfigMessageThreadID = []byte("message_thread_id")

var ffjKeyInvoiceConfigMessageEffectID = []byte("message_effect_id")

var ffjKeyInvoiceConfigAllowPaidBroadcast = []byte("allow_paid_broadcast")

var ffjKeyInvoiceConfigReplyParameters = []byte("reply_parameters")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InvoiceConfig) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InvoiceConfig) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInvoiceConfigbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInvoiceConfignosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyInvoiceConfigAllowPaidBroadcast, kn) {
						currentKey = ffjtInvoiceConfigAllowPaidBroadcast
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyInvoiceConfigCurrency, kn) {
						currentKey = ffjtInvoiceConfigCurrency
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInvoiceConfigChatID, kn) {
						currentKey = ffjtInvoiceConfigChatID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInvoiceConfigChannelUsername, kn) {
						currentKey = ffjtInvoiceConfigChannelUsername
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyInvoiceConfigDescription, kn) {
						currentKey = ffjtInvoiceConfigDescription
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInvoiceConfigDisableNotification, kn) {
						currentKey = ffjtInvoiceConfigDisableNotification
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyInvoiceConfigIsFlexible, kn) {
						currentKey = ffjtInvoiceConfigIsFlexible
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyInvoiceConfigMaxTipAmount, kn) {
						currentKey = ffjtInvoiceConfigMaxTipAmount
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInvoiceConfigMessageThreadID, kn) {
						currentKey = ffjtInvoiceConfigMessageThreadID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInvoiceConfigMessageEffectID, kn) {
						currentKey = ffjtInvoiceConfigMessageEffectID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyInvoiceConfigNeedName, kn) {
						currentKey = ffjtInvoiceConfigNeedName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInvoiceConfigNeedPhoneNumber, kn) {
						currentKey = ffjtInvoiceConfigNeedPhoneNumber
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInvoiceConfigNeedEmail, kn) {
						currentKey = ffjtInvoiceConfigNeedEmail
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInvoiceConfigNeedShippingAddress, kn) {
						currentKey = ffjtInvoiceConfigNeedShippingAddress
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyInvoiceConfigPayload, kn) {
						currentKey = ffjtInvoiceConfigPayload
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInvoiceConfigProviderToken, kn) {
						currentKey = ffjtInvoiceConfigProviderToken
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInvoiceConfigPrices, kn) {
						currentKey = ffjtInvoiceConfigPrices
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInvoiceConfigProviderData, kn) {
						currentKey = ffjtInvoiceConfigProviderData
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInvoiceConfigPhotoURL, kn) {
						currentKey = ffjtInvoiceConfigPhotoURL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInvoiceConfigPhotoSize, kn) {
						currentKey = ffjtInvoiceConfigPhotoSize
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInvoiceConfigPhotoWidth, kn) {
						currentKey = ffjtInvoiceConfigPhotoWidth
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInvoiceConfigPhotoHeight, kn) {
						currentKey = ffjtInvoiceConfigPhotoHeight
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInvoiceConfigProtectContent, kn) {
						currentKey = ffjtInvoiceConfigProtectContent
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyInvoiceConfigReplyToMessageID, kn) {
						currentKey = ffjtInvoiceConfigReplyToMessageID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInvoiceConfigReplyMarkup, kn) {
						currentKey = ffjtInvoiceConfigReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInvoiceConfigReplyParameters, kn) {
						currentKey = ffjtInvoiceConfigReplyParameters
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyInvoiceConfigSuggestedTipAmounts, kn) {
						currentKey = ffjtInvoiceConfigSuggestedTipAmounts
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInvoiceConfigStartParameter, kn) {
						currentKey = ffjtInvoiceConfigStartParameter
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInvoiceConfigSendPhoneNumberToProvider, kn) {
						currentKey = ffjtInvoiceConfigSendPhoneNumberToProvider
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInvoiceConfigSendEmailToProvider, kn) {
						currentKey = ffjtInvoiceConfigSendEmailToProvider
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyInvoiceConfigTitle, kn) {
						currentKey = ffjtInvoiceConfigTitle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyInvoiceConfigReplyParameters, kn) {
					currentKey = ffjtInvoiceConfigReplyParameters
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInvoiceConfigAllowPaidBroadcast, kn) {
					currentKey = ffjtInvoiceConfigAllowPaidBroadcast
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInvoiceConfigMessageEffectID, kn) {
					currentKey = ffjtInvoiceConfigMessageEffectID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInvoiceConfigMessageThreadID, kn) {
					currentKey = ffjtInvoiceConfigMessageThreadID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInvoiceConfigProtectContent, kn) {
					currentKey = ffjtInvoiceConfigProtectContent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInvoiceConfigDisableNotification, kn) {
					currentKey = ffjtInvoiceConfigDisableNotification
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInvoiceConfigReplyMarkup, kn) {
					currentKey = ffjtInvoiceConfigReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInvoiceConfigReplyToMessageID, kn) {
					currentKey = ffjtInvoiceConfigReplyToMessageID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInvoiceConfigChannelUsername, kn) {
					currentKey = ffjtInvoiceConfigChannelUsername
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInvoiceConfigChatID, kn) {
					currentKey = ffjtInvoiceConfigChatID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInvoiceConfigIsFlexible, kn) {
					currentKey = ffjtInvoiceConfigIsFlexible
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInvoiceConfigSendEmailToProvider, kn) {
					currentKey = ffjtInvoiceConfigSendEmailToProvider
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInvoiceConfigSendPhoneNumberToProvider, kn) {
					currentKey = ffjtInvoiceConfigSendPhoneNumberToProvider
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInvoiceConfigNeedShippingAddress, kn) {
					currentKey = ffjtInvoiceConfigNeedShippingAddress
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInvoiceConfigNeedEmail, kn) {
					currentKey = ffjtInvoiceConfigNeedEmail
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInvoiceConfigNeedPhoneNumber, kn) {
					currentKey = ffjtInvoiceConfigNeedPhoneNumber
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInvoiceConfigNeedName, kn) {
					currentKey = ffjtInvoiceConfigNeedName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInvoiceConfigPhotoHeight, kn) {
					currentKey = ffjtInvoiceConfigPhotoHeight
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInvoiceConfigPhotoWidth, kn) {
					currentKey = ffjtInvoiceConfigPhotoWidth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInvoiceConfigPhotoSize, kn) {
					currentKey = ffjtInvoiceConfigPhotoSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInvoiceConfigPhotoURL, kn) {
					currentKey = ffjtInvoiceConfigPhotoURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInvoiceConfigProviderData, kn) {
					currentKey = ffjtInvoiceConfigProviderData
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInvoiceConfigStartParameter, kn) {
					currentKey = ffjtInvoiceConfigStartParameter
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInvoiceConfigSuggestedTipAmounts, kn) {
					currentKey = ffjtInvoiceConfigSuggestedTipAmounts
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInvoiceConfigMaxTipAmount, kn) {
					currentKey = ffjtInvoiceConfigMaxTipAmount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInvoiceConfigPrices, kn) {
					currentKey = ffjtInvoiceConfigPrices
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInvoiceConfigCurrency, kn) {
					currentKey = ffjtInvoiceConfigCurrency
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInvoiceConfigProviderToken, kn) {
					currentKey = ffjtInvoiceConfigProviderToken
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInvoiceConfigPayload, kn) {
					currentKey = ffjtInvoiceConfigPayload
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInvoiceConfigDescription, kn) {
					currentKey = ffjtInvoiceConfigDescription
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInvoiceConfigTitle, kn) {
					currentKey = ffjtInvoiceConfigTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInvoiceConfignosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInvoiceConfigTitle:
					goto handle_Title

				case ffjtInvoiceConfigDescription:
					goto handle_Description

				case ffjtInvoiceConfigPayload:
					goto handle_Payload

				case ffjtInvoiceConfigProviderToken:
					goto handle_ProviderToken

				case ffjtInvoiceConfigCurrency:
					goto handle_Currency

				case ffjtInvoiceConfigPrices:
					goto handle_Prices

				case ffjtInvoiceConfigMaxTipAmount:
					goto handle_MaxTipAmount

				case ffjtInvoiceConfigSuggestedTipAmounts:
					goto handle_SuggestedTipAmounts

				case ffjtInvoiceConfigStartParameter:
					goto handle_StartParameter

				case ffjtInvoiceConfigProviderData:
					goto handle_ProviderData

				case ffjtInvoiceConfigPhotoURL:
					goto handle_PhotoURL

				case ffjtInvoiceConfigPhotoSize:
					goto handle_PhotoSize

				case ffjtInvoiceConfigPhotoWidth:
					goto handle_PhotoWidth

				case ffjtInvoiceConfigPhotoHeight:
					goto handle_PhotoHeight

				case ffjtInvoiceConfigNeedName:
					goto handle_NeedName

				case ffjtInvoiceConfigNeedPhoneNumber:
					goto handle_NeedPhoneNumber

				case ffjtInvoiceConfigNeedEmail:
					goto handle_NeedEmail

				case ffjtInvoiceConfigNeedShippingAddress:
					goto handle_NeedShippingAddress

				case ffjtInvoiceConfigSendPhoneNumberToProvider:
					goto handle_SendPhoneNumberToProvider

				case ffjtInvoiceConfigSendEmailToProvider:
					goto handle_SendEmailToProvider

				case ffjtInvoiceConfigIsFlexible:
					goto handle_IsFlexible

				case ffjtInvoiceConfigChatID:
					goto handle_ChatID

				case ffjtInvoiceConfigChannelUsername:
					goto handle_ChannelUsername

				case ffjtInvoiceConfigReplyToMessageID:
					goto handle_ReplyToMessageID

				case ffjtInvoiceConfigReplyMarkup:
					goto handle_ReplyMarkup

				case ffjtInvoiceConfigDisableNotification:
					goto handle_DisableNotification

				case ffjtInvoiceConfigProtectContent:
					goto handle_ProtectContent

				case ffjtInvoiceConfigMessageThreadID:
					goto handle_MessageThreadID

				case ffjtInvoiceConfigMessageEffectID:
					goto handle_MessageEffectID

				case ffjtInvoiceConfigAllowPaidBroadcast:
					goto handle_AllowPaidBroadcast

				case ffjtInvoiceConfigReplyParameters:
					goto handle_ReplyParameters

				case ffjtInvoiceConfignosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Description:

	/* handler: j.Description type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Description = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Payload:

	/* handler: j.Payload type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Payload = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ProviderToken:

	/* handler: j.ProviderToken type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ProviderToken = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Currency:

	/* handler: j.Currency type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Currency = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Prices:

	/* handler: j.Prices type=[]tgbotapi.LabeledPrice kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Prices = nil
		} else {

			j.Prices = []LabeledPrice{}

			wantVal := true

			for {

				var tmpJPrices LabeledPrice

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJPrices type=tgbotapi.LabeledPrice kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						err = tmpJPrices.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Prices = append(j.Prices, tmpJPrices)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MaxTipAmount:

	/* handler: j.MaxTipAmount type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.MaxTipAmount = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SuggestedTipAmounts:

	/* handler: j.SuggestedTipAmounts type=[]int64 kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.SuggestedTipAmounts = nil
		} else {

			j.SuggestedTipAmounts = []int64{}

			wantVal := true

			for {

				var tmpJSuggestedTipAmounts int64

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJSuggestedTipAmounts type=int64 kind=int64 quoted=false*/

				{
					if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
						return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
					}
				}

				{

					if tok == fflib.FFTok_null {

					} else {

						tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

						if err != nil {
							return fs.WrapErr(err)
						}

						tmpJSuggestedTipAmounts = int64(tval)

					}
				}

				j.SuggestedTipAmounts = append(j.SuggestedTipAmounts, tmpJSuggestedTipAmounts)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StartParameter:

	/* handler: j.StartParameter type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.StartParameter = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ProviderData:

	/* handler: j.ProviderData type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ProviderData = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PhotoURL:

	/* handler: j.PhotoURL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.PhotoURL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PhotoSize:

	/* handler: j.PhotoSize type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.PhotoSize = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PhotoWidth:

	/* handler: j.PhotoWidth type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.PhotoWidth = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PhotoHeight:

	/* handler: j.PhotoHeight type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.PhotoHeight = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NeedName:

	/* handler: j.NeedName type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.NeedName = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.NeedName = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NeedPhoneNumber:

	/* handler: j.NeedPhoneNumber type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.NeedPhoneNumber = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.NeedPhoneNumber = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NeedEmail:

	/* handler: j.NeedEmail type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.NeedEmail = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.NeedEmail = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NeedShippingAddress:

	/* handler: j.NeedShippingAddress type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.NeedShippingAddress = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.NeedShippingAddress = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SendPhoneNumberToProvider:

	/* handler: j.SendPhoneNumberToProvider type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.SendPhoneNumberToProvider = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.SendPhoneNumberToProvider = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SendEmailToProvider:

	/* handler: j.SendEmailToProvider type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.SendEmailToProvider = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.SendEmailToProvider = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IsFlexible:

	/* handler: j.IsFlexible type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.IsFlexible = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.IsFlexible = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChatID:

	/* handler: j.ChatID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ChatID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChannelUsername:

	/* handler: j.ChannelUsername type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ChannelUsername = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyToMessageID:

	/* handler: j.ReplyToMessageID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ReplyToMessageID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: j.ReplyMarkup type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.ReplyMarkup)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DisableNotification:

	/* handler: j.DisableNotification type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.DisableNotification = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.DisableNotification = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ProtectContent:

	/* handler: j.ProtectContent type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.ProtectContent = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.ProtectContent = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MessageThreadID:

	/* handler: j.MessageThreadID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.MessageThreadID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MessageEffectID:

	/* handler: j.MessageEffectID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.MessageEffectID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AllowPaidBroadcast:

	/* handler: j.AllowPaidBroadcast type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.AllowPaidBroadcast = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.AllowPaidBroadcast = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyParameters:

	/* handler: j.ReplyParameters type=tgbotapi.ReplyParameters kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			j.ReplyParameters = nil

		} else {

			if j.ReplyParameters == nil {
				j.ReplyParameters = new(ReplyParameters)
			}

			err = j.ReplyParameters.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
			if err != nil {
				return err
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *LabeledPrice) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *LabeledPrice) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"label":`)
	fflib.WriteJsonString(buf, string(j.Label))
	buf.WriteString(`,"amount":`)
	fflib.FormatBits2(buf, uint64(j.Amount), 10, j.Amount < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtLabeledPricebase = iota
	ffjtLabeledPricenosuchkey

	ffjtLabeledPriceLabel

	ffjtLabeledPriceAmount
)

var ffjKeyLabeledPriceLabel = []byte("label")

var ffjKeyLabeledPriceAmount = []byte("amount")

// UnmarshalJSON umarshall json - template of ffjson
func (j *LabeledPrice) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *LabeledPrice) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtLabeledPricebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtLabeledPricenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyLabeledPriceAmount, kn) {
						currentKey = ffjtLabeledPriceAmount
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyLabeledPriceLabel, kn) {
						currentKey = ffjtLabeledPriceLabel
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyLabeledPriceAmount, kn) {
					currentKey = ffjtLabeledPriceAmount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyLabeledPriceLabel, kn) {
					currentKey = ffjtLabeledPriceLabel
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtLabeledPricenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtLabeledPriceLabel:
					goto handle_Label

				case ffjtLabeledPriceAmount:
					goto handle_Amount

				case ffjtLabeledPricenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Label:

	/* handler: j.Label type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Label = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Amount:

	/* handler: j.Amount type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Amount = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}
