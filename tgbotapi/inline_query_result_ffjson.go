// Code generated by ffjson <https://github.com/pquerna/ffjson>. DO NOT EDIT.
// source: inline_query_result.go

package tgbotapi

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	fflib "github.com/pquerna/ffjson/fflib/v1"
)

// MarshalJSON marshal bytes to json - template
func (j *FoursquareFields) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *FoursquareFields) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(j.FoursquareID) != 0 {
		buf.WriteString(`"foursquare_id":`)
		fflib.WriteJsonString(buf, string(j.FoursquareID))
		buf.WriteByte(',')
	}
	if len(j.FoursquareType) != 0 {
		buf.WriteString(`"foursquare_type":`)
		fflib.WriteJsonString(buf, string(j.FoursquareType))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtFoursquareFieldsbase = iota
	ffjtFoursquareFieldsnosuchkey

	ffjtFoursquareFieldsFoursquareID

	ffjtFoursquareFieldsFoursquareType
)

var ffjKeyFoursquareFieldsFoursquareID = []byte("foursquare_id")

var ffjKeyFoursquareFieldsFoursquareType = []byte("foursquare_type")

// UnmarshalJSON umarshall json - template of ffjson
func (j *FoursquareFields) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *FoursquareFields) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtFoursquareFieldsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtFoursquareFieldsnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffjKeyFoursquareFieldsFoursquareID, kn) {
						currentKey = ffjtFoursquareFieldsFoursquareID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyFoursquareFieldsFoursquareType, kn) {
						currentKey = ffjtFoursquareFieldsFoursquareType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyFoursquareFieldsFoursquareType, kn) {
					currentKey = ffjtFoursquareFieldsFoursquareType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyFoursquareFieldsFoursquareID, kn) {
					currentKey = ffjtFoursquareFieldsFoursquareID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtFoursquareFieldsnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtFoursquareFieldsFoursquareID:
					goto handle_FoursquareID

				case ffjtFoursquareFieldsFoursquareType:
					goto handle_FoursquareType

				case ffjtFoursquareFieldsnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_FoursquareID:

	/* handler: j.FoursquareID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FoursquareID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FoursquareType:

	/* handler: j.FoursquareType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FoursquareType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *GooglePlaceFields) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *GooglePlaceFields) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ `)
	if len(j.GooglePlaceID) != 0 {
		buf.WriteString(`"google_place_id":`)
		fflib.WriteJsonString(buf, string(j.GooglePlaceID))
		buf.WriteByte(',')
	}
	if len(j.GooglePlaceType) != 0 {
		buf.WriteString(`"google_place_type":`)
		fflib.WriteJsonString(buf, string(j.GooglePlaceType))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtGooglePlaceFieldsbase = iota
	ffjtGooglePlaceFieldsnosuchkey

	ffjtGooglePlaceFieldsGooglePlaceID

	ffjtGooglePlaceFieldsGooglePlaceType
)

var ffjKeyGooglePlaceFieldsGooglePlaceID = []byte("google_place_id")

var ffjKeyGooglePlaceFieldsGooglePlaceType = []byte("google_place_type")

// UnmarshalJSON umarshall json - template of ffjson
func (j *GooglePlaceFields) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *GooglePlaceFields) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtGooglePlaceFieldsbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtGooglePlaceFieldsnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'g':

					if bytes.Equal(ffjKeyGooglePlaceFieldsGooglePlaceID, kn) {
						currentKey = ffjtGooglePlaceFieldsGooglePlaceID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyGooglePlaceFieldsGooglePlaceType, kn) {
						currentKey = ffjtGooglePlaceFieldsGooglePlaceType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyGooglePlaceFieldsGooglePlaceType, kn) {
					currentKey = ffjtGooglePlaceFieldsGooglePlaceType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyGooglePlaceFieldsGooglePlaceID, kn) {
					currentKey = ffjtGooglePlaceFieldsGooglePlaceID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtGooglePlaceFieldsnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtGooglePlaceFieldsGooglePlaceID:
					goto handle_GooglePlaceID

				case ffjtGooglePlaceFieldsGooglePlaceType:
					goto handle_GooglePlaceType

				case ffjtGooglePlaceFieldsnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_GooglePlaceID:

	/* handler: j.GooglePlaceID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.GooglePlaceID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GooglePlaceType:

	/* handler: j.GooglePlaceType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.GooglePlaceType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InlineQueryResultArticle) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InlineQueryResultArticle) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "input_message_content":`)
	/* Interface types must use runtime reflection. type=interface {} kind=interface */
	err = buf.Encode(j.InputMessageContent)
	if err != nil {
		return err
	}
	buf.WriteByte(',')
	if len(j.URL) != 0 {
		buf.WriteString(`"url":`)
		fflib.WriteJsonString(buf, string(j.URL))
		buf.WriteByte(',')
	}
	if j.HideURL != false {
		if j.HideURL {
			buf.WriteString(`"hide_url":true`)
		} else {
			buf.WriteString(`"hide_url":false`)
		}
		buf.WriteByte(',')
	}
	if len(j.Description) != 0 {
		buf.WriteString(`"description":`)
		fflib.WriteJsonString(buf, string(j.Description))
		buf.WriteByte(',')
	}
	if len(j.ThumbURL) != 0 {
		buf.WriteString(`"thumb_url":`)
		fflib.WriteJsonString(buf, string(j.ThumbURL))
		buf.WriteByte(',')
	}
	if j.ThumbWidth != 0 {
		buf.WriteString(`"thumb_width":`)
		fflib.FormatBits2(buf, uint64(j.ThumbWidth), 10, j.ThumbWidth < 0)
		buf.WriteByte(',')
	}
	if j.ThumbHeight != 0 {
		buf.WriteString(`"thumb_height":`)
		fflib.FormatBits2(buf, uint64(j.ThumbHeight), 10, j.ThumbHeight < 0)
		buf.WriteByte(',')
	}
	buf.WriteString(`"type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteByte(',')
	if len(j.Title) != 0 {
		buf.WriteString(`"title":`)
		fflib.WriteJsonString(buf, string(j.Title))
		buf.WriteByte(',')
	}
	if j.ReplyMarkup != nil {
		if true {
			/* Struct fall back. type=tgbotapi.InlineKeyboardMarkup kind=struct */
			buf.WriteString(`"reply_markup":`)
			err = buf.Encode(j.ReplyMarkup)
			if err != nil {
				return err
			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInlineQueryResultArticlebase = iota
	ffjtInlineQueryResultArticlenosuchkey

	ffjtInlineQueryResultArticleInputMessageContent

	ffjtInlineQueryResultArticleURL

	ffjtInlineQueryResultArticleHideURL

	ffjtInlineQueryResultArticleDescription

	ffjtInlineQueryResultArticleThumbURL

	ffjtInlineQueryResultArticleThumbWidth

	ffjtInlineQueryResultArticleThumbHeight

	ffjtInlineQueryResultArticleType

	ffjtInlineQueryResultArticleID

	ffjtInlineQueryResultArticleTitle

	ffjtInlineQueryResultArticleReplyMarkup
)

var ffjKeyInlineQueryResultArticleInputMessageContent = []byte("input_message_content")

var ffjKeyInlineQueryResultArticleURL = []byte("url")

var ffjKeyInlineQueryResultArticleHideURL = []byte("hide_url")

var ffjKeyInlineQueryResultArticleDescription = []byte("description")

var ffjKeyInlineQueryResultArticleThumbURL = []byte("thumb_url")

var ffjKeyInlineQueryResultArticleThumbWidth = []byte("thumb_width")

var ffjKeyInlineQueryResultArticleThumbHeight = []byte("thumb_height")

var ffjKeyInlineQueryResultArticleType = []byte("type")

var ffjKeyInlineQueryResultArticleID = []byte("id")

var ffjKeyInlineQueryResultArticleTitle = []byte("title")

var ffjKeyInlineQueryResultArticleReplyMarkup = []byte("reply_markup")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InlineQueryResultArticle) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InlineQueryResultArticle) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInlineQueryResultArticlebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInlineQueryResultArticlenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffjKeyInlineQueryResultArticleDescription, kn) {
						currentKey = ffjtInlineQueryResultArticleDescription
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffjKeyInlineQueryResultArticleHideURL, kn) {
						currentKey = ffjtInlineQueryResultArticleHideURL
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyInlineQueryResultArticleInputMessageContent, kn) {
						currentKey = ffjtInlineQueryResultArticleInputMessageContent
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultArticleID, kn) {
						currentKey = ffjtInlineQueryResultArticleID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyInlineQueryResultArticleReplyMarkup, kn) {
						currentKey = ffjtInlineQueryResultArticleReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyInlineQueryResultArticleThumbURL, kn) {
						currentKey = ffjtInlineQueryResultArticleThumbURL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultArticleThumbWidth, kn) {
						currentKey = ffjtInlineQueryResultArticleThumbWidth
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultArticleThumbHeight, kn) {
						currentKey = ffjtInlineQueryResultArticleThumbHeight
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultArticleType, kn) {
						currentKey = ffjtInlineQueryResultArticleType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultArticleTitle, kn) {
						currentKey = ffjtInlineQueryResultArticleTitle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyInlineQueryResultArticleURL, kn) {
						currentKey = ffjtInlineQueryResultArticleURL
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultArticleReplyMarkup, kn) {
					currentKey = ffjtInlineQueryResultArticleReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultArticleTitle, kn) {
					currentKey = ffjtInlineQueryResultArticleTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultArticleID, kn) {
					currentKey = ffjtInlineQueryResultArticleID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultArticleType, kn) {
					currentKey = ffjtInlineQueryResultArticleType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultArticleThumbHeight, kn) {
					currentKey = ffjtInlineQueryResultArticleThumbHeight
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultArticleThumbWidth, kn) {
					currentKey = ffjtInlineQueryResultArticleThumbWidth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultArticleThumbURL, kn) {
					currentKey = ffjtInlineQueryResultArticleThumbURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultArticleDescription, kn) {
					currentKey = ffjtInlineQueryResultArticleDescription
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultArticleHideURL, kn) {
					currentKey = ffjtInlineQueryResultArticleHideURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultArticleURL, kn) {
					currentKey = ffjtInlineQueryResultArticleURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultArticleInputMessageContent, kn) {
					currentKey = ffjtInlineQueryResultArticleInputMessageContent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInlineQueryResultArticlenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInlineQueryResultArticleInputMessageContent:
					goto handle_InputMessageContent

				case ffjtInlineQueryResultArticleURL:
					goto handle_URL

				case ffjtInlineQueryResultArticleHideURL:
					goto handle_HideURL

				case ffjtInlineQueryResultArticleDescription:
					goto handle_Description

				case ffjtInlineQueryResultArticleThumbURL:
					goto handle_ThumbURL

				case ffjtInlineQueryResultArticleThumbWidth:
					goto handle_ThumbWidth

				case ffjtInlineQueryResultArticleThumbHeight:
					goto handle_ThumbHeight

				case ffjtInlineQueryResultArticleType:
					goto handle_Type

				case ffjtInlineQueryResultArticleID:
					goto handle_ID

				case ffjtInlineQueryResultArticleTitle:
					goto handle_Title

				case ffjtInlineQueryResultArticleReplyMarkup:
					goto handle_ReplyMarkup

				case ffjtInlineQueryResultArticlenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_InputMessageContent:

	/* handler: j.InputMessageContent type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.InputMessageContent)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_URL:

	/* handler: j.URL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.URL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_HideURL:

	/* handler: j.HideURL type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.HideURL = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.HideURL = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Description:

	/* handler: j.Description type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Description = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ThumbURL:

	/* handler: j.ThumbURL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ThumbURL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ThumbWidth:

	/* handler: j.ThumbWidth type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ThumbWidth = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ThumbHeight:

	/* handler: j.ThumbHeight type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ThumbHeight = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: j.Type type=tgbotapi.InlineQueryResultType kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for InlineQueryResultType", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = InlineQueryResultType(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: j.ReplyMarkup type=tgbotapi.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		/* Falling back. type=tgbotapi.InlineKeyboardMarkup kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.ReplyMarkup)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InlineQueryResultAudio) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InlineQueryResultAudio) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "audio_url":`)
	fflib.WriteJsonString(buf, string(j.URL))
	buf.WriteString(`,"performer":`)
	fflib.WriteJsonString(buf, string(j.Performer))
	buf.WriteString(`,"audio_duration":`)
	fflib.FormatBits2(buf, uint64(j.Duration), 10, j.Duration < 0)
	buf.WriteByte(',')
	if j.InputMessageContent != nil {
		buf.WriteString(`"input_message_content":`)
		/* Interface types must use runtime reflection. type=interface {} kind=interface */
		err = buf.Encode(j.InputMessageContent)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	buf.WriteString(`"type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteByte(',')
	if len(j.Title) != 0 {
		buf.WriteString(`"title":`)
		fflib.WriteJsonString(buf, string(j.Title))
		buf.WriteByte(',')
	}
	if j.ReplyMarkup != nil {
		if true {
			/* Struct fall back. type=tgbotapi.InlineKeyboardMarkup kind=struct */
			buf.WriteString(`"reply_markup":`)
			err = buf.Encode(j.ReplyMarkup)
			if err != nil {
				return err
			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInlineQueryResultAudiobase = iota
	ffjtInlineQueryResultAudionosuchkey

	ffjtInlineQueryResultAudioURL

	ffjtInlineQueryResultAudioPerformer

	ffjtInlineQueryResultAudioDuration

	ffjtInlineQueryResultAudioInputMessageContent

	ffjtInlineQueryResultAudioType

	ffjtInlineQueryResultAudioID

	ffjtInlineQueryResultAudioTitle

	ffjtInlineQueryResultAudioReplyMarkup
)

var ffjKeyInlineQueryResultAudioURL = []byte("audio_url")

var ffjKeyInlineQueryResultAudioPerformer = []byte("performer")

var ffjKeyInlineQueryResultAudioDuration = []byte("audio_duration")

var ffjKeyInlineQueryResultAudioInputMessageContent = []byte("input_message_content")

var ffjKeyInlineQueryResultAudioType = []byte("type")

var ffjKeyInlineQueryResultAudioID = []byte("id")

var ffjKeyInlineQueryResultAudioTitle = []byte("title")

var ffjKeyInlineQueryResultAudioReplyMarkup = []byte("reply_markup")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InlineQueryResultAudio) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InlineQueryResultAudio) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInlineQueryResultAudiobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInlineQueryResultAudionosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyInlineQueryResultAudioURL, kn) {
						currentKey = ffjtInlineQueryResultAudioURL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultAudioDuration, kn) {
						currentKey = ffjtInlineQueryResultAudioDuration
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyInlineQueryResultAudioInputMessageContent, kn) {
						currentKey = ffjtInlineQueryResultAudioInputMessageContent
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultAudioID, kn) {
						currentKey = ffjtInlineQueryResultAudioID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyInlineQueryResultAudioPerformer, kn) {
						currentKey = ffjtInlineQueryResultAudioPerformer
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyInlineQueryResultAudioReplyMarkup, kn) {
						currentKey = ffjtInlineQueryResultAudioReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyInlineQueryResultAudioType, kn) {
						currentKey = ffjtInlineQueryResultAudioType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultAudioTitle, kn) {
						currentKey = ffjtInlineQueryResultAudioTitle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultAudioReplyMarkup, kn) {
					currentKey = ffjtInlineQueryResultAudioReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultAudioTitle, kn) {
					currentKey = ffjtInlineQueryResultAudioTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultAudioID, kn) {
					currentKey = ffjtInlineQueryResultAudioID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultAudioType, kn) {
					currentKey = ffjtInlineQueryResultAudioType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultAudioInputMessageContent, kn) {
					currentKey = ffjtInlineQueryResultAudioInputMessageContent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultAudioDuration, kn) {
					currentKey = ffjtInlineQueryResultAudioDuration
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultAudioPerformer, kn) {
					currentKey = ffjtInlineQueryResultAudioPerformer
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultAudioURL, kn) {
					currentKey = ffjtInlineQueryResultAudioURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInlineQueryResultAudionosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInlineQueryResultAudioURL:
					goto handle_URL

				case ffjtInlineQueryResultAudioPerformer:
					goto handle_Performer

				case ffjtInlineQueryResultAudioDuration:
					goto handle_Duration

				case ffjtInlineQueryResultAudioInputMessageContent:
					goto handle_InputMessageContent

				case ffjtInlineQueryResultAudioType:
					goto handle_Type

				case ffjtInlineQueryResultAudioID:
					goto handle_ID

				case ffjtInlineQueryResultAudioTitle:
					goto handle_Title

				case ffjtInlineQueryResultAudioReplyMarkup:
					goto handle_ReplyMarkup

				case ffjtInlineQueryResultAudionosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_URL:

	/* handler: j.URL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.URL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Performer:

	/* handler: j.Performer type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Performer = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Duration:

	/* handler: j.Duration type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Duration = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InputMessageContent:

	/* handler: j.InputMessageContent type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.InputMessageContent)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: j.Type type=tgbotapi.InlineQueryResultType kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for InlineQueryResultType", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = InlineQueryResultType(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: j.ReplyMarkup type=tgbotapi.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		/* Falling back. type=tgbotapi.InlineKeyboardMarkup kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.ReplyMarkup)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InlineQueryResultBase) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InlineQueryResultBase) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteByte(',')
	if len(j.Title) != 0 {
		buf.WriteString(`"title":`)
		fflib.WriteJsonString(buf, string(j.Title))
		buf.WriteByte(',')
	}
	if j.ReplyMarkup != nil {
		if true {
			/* Struct fall back. type=tgbotapi.InlineKeyboardMarkup kind=struct */
			buf.WriteString(`"reply_markup":`)
			err = buf.Encode(j.ReplyMarkup)
			if err != nil {
				return err
			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInlineQueryResultBasebase = iota
	ffjtInlineQueryResultBasenosuchkey

	ffjtInlineQueryResultBaseType

	ffjtInlineQueryResultBaseID

	ffjtInlineQueryResultBaseTitle

	ffjtInlineQueryResultBaseReplyMarkup
)

var ffjKeyInlineQueryResultBaseType = []byte("type")

var ffjKeyInlineQueryResultBaseID = []byte("id")

var ffjKeyInlineQueryResultBaseTitle = []byte("title")

var ffjKeyInlineQueryResultBaseReplyMarkup = []byte("reply_markup")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InlineQueryResultBase) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InlineQueryResultBase) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInlineQueryResultBasebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInlineQueryResultBasenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'i':

					if bytes.Equal(ffjKeyInlineQueryResultBaseID, kn) {
						currentKey = ffjtInlineQueryResultBaseID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyInlineQueryResultBaseReplyMarkup, kn) {
						currentKey = ffjtInlineQueryResultBaseReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyInlineQueryResultBaseType, kn) {
						currentKey = ffjtInlineQueryResultBaseType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultBaseTitle, kn) {
						currentKey = ffjtInlineQueryResultBaseTitle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultBaseReplyMarkup, kn) {
					currentKey = ffjtInlineQueryResultBaseReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultBaseTitle, kn) {
					currentKey = ffjtInlineQueryResultBaseTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultBaseID, kn) {
					currentKey = ffjtInlineQueryResultBaseID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultBaseType, kn) {
					currentKey = ffjtInlineQueryResultBaseType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInlineQueryResultBasenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInlineQueryResultBaseType:
					goto handle_Type

				case ffjtInlineQueryResultBaseID:
					goto handle_ID

				case ffjtInlineQueryResultBaseTitle:
					goto handle_Title

				case ffjtInlineQueryResultBaseReplyMarkup:
					goto handle_ReplyMarkup

				case ffjtInlineQueryResultBasenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: j.Type type=tgbotapi.InlineQueryResultType kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for InlineQueryResultType", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = InlineQueryResultType(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: j.ReplyMarkup type=tgbotapi.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		/* Falling back. type=tgbotapi.InlineKeyboardMarkup kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.ReplyMarkup)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InlineQueryResultCachedSticker) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InlineQueryResultCachedSticker) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "sticker_file_id":`)
	fflib.WriteJsonString(buf, string(j.StickerFileID))
	buf.WriteByte(',')
	if j.InputMessageContent != nil {
		buf.WriteString(`"input_message_content":`)
		/* Interface types must use runtime reflection. type=tgbotapi.InputMessageContent kind=interface */
		err = buf.Encode(j.InputMessageContent)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	buf.WriteString(`"type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteByte(',')
	if len(j.Title) != 0 {
		buf.WriteString(`"title":`)
		fflib.WriteJsonString(buf, string(j.Title))
		buf.WriteByte(',')
	}
	if j.ReplyMarkup != nil {
		if true {
			/* Struct fall back. type=tgbotapi.InlineKeyboardMarkup kind=struct */
			buf.WriteString(`"reply_markup":`)
			err = buf.Encode(j.ReplyMarkup)
			if err != nil {
				return err
			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInlineQueryResultCachedStickerbase = iota
	ffjtInlineQueryResultCachedStickernosuchkey

	ffjtInlineQueryResultCachedStickerStickerFileID

	ffjtInlineQueryResultCachedStickerInputMessageContent

	ffjtInlineQueryResultCachedStickerType

	ffjtInlineQueryResultCachedStickerID

	ffjtInlineQueryResultCachedStickerTitle

	ffjtInlineQueryResultCachedStickerReplyMarkup
)

var ffjKeyInlineQueryResultCachedStickerStickerFileID = []byte("sticker_file_id")

var ffjKeyInlineQueryResultCachedStickerInputMessageContent = []byte("input_message_content")

var ffjKeyInlineQueryResultCachedStickerType = []byte("type")

var ffjKeyInlineQueryResultCachedStickerID = []byte("id")

var ffjKeyInlineQueryResultCachedStickerTitle = []byte("title")

var ffjKeyInlineQueryResultCachedStickerReplyMarkup = []byte("reply_markup")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InlineQueryResultCachedSticker) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InlineQueryResultCachedSticker) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInlineQueryResultCachedStickerbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInlineQueryResultCachedStickernosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'i':

					if bytes.Equal(ffjKeyInlineQueryResultCachedStickerInputMessageContent, kn) {
						currentKey = ffjtInlineQueryResultCachedStickerInputMessageContent
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultCachedStickerID, kn) {
						currentKey = ffjtInlineQueryResultCachedStickerID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyInlineQueryResultCachedStickerReplyMarkup, kn) {
						currentKey = ffjtInlineQueryResultCachedStickerReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyInlineQueryResultCachedStickerStickerFileID, kn) {
						currentKey = ffjtInlineQueryResultCachedStickerStickerFileID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyInlineQueryResultCachedStickerType, kn) {
						currentKey = ffjtInlineQueryResultCachedStickerType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultCachedStickerTitle, kn) {
						currentKey = ffjtInlineQueryResultCachedStickerTitle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultCachedStickerReplyMarkup, kn) {
					currentKey = ffjtInlineQueryResultCachedStickerReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultCachedStickerTitle, kn) {
					currentKey = ffjtInlineQueryResultCachedStickerTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultCachedStickerID, kn) {
					currentKey = ffjtInlineQueryResultCachedStickerID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultCachedStickerType, kn) {
					currentKey = ffjtInlineQueryResultCachedStickerType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultCachedStickerInputMessageContent, kn) {
					currentKey = ffjtInlineQueryResultCachedStickerInputMessageContent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultCachedStickerStickerFileID, kn) {
					currentKey = ffjtInlineQueryResultCachedStickerStickerFileID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInlineQueryResultCachedStickernosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInlineQueryResultCachedStickerStickerFileID:
					goto handle_StickerFileID

				case ffjtInlineQueryResultCachedStickerInputMessageContent:
					goto handle_InputMessageContent

				case ffjtInlineQueryResultCachedStickerType:
					goto handle_Type

				case ffjtInlineQueryResultCachedStickerID:
					goto handle_ID

				case ffjtInlineQueryResultCachedStickerTitle:
					goto handle_Title

				case ffjtInlineQueryResultCachedStickerReplyMarkup:
					goto handle_ReplyMarkup

				case ffjtInlineQueryResultCachedStickernosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_StickerFileID:

	/* handler: j.StickerFileID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.StickerFileID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InputMessageContent:

	/* handler: j.InputMessageContent type=tgbotapi.InputMessageContent kind=interface quoted=false*/

	{
		/* Falling back. type=tgbotapi.InputMessageContent kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.InputMessageContent)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: j.Type type=tgbotapi.InlineQueryResultType kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for InlineQueryResultType", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = InlineQueryResultType(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: j.ReplyMarkup type=tgbotapi.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		/* Falling back. type=tgbotapi.InlineKeyboardMarkup kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.ReplyMarkup)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InlineQueryResultContact) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InlineQueryResultContact) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "phone_number":`)
	fflib.WriteJsonString(buf, string(j.PhoneNumber))
	buf.WriteString(`,"first_name":`)
	fflib.WriteJsonString(buf, string(j.FirstName))
	buf.WriteByte(',')
	if len(j.LastName) != 0 {
		buf.WriteString(`"last_name":`)
		fflib.WriteJsonString(buf, string(j.LastName))
		buf.WriteByte(',')
	}
	if len(j.Vcard) != 0 {
		buf.WriteString(`"vcard":`)
		fflib.WriteJsonString(buf, string(j.Vcard))
		buf.WriteByte(',')
	}
	if j.InputMessageContent != nil {
		buf.WriteString(`"input_message_content":`)
		/* Interface types must use runtime reflection. type=tgbotapi.InputMessageContent kind=interface */
		err = buf.Encode(j.InputMessageContent)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	buf.WriteString(`"type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteByte(',')
	if len(j.Title) != 0 {
		buf.WriteString(`"title":`)
		fflib.WriteJsonString(buf, string(j.Title))
		buf.WriteByte(',')
	}
	if j.ReplyMarkup != nil {
		if true {
			/* Struct fall back. type=tgbotapi.InlineKeyboardMarkup kind=struct */
			buf.WriteString(`"reply_markup":`)
			err = buf.Encode(j.ReplyMarkup)
			if err != nil {
				return err
			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInlineQueryResultContactbase = iota
	ffjtInlineQueryResultContactnosuchkey

	ffjtInlineQueryResultContactPhoneNumber

	ffjtInlineQueryResultContactFirstName

	ffjtInlineQueryResultContactLastName

	ffjtInlineQueryResultContactVcard

	ffjtInlineQueryResultContactInputMessageContent

	ffjtInlineQueryResultContactType

	ffjtInlineQueryResultContactID

	ffjtInlineQueryResultContactTitle

	ffjtInlineQueryResultContactReplyMarkup
)

var ffjKeyInlineQueryResultContactPhoneNumber = []byte("phone_number")

var ffjKeyInlineQueryResultContactFirstName = []byte("first_name")

var ffjKeyInlineQueryResultContactLastName = []byte("last_name")

var ffjKeyInlineQueryResultContactVcard = []byte("vcard")

var ffjKeyInlineQueryResultContactInputMessageContent = []byte("input_message_content")

var ffjKeyInlineQueryResultContactType = []byte("type")

var ffjKeyInlineQueryResultContactID = []byte("id")

var ffjKeyInlineQueryResultContactTitle = []byte("title")

var ffjKeyInlineQueryResultContactReplyMarkup = []byte("reply_markup")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InlineQueryResultContact) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InlineQueryResultContact) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInlineQueryResultContactbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInlineQueryResultContactnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffjKeyInlineQueryResultContactFirstName, kn) {
						currentKey = ffjtInlineQueryResultContactFirstName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyInlineQueryResultContactInputMessageContent, kn) {
						currentKey = ffjtInlineQueryResultContactInputMessageContent
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultContactID, kn) {
						currentKey = ffjtInlineQueryResultContactID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyInlineQueryResultContactLastName, kn) {
						currentKey = ffjtInlineQueryResultContactLastName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyInlineQueryResultContactPhoneNumber, kn) {
						currentKey = ffjtInlineQueryResultContactPhoneNumber
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyInlineQueryResultContactReplyMarkup, kn) {
						currentKey = ffjtInlineQueryResultContactReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyInlineQueryResultContactType, kn) {
						currentKey = ffjtInlineQueryResultContactType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultContactTitle, kn) {
						currentKey = ffjtInlineQueryResultContactTitle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffjKeyInlineQueryResultContactVcard, kn) {
						currentKey = ffjtInlineQueryResultContactVcard
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultContactReplyMarkup, kn) {
					currentKey = ffjtInlineQueryResultContactReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultContactTitle, kn) {
					currentKey = ffjtInlineQueryResultContactTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultContactID, kn) {
					currentKey = ffjtInlineQueryResultContactID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultContactType, kn) {
					currentKey = ffjtInlineQueryResultContactType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultContactInputMessageContent, kn) {
					currentKey = ffjtInlineQueryResultContactInputMessageContent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultContactVcard, kn) {
					currentKey = ffjtInlineQueryResultContactVcard
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultContactLastName, kn) {
					currentKey = ffjtInlineQueryResultContactLastName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultContactFirstName, kn) {
					currentKey = ffjtInlineQueryResultContactFirstName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultContactPhoneNumber, kn) {
					currentKey = ffjtInlineQueryResultContactPhoneNumber
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInlineQueryResultContactnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInlineQueryResultContactPhoneNumber:
					goto handle_PhoneNumber

				case ffjtInlineQueryResultContactFirstName:
					goto handle_FirstName

				case ffjtInlineQueryResultContactLastName:
					goto handle_LastName

				case ffjtInlineQueryResultContactVcard:
					goto handle_Vcard

				case ffjtInlineQueryResultContactInputMessageContent:
					goto handle_InputMessageContent

				case ffjtInlineQueryResultContactType:
					goto handle_Type

				case ffjtInlineQueryResultContactID:
					goto handle_ID

				case ffjtInlineQueryResultContactTitle:
					goto handle_Title

				case ffjtInlineQueryResultContactReplyMarkup:
					goto handle_ReplyMarkup

				case ffjtInlineQueryResultContactnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_PhoneNumber:

	/* handler: j.PhoneNumber type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.PhoneNumber = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FirstName:

	/* handler: j.FirstName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FirstName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LastName:

	/* handler: j.LastName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.LastName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Vcard:

	/* handler: j.Vcard type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Vcard = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InputMessageContent:

	/* handler: j.InputMessageContent type=tgbotapi.InputMessageContent kind=interface quoted=false*/

	{
		/* Falling back. type=tgbotapi.InputMessageContent kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.InputMessageContent)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: j.Type type=tgbotapi.InlineQueryResultType kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for InlineQueryResultType", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = InlineQueryResultType(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: j.ReplyMarkup type=tgbotapi.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		/* Falling back. type=tgbotapi.InlineKeyboardMarkup kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.ReplyMarkup)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InlineQueryResultDocument) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InlineQueryResultDocument) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "caption":`)
	fflib.WriteJsonString(buf, string(j.Caption))
	buf.WriteString(`,"document_url":`)
	fflib.WriteJsonString(buf, string(j.URL))
	buf.WriteString(`,"mime_type":`)
	fflib.WriteJsonString(buf, string(j.MimeType))
	buf.WriteString(`,"description":`)
	fflib.WriteJsonString(buf, string(j.Description))
	buf.WriteByte(',')
	if j.InputMessageContent != nil {
		buf.WriteString(`"input_message_content":`)
		/* Interface types must use runtime reflection. type=interface {} kind=interface */
		err = buf.Encode(j.InputMessageContent)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	buf.WriteString(`"thumb_url":`)
	fflib.WriteJsonString(buf, string(j.ThumbURL))
	buf.WriteString(`,"thumb_width":`)
	fflib.FormatBits2(buf, uint64(j.ThumbWidth), 10, j.ThumbWidth < 0)
	buf.WriteString(`,"thumb_height":`)
	fflib.FormatBits2(buf, uint64(j.ThumbHeight), 10, j.ThumbHeight < 0)
	buf.WriteString(`,"type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteByte(',')
	if len(j.Title) != 0 {
		buf.WriteString(`"title":`)
		fflib.WriteJsonString(buf, string(j.Title))
		buf.WriteByte(',')
	}
	if j.ReplyMarkup != nil {
		if true {
			/* Struct fall back. type=tgbotapi.InlineKeyboardMarkup kind=struct */
			buf.WriteString(`"reply_markup":`)
			err = buf.Encode(j.ReplyMarkup)
			if err != nil {
				return err
			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInlineQueryResultDocumentbase = iota
	ffjtInlineQueryResultDocumentnosuchkey

	ffjtInlineQueryResultDocumentCaption

	ffjtInlineQueryResultDocumentURL

	ffjtInlineQueryResultDocumentMimeType

	ffjtInlineQueryResultDocumentDescription

	ffjtInlineQueryResultDocumentInputMessageContent

	ffjtInlineQueryResultDocumentThumbURL

	ffjtInlineQueryResultDocumentThumbWidth

	ffjtInlineQueryResultDocumentThumbHeight

	ffjtInlineQueryResultDocumentType

	ffjtInlineQueryResultDocumentID

	ffjtInlineQueryResultDocumentTitle

	ffjtInlineQueryResultDocumentReplyMarkup
)

var ffjKeyInlineQueryResultDocumentCaption = []byte("caption")

var ffjKeyInlineQueryResultDocumentURL = []byte("document_url")

var ffjKeyInlineQueryResultDocumentMimeType = []byte("mime_type")

var ffjKeyInlineQueryResultDocumentDescription = []byte("description")

var ffjKeyInlineQueryResultDocumentInputMessageContent = []byte("input_message_content")

var ffjKeyInlineQueryResultDocumentThumbURL = []byte("thumb_url")

var ffjKeyInlineQueryResultDocumentThumbWidth = []byte("thumb_width")

var ffjKeyInlineQueryResultDocumentThumbHeight = []byte("thumb_height")

var ffjKeyInlineQueryResultDocumentType = []byte("type")

var ffjKeyInlineQueryResultDocumentID = []byte("id")

var ffjKeyInlineQueryResultDocumentTitle = []byte("title")

var ffjKeyInlineQueryResultDocumentReplyMarkup = []byte("reply_markup")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InlineQueryResultDocument) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InlineQueryResultDocument) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInlineQueryResultDocumentbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInlineQueryResultDocumentnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyInlineQueryResultDocumentCaption, kn) {
						currentKey = ffjtInlineQueryResultDocumentCaption
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyInlineQueryResultDocumentURL, kn) {
						currentKey = ffjtInlineQueryResultDocumentURL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultDocumentDescription, kn) {
						currentKey = ffjtInlineQueryResultDocumentDescription
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyInlineQueryResultDocumentInputMessageContent, kn) {
						currentKey = ffjtInlineQueryResultDocumentInputMessageContent
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultDocumentID, kn) {
						currentKey = ffjtInlineQueryResultDocumentID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyInlineQueryResultDocumentMimeType, kn) {
						currentKey = ffjtInlineQueryResultDocumentMimeType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyInlineQueryResultDocumentReplyMarkup, kn) {
						currentKey = ffjtInlineQueryResultDocumentReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyInlineQueryResultDocumentThumbURL, kn) {
						currentKey = ffjtInlineQueryResultDocumentThumbURL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultDocumentThumbWidth, kn) {
						currentKey = ffjtInlineQueryResultDocumentThumbWidth
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultDocumentThumbHeight, kn) {
						currentKey = ffjtInlineQueryResultDocumentThumbHeight
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultDocumentType, kn) {
						currentKey = ffjtInlineQueryResultDocumentType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultDocumentTitle, kn) {
						currentKey = ffjtInlineQueryResultDocumentTitle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultDocumentReplyMarkup, kn) {
					currentKey = ffjtInlineQueryResultDocumentReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultDocumentTitle, kn) {
					currentKey = ffjtInlineQueryResultDocumentTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultDocumentID, kn) {
					currentKey = ffjtInlineQueryResultDocumentID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultDocumentType, kn) {
					currentKey = ffjtInlineQueryResultDocumentType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultDocumentThumbHeight, kn) {
					currentKey = ffjtInlineQueryResultDocumentThumbHeight
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultDocumentThumbWidth, kn) {
					currentKey = ffjtInlineQueryResultDocumentThumbWidth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultDocumentThumbURL, kn) {
					currentKey = ffjtInlineQueryResultDocumentThumbURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultDocumentInputMessageContent, kn) {
					currentKey = ffjtInlineQueryResultDocumentInputMessageContent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultDocumentDescription, kn) {
					currentKey = ffjtInlineQueryResultDocumentDescription
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultDocumentMimeType, kn) {
					currentKey = ffjtInlineQueryResultDocumentMimeType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultDocumentURL, kn) {
					currentKey = ffjtInlineQueryResultDocumentURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultDocumentCaption, kn) {
					currentKey = ffjtInlineQueryResultDocumentCaption
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInlineQueryResultDocumentnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInlineQueryResultDocumentCaption:
					goto handle_Caption

				case ffjtInlineQueryResultDocumentURL:
					goto handle_URL

				case ffjtInlineQueryResultDocumentMimeType:
					goto handle_MimeType

				case ffjtInlineQueryResultDocumentDescription:
					goto handle_Description

				case ffjtInlineQueryResultDocumentInputMessageContent:
					goto handle_InputMessageContent

				case ffjtInlineQueryResultDocumentThumbURL:
					goto handle_ThumbURL

				case ffjtInlineQueryResultDocumentThumbWidth:
					goto handle_ThumbWidth

				case ffjtInlineQueryResultDocumentThumbHeight:
					goto handle_ThumbHeight

				case ffjtInlineQueryResultDocumentType:
					goto handle_Type

				case ffjtInlineQueryResultDocumentID:
					goto handle_ID

				case ffjtInlineQueryResultDocumentTitle:
					goto handle_Title

				case ffjtInlineQueryResultDocumentReplyMarkup:
					goto handle_ReplyMarkup

				case ffjtInlineQueryResultDocumentnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Caption:

	/* handler: j.Caption type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Caption = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_URL:

	/* handler: j.URL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.URL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MimeType:

	/* handler: j.MimeType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.MimeType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Description:

	/* handler: j.Description type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Description = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InputMessageContent:

	/* handler: j.InputMessageContent type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.InputMessageContent)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ThumbURL:

	/* handler: j.ThumbURL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ThumbURL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ThumbWidth:

	/* handler: j.ThumbWidth type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ThumbWidth = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ThumbHeight:

	/* handler: j.ThumbHeight type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ThumbHeight = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: j.Type type=tgbotapi.InlineQueryResultType kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for InlineQueryResultType", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = InlineQueryResultType(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: j.ReplyMarkup type=tgbotapi.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		/* Falling back. type=tgbotapi.InlineKeyboardMarkup kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.ReplyMarkup)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InlineQueryResultGIF) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InlineQueryResultGIF) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "gif_url":`)
	fflib.WriteJsonString(buf, string(j.URL))
	buf.WriteByte(',')
	if j.Width != 0 {
		buf.WriteString(`"gif_width":`)
		fflib.FormatBits2(buf, uint64(j.Width), 10, j.Width < 0)
		buf.WriteByte(',')
	}
	if j.Height != 0 {
		buf.WriteString(`"gif_height":`)
		fflib.FormatBits2(buf, uint64(j.Height), 10, j.Height < 0)
		buf.WriteByte(',')
	}
	if len(j.ThumbURL) != 0 {
		buf.WriteString(`"thumb_url":`)
		fflib.WriteJsonString(buf, string(j.ThumbURL))
		buf.WriteByte(',')
	}
	if len(j.Caption) != 0 {
		buf.WriteString(`"caption":`)
		fflib.WriteJsonString(buf, string(j.Caption))
		buf.WriteByte(',')
	}
	if j.InputMessageContent != nil {
		buf.WriteString(`"input_message_content":`)
		/* Interface types must use runtime reflection. type=interface {} kind=interface */
		err = buf.Encode(j.InputMessageContent)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	buf.WriteString(`"type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteByte(',')
	if len(j.Title) != 0 {
		buf.WriteString(`"title":`)
		fflib.WriteJsonString(buf, string(j.Title))
		buf.WriteByte(',')
	}
	if j.ReplyMarkup != nil {
		if true {
			/* Struct fall back. type=tgbotapi.InlineKeyboardMarkup kind=struct */
			buf.WriteString(`"reply_markup":`)
			err = buf.Encode(j.ReplyMarkup)
			if err != nil {
				return err
			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInlineQueryResultGIFbase = iota
	ffjtInlineQueryResultGIFnosuchkey

	ffjtInlineQueryResultGIFURL

	ffjtInlineQueryResultGIFWidth

	ffjtInlineQueryResultGIFHeight

	ffjtInlineQueryResultGIFThumbURL

	ffjtInlineQueryResultGIFCaption

	ffjtInlineQueryResultGIFInputMessageContent

	ffjtInlineQueryResultGIFType

	ffjtInlineQueryResultGIFID

	ffjtInlineQueryResultGIFTitle

	ffjtInlineQueryResultGIFReplyMarkup
)

var ffjKeyInlineQueryResultGIFURL = []byte("gif_url")

var ffjKeyInlineQueryResultGIFWidth = []byte("gif_width")

var ffjKeyInlineQueryResultGIFHeight = []byte("gif_height")

var ffjKeyInlineQueryResultGIFThumbURL = []byte("thumb_url")

var ffjKeyInlineQueryResultGIFCaption = []byte("caption")

var ffjKeyInlineQueryResultGIFInputMessageContent = []byte("input_message_content")

var ffjKeyInlineQueryResultGIFType = []byte("type")

var ffjKeyInlineQueryResultGIFID = []byte("id")

var ffjKeyInlineQueryResultGIFTitle = []byte("title")

var ffjKeyInlineQueryResultGIFReplyMarkup = []byte("reply_markup")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InlineQueryResultGIF) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InlineQueryResultGIF) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInlineQueryResultGIFbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInlineQueryResultGIFnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyInlineQueryResultGIFCaption, kn) {
						currentKey = ffjtInlineQueryResultGIFCaption
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffjKeyInlineQueryResultGIFURL, kn) {
						currentKey = ffjtInlineQueryResultGIFURL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultGIFWidth, kn) {
						currentKey = ffjtInlineQueryResultGIFWidth
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultGIFHeight, kn) {
						currentKey = ffjtInlineQueryResultGIFHeight
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyInlineQueryResultGIFInputMessageContent, kn) {
						currentKey = ffjtInlineQueryResultGIFInputMessageContent
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultGIFID, kn) {
						currentKey = ffjtInlineQueryResultGIFID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyInlineQueryResultGIFReplyMarkup, kn) {
						currentKey = ffjtInlineQueryResultGIFReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyInlineQueryResultGIFThumbURL, kn) {
						currentKey = ffjtInlineQueryResultGIFThumbURL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultGIFType, kn) {
						currentKey = ffjtInlineQueryResultGIFType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultGIFTitle, kn) {
						currentKey = ffjtInlineQueryResultGIFTitle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultGIFReplyMarkup, kn) {
					currentKey = ffjtInlineQueryResultGIFReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultGIFTitle, kn) {
					currentKey = ffjtInlineQueryResultGIFTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultGIFID, kn) {
					currentKey = ffjtInlineQueryResultGIFID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultGIFType, kn) {
					currentKey = ffjtInlineQueryResultGIFType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultGIFInputMessageContent, kn) {
					currentKey = ffjtInlineQueryResultGIFInputMessageContent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultGIFCaption, kn) {
					currentKey = ffjtInlineQueryResultGIFCaption
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultGIFThumbURL, kn) {
					currentKey = ffjtInlineQueryResultGIFThumbURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultGIFHeight, kn) {
					currentKey = ffjtInlineQueryResultGIFHeight
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultGIFWidth, kn) {
					currentKey = ffjtInlineQueryResultGIFWidth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultGIFURL, kn) {
					currentKey = ffjtInlineQueryResultGIFURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInlineQueryResultGIFnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInlineQueryResultGIFURL:
					goto handle_URL

				case ffjtInlineQueryResultGIFWidth:
					goto handle_Width

				case ffjtInlineQueryResultGIFHeight:
					goto handle_Height

				case ffjtInlineQueryResultGIFThumbURL:
					goto handle_ThumbURL

				case ffjtInlineQueryResultGIFCaption:
					goto handle_Caption

				case ffjtInlineQueryResultGIFInputMessageContent:
					goto handle_InputMessageContent

				case ffjtInlineQueryResultGIFType:
					goto handle_Type

				case ffjtInlineQueryResultGIFID:
					goto handle_ID

				case ffjtInlineQueryResultGIFTitle:
					goto handle_Title

				case ffjtInlineQueryResultGIFReplyMarkup:
					goto handle_ReplyMarkup

				case ffjtInlineQueryResultGIFnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_URL:

	/* handler: j.URL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.URL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Width:

	/* handler: j.Width type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Width = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Height:

	/* handler: j.Height type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Height = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ThumbURL:

	/* handler: j.ThumbURL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ThumbURL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Caption:

	/* handler: j.Caption type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Caption = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InputMessageContent:

	/* handler: j.InputMessageContent type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.InputMessageContent)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: j.Type type=tgbotapi.InlineQueryResultType kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for InlineQueryResultType", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = InlineQueryResultType(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: j.ReplyMarkup type=tgbotapi.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		/* Falling back. type=tgbotapi.InlineKeyboardMarkup kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.ReplyMarkup)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InlineQueryResultGame) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InlineQueryResultGame) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "game_short_name":`)
	fflib.WriteJsonString(buf, string(j.GameShortName))
	buf.WriteString(`,"type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteByte(',')
	if len(j.Title) != 0 {
		buf.WriteString(`"title":`)
		fflib.WriteJsonString(buf, string(j.Title))
		buf.WriteByte(',')
	}
	if j.ReplyMarkup != nil {
		if true {
			/* Struct fall back. type=tgbotapi.InlineKeyboardMarkup kind=struct */
			buf.WriteString(`"reply_markup":`)
			err = buf.Encode(j.ReplyMarkup)
			if err != nil {
				return err
			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInlineQueryResultGamebase = iota
	ffjtInlineQueryResultGamenosuchkey

	ffjtInlineQueryResultGameGameShortName

	ffjtInlineQueryResultGameType

	ffjtInlineQueryResultGameID

	ffjtInlineQueryResultGameTitle

	ffjtInlineQueryResultGameReplyMarkup
)

var ffjKeyInlineQueryResultGameGameShortName = []byte("game_short_name")

var ffjKeyInlineQueryResultGameType = []byte("type")

var ffjKeyInlineQueryResultGameID = []byte("id")

var ffjKeyInlineQueryResultGameTitle = []byte("title")

var ffjKeyInlineQueryResultGameReplyMarkup = []byte("reply_markup")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InlineQueryResultGame) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InlineQueryResultGame) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInlineQueryResultGamebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInlineQueryResultGamenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'g':

					if bytes.Equal(ffjKeyInlineQueryResultGameGameShortName, kn) {
						currentKey = ffjtInlineQueryResultGameGameShortName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyInlineQueryResultGameID, kn) {
						currentKey = ffjtInlineQueryResultGameID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyInlineQueryResultGameReplyMarkup, kn) {
						currentKey = ffjtInlineQueryResultGameReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyInlineQueryResultGameType, kn) {
						currentKey = ffjtInlineQueryResultGameType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultGameTitle, kn) {
						currentKey = ffjtInlineQueryResultGameTitle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultGameReplyMarkup, kn) {
					currentKey = ffjtInlineQueryResultGameReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultGameTitle, kn) {
					currentKey = ffjtInlineQueryResultGameTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultGameID, kn) {
					currentKey = ffjtInlineQueryResultGameID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultGameType, kn) {
					currentKey = ffjtInlineQueryResultGameType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultGameGameShortName, kn) {
					currentKey = ffjtInlineQueryResultGameGameShortName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInlineQueryResultGamenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInlineQueryResultGameGameShortName:
					goto handle_GameShortName

				case ffjtInlineQueryResultGameType:
					goto handle_Type

				case ffjtInlineQueryResultGameID:
					goto handle_ID

				case ffjtInlineQueryResultGameTitle:
					goto handle_Title

				case ffjtInlineQueryResultGameReplyMarkup:
					goto handle_ReplyMarkup

				case ffjtInlineQueryResultGamenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_GameShortName:

	/* handler: j.GameShortName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.GameShortName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: j.Type type=tgbotapi.InlineQueryResultType kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for InlineQueryResultType", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = InlineQueryResultType(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: j.ReplyMarkup type=tgbotapi.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		/* Falling back. type=tgbotapi.InlineKeyboardMarkup kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.ReplyMarkup)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InlineQueryResultLocation) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InlineQueryResultLocation) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "latitude":`)
	fflib.AppendFloat(buf, float64(j.Latitude), 'g', -1, 64)
	buf.WriteString(`,"longitude":`)
	fflib.AppendFloat(buf, float64(j.Longitude), 'g', -1, 64)
	buf.WriteByte(',')
	if j.InputMessageContent != nil {
		buf.WriteString(`"input_message_content":`)
		/* Interface types must use runtime reflection. type=interface {} kind=interface */
		err = buf.Encode(j.InputMessageContent)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	if len(j.ThumbURL) != 0 {
		buf.WriteString(`"thumb_url":`)
		fflib.WriteJsonString(buf, string(j.ThumbURL))
		buf.WriteByte(',')
	}
	if j.ThumbWidth != 0 {
		buf.WriteString(`"thumb_width":`)
		fflib.FormatBits2(buf, uint64(j.ThumbWidth), 10, j.ThumbWidth < 0)
		buf.WriteByte(',')
	}
	if j.ThumbHeight != 0 {
		buf.WriteString(`"thumb_height":`)
		fflib.FormatBits2(buf, uint64(j.ThumbHeight), 10, j.ThumbHeight < 0)
		buf.WriteByte(',')
	}
	buf.WriteString(`"type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteByte(',')
	if len(j.Title) != 0 {
		buf.WriteString(`"title":`)
		fflib.WriteJsonString(buf, string(j.Title))
		buf.WriteByte(',')
	}
	if j.ReplyMarkup != nil {
		if true {
			/* Struct fall back. type=tgbotapi.InlineKeyboardMarkup kind=struct */
			buf.WriteString(`"reply_markup":`)
			err = buf.Encode(j.ReplyMarkup)
			if err != nil {
				return err
			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInlineQueryResultLocationbase = iota
	ffjtInlineQueryResultLocationnosuchkey

	ffjtInlineQueryResultLocationLatitude

	ffjtInlineQueryResultLocationLongitude

	ffjtInlineQueryResultLocationInputMessageContent

	ffjtInlineQueryResultLocationThumbURL

	ffjtInlineQueryResultLocationThumbWidth

	ffjtInlineQueryResultLocationThumbHeight

	ffjtInlineQueryResultLocationType

	ffjtInlineQueryResultLocationID

	ffjtInlineQueryResultLocationTitle

	ffjtInlineQueryResultLocationReplyMarkup
)

var ffjKeyInlineQueryResultLocationLatitude = []byte("latitude")

var ffjKeyInlineQueryResultLocationLongitude = []byte("longitude")

var ffjKeyInlineQueryResultLocationInputMessageContent = []byte("input_message_content")

var ffjKeyInlineQueryResultLocationThumbURL = []byte("thumb_url")

var ffjKeyInlineQueryResultLocationThumbWidth = []byte("thumb_width")

var ffjKeyInlineQueryResultLocationThumbHeight = []byte("thumb_height")

var ffjKeyInlineQueryResultLocationType = []byte("type")

var ffjKeyInlineQueryResultLocationID = []byte("id")

var ffjKeyInlineQueryResultLocationTitle = []byte("title")

var ffjKeyInlineQueryResultLocationReplyMarkup = []byte("reply_markup")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InlineQueryResultLocation) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InlineQueryResultLocation) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInlineQueryResultLocationbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInlineQueryResultLocationnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'i':

					if bytes.Equal(ffjKeyInlineQueryResultLocationInputMessageContent, kn) {
						currentKey = ffjtInlineQueryResultLocationInputMessageContent
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultLocationID, kn) {
						currentKey = ffjtInlineQueryResultLocationID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyInlineQueryResultLocationLatitude, kn) {
						currentKey = ffjtInlineQueryResultLocationLatitude
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultLocationLongitude, kn) {
						currentKey = ffjtInlineQueryResultLocationLongitude
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyInlineQueryResultLocationReplyMarkup, kn) {
						currentKey = ffjtInlineQueryResultLocationReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyInlineQueryResultLocationThumbURL, kn) {
						currentKey = ffjtInlineQueryResultLocationThumbURL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultLocationThumbWidth, kn) {
						currentKey = ffjtInlineQueryResultLocationThumbWidth
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultLocationThumbHeight, kn) {
						currentKey = ffjtInlineQueryResultLocationThumbHeight
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultLocationType, kn) {
						currentKey = ffjtInlineQueryResultLocationType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultLocationTitle, kn) {
						currentKey = ffjtInlineQueryResultLocationTitle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultLocationReplyMarkup, kn) {
					currentKey = ffjtInlineQueryResultLocationReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultLocationTitle, kn) {
					currentKey = ffjtInlineQueryResultLocationTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultLocationID, kn) {
					currentKey = ffjtInlineQueryResultLocationID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultLocationType, kn) {
					currentKey = ffjtInlineQueryResultLocationType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultLocationThumbHeight, kn) {
					currentKey = ffjtInlineQueryResultLocationThumbHeight
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultLocationThumbWidth, kn) {
					currentKey = ffjtInlineQueryResultLocationThumbWidth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultLocationThumbURL, kn) {
					currentKey = ffjtInlineQueryResultLocationThumbURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultLocationInputMessageContent, kn) {
					currentKey = ffjtInlineQueryResultLocationInputMessageContent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultLocationLongitude, kn) {
					currentKey = ffjtInlineQueryResultLocationLongitude
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultLocationLatitude, kn) {
					currentKey = ffjtInlineQueryResultLocationLatitude
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInlineQueryResultLocationnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInlineQueryResultLocationLatitude:
					goto handle_Latitude

				case ffjtInlineQueryResultLocationLongitude:
					goto handle_Longitude

				case ffjtInlineQueryResultLocationInputMessageContent:
					goto handle_InputMessageContent

				case ffjtInlineQueryResultLocationThumbURL:
					goto handle_ThumbURL

				case ffjtInlineQueryResultLocationThumbWidth:
					goto handle_ThumbWidth

				case ffjtInlineQueryResultLocationThumbHeight:
					goto handle_ThumbHeight

				case ffjtInlineQueryResultLocationType:
					goto handle_Type

				case ffjtInlineQueryResultLocationID:
					goto handle_ID

				case ffjtInlineQueryResultLocationTitle:
					goto handle_Title

				case ffjtInlineQueryResultLocationReplyMarkup:
					goto handle_ReplyMarkup

				case ffjtInlineQueryResultLocationnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Latitude:

	/* handler: j.Latitude type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Latitude = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Longitude:

	/* handler: j.Longitude type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Longitude = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InputMessageContent:

	/* handler: j.InputMessageContent type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.InputMessageContent)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ThumbURL:

	/* handler: j.ThumbURL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ThumbURL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ThumbWidth:

	/* handler: j.ThumbWidth type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ThumbWidth = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ThumbHeight:

	/* handler: j.ThumbHeight type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ThumbHeight = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: j.Type type=tgbotapi.InlineQueryResultType kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for InlineQueryResultType", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = InlineQueryResultType(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: j.ReplyMarkup type=tgbotapi.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		/* Falling back. type=tgbotapi.InlineKeyboardMarkup kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.ReplyMarkup)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InlineQueryResultMPEG4GIF) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InlineQueryResultMPEG4GIF) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "mpeg4_url":`)
	fflib.WriteJsonString(buf, string(j.URL))
	buf.WriteString(`,"mpeg4_width":`)
	fflib.FormatBits2(buf, uint64(j.Width), 10, j.Width < 0)
	buf.WriteString(`,"mpeg4_height":`)
	fflib.FormatBits2(buf, uint64(j.Height), 10, j.Height < 0)
	buf.WriteString(`,"thumb_url":`)
	fflib.WriteJsonString(buf, string(j.ThumbURL))
	buf.WriteString(`,"caption":`)
	fflib.WriteJsonString(buf, string(j.Caption))
	buf.WriteByte(',')
	if j.InputMessageContent != nil {
		buf.WriteString(`"input_message_content":`)
		/* Interface types must use runtime reflection. type=interface {} kind=interface */
		err = buf.Encode(j.InputMessageContent)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	buf.WriteString(`"type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteByte(',')
	if len(j.Title) != 0 {
		buf.WriteString(`"title":`)
		fflib.WriteJsonString(buf, string(j.Title))
		buf.WriteByte(',')
	}
	if j.ReplyMarkup != nil {
		if true {
			/* Struct fall back. type=tgbotapi.InlineKeyboardMarkup kind=struct */
			buf.WriteString(`"reply_markup":`)
			err = buf.Encode(j.ReplyMarkup)
			if err != nil {
				return err
			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInlineQueryResultMPEG4GIFbase = iota
	ffjtInlineQueryResultMPEG4GIFnosuchkey

	ffjtInlineQueryResultMPEG4GIFURL

	ffjtInlineQueryResultMPEG4GIFWidth

	ffjtInlineQueryResultMPEG4GIFHeight

	ffjtInlineQueryResultMPEG4GIFThumbURL

	ffjtInlineQueryResultMPEG4GIFCaption

	ffjtInlineQueryResultMPEG4GIFInputMessageContent

	ffjtInlineQueryResultMPEG4GIFType

	ffjtInlineQueryResultMPEG4GIFID

	ffjtInlineQueryResultMPEG4GIFTitle

	ffjtInlineQueryResultMPEG4GIFReplyMarkup
)

var ffjKeyInlineQueryResultMPEG4GIFURL = []byte("mpeg4_url")

var ffjKeyInlineQueryResultMPEG4GIFWidth = []byte("mpeg4_width")

var ffjKeyInlineQueryResultMPEG4GIFHeight = []byte("mpeg4_height")

var ffjKeyInlineQueryResultMPEG4GIFThumbURL = []byte("thumb_url")

var ffjKeyInlineQueryResultMPEG4GIFCaption = []byte("caption")

var ffjKeyInlineQueryResultMPEG4GIFInputMessageContent = []byte("input_message_content")

var ffjKeyInlineQueryResultMPEG4GIFType = []byte("type")

var ffjKeyInlineQueryResultMPEG4GIFID = []byte("id")

var ffjKeyInlineQueryResultMPEG4GIFTitle = []byte("title")

var ffjKeyInlineQueryResultMPEG4GIFReplyMarkup = []byte("reply_markup")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InlineQueryResultMPEG4GIF) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InlineQueryResultMPEG4GIF) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInlineQueryResultMPEG4GIFbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInlineQueryResultMPEG4GIFnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyInlineQueryResultMPEG4GIFCaption, kn) {
						currentKey = ffjtInlineQueryResultMPEG4GIFCaption
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyInlineQueryResultMPEG4GIFInputMessageContent, kn) {
						currentKey = ffjtInlineQueryResultMPEG4GIFInputMessageContent
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultMPEG4GIFID, kn) {
						currentKey = ffjtInlineQueryResultMPEG4GIFID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyInlineQueryResultMPEG4GIFURL, kn) {
						currentKey = ffjtInlineQueryResultMPEG4GIFURL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultMPEG4GIFWidth, kn) {
						currentKey = ffjtInlineQueryResultMPEG4GIFWidth
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultMPEG4GIFHeight, kn) {
						currentKey = ffjtInlineQueryResultMPEG4GIFHeight
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyInlineQueryResultMPEG4GIFReplyMarkup, kn) {
						currentKey = ffjtInlineQueryResultMPEG4GIFReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyInlineQueryResultMPEG4GIFThumbURL, kn) {
						currentKey = ffjtInlineQueryResultMPEG4GIFThumbURL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultMPEG4GIFType, kn) {
						currentKey = ffjtInlineQueryResultMPEG4GIFType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultMPEG4GIFTitle, kn) {
						currentKey = ffjtInlineQueryResultMPEG4GIFTitle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultMPEG4GIFReplyMarkup, kn) {
					currentKey = ffjtInlineQueryResultMPEG4GIFReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultMPEG4GIFTitle, kn) {
					currentKey = ffjtInlineQueryResultMPEG4GIFTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultMPEG4GIFID, kn) {
					currentKey = ffjtInlineQueryResultMPEG4GIFID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultMPEG4GIFType, kn) {
					currentKey = ffjtInlineQueryResultMPEG4GIFType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultMPEG4GIFInputMessageContent, kn) {
					currentKey = ffjtInlineQueryResultMPEG4GIFInputMessageContent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultMPEG4GIFCaption, kn) {
					currentKey = ffjtInlineQueryResultMPEG4GIFCaption
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultMPEG4GIFThumbURL, kn) {
					currentKey = ffjtInlineQueryResultMPEG4GIFThumbURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultMPEG4GIFHeight, kn) {
					currentKey = ffjtInlineQueryResultMPEG4GIFHeight
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultMPEG4GIFWidth, kn) {
					currentKey = ffjtInlineQueryResultMPEG4GIFWidth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultMPEG4GIFURL, kn) {
					currentKey = ffjtInlineQueryResultMPEG4GIFURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInlineQueryResultMPEG4GIFnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInlineQueryResultMPEG4GIFURL:
					goto handle_URL

				case ffjtInlineQueryResultMPEG4GIFWidth:
					goto handle_Width

				case ffjtInlineQueryResultMPEG4GIFHeight:
					goto handle_Height

				case ffjtInlineQueryResultMPEG4GIFThumbURL:
					goto handle_ThumbURL

				case ffjtInlineQueryResultMPEG4GIFCaption:
					goto handle_Caption

				case ffjtInlineQueryResultMPEG4GIFInputMessageContent:
					goto handle_InputMessageContent

				case ffjtInlineQueryResultMPEG4GIFType:
					goto handle_Type

				case ffjtInlineQueryResultMPEG4GIFID:
					goto handle_ID

				case ffjtInlineQueryResultMPEG4GIFTitle:
					goto handle_Title

				case ffjtInlineQueryResultMPEG4GIFReplyMarkup:
					goto handle_ReplyMarkup

				case ffjtInlineQueryResultMPEG4GIFnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_URL:

	/* handler: j.URL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.URL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Width:

	/* handler: j.Width type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Width = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Height:

	/* handler: j.Height type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Height = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ThumbURL:

	/* handler: j.ThumbURL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ThumbURL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Caption:

	/* handler: j.Caption type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Caption = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InputMessageContent:

	/* handler: j.InputMessageContent type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.InputMessageContent)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: j.Type type=tgbotapi.InlineQueryResultType kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for InlineQueryResultType", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = InlineQueryResultType(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: j.ReplyMarkup type=tgbotapi.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		/* Falling back. type=tgbotapi.InlineKeyboardMarkup kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.ReplyMarkup)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InlineQueryResultPhoto) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InlineQueryResultPhoto) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "photo_url":`)
	fflib.WriteJsonString(buf, string(j.URL))
	buf.WriteByte(',')
	if len(j.MimeType) != 0 {
		buf.WriteString(`"mime_type":`)
		fflib.WriteJsonString(buf, string(j.MimeType))
		buf.WriteByte(',')
	}
	if j.Width != 0 {
		buf.WriteString(`"photo_width":`)
		fflib.FormatBits2(buf, uint64(j.Width), 10, j.Width < 0)
		buf.WriteByte(',')
	}
	if j.Height != 0 {
		buf.WriteString(`"photo_height":`)
		fflib.FormatBits2(buf, uint64(j.Height), 10, j.Height < 0)
		buf.WriteByte(',')
	}
	if len(j.ThumbURL) != 0 {
		buf.WriteString(`"thumb_url":`)
		fflib.WriteJsonString(buf, string(j.ThumbURL))
		buf.WriteByte(',')
	}
	if len(j.Description) != 0 {
		buf.WriteString(`"description":`)
		fflib.WriteJsonString(buf, string(j.Description))
		buf.WriteByte(',')
	}
	if len(j.Caption) != 0 {
		buf.WriteString(`"caption":`)
		fflib.WriteJsonString(buf, string(j.Caption))
		buf.WriteByte(',')
	}
	if j.InputMessageContent != nil {
		buf.WriteString(`"input_message_content":`)
		/* Interface types must use runtime reflection. type=interface {} kind=interface */
		err = buf.Encode(j.InputMessageContent)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	buf.WriteString(`"type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteByte(',')
	if len(j.Title) != 0 {
		buf.WriteString(`"title":`)
		fflib.WriteJsonString(buf, string(j.Title))
		buf.WriteByte(',')
	}
	if j.ReplyMarkup != nil {
		if true {
			/* Struct fall back. type=tgbotapi.InlineKeyboardMarkup kind=struct */
			buf.WriteString(`"reply_markup":`)
			err = buf.Encode(j.ReplyMarkup)
			if err != nil {
				return err
			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInlineQueryResultPhotobase = iota
	ffjtInlineQueryResultPhotonosuchkey

	ffjtInlineQueryResultPhotoURL

	ffjtInlineQueryResultPhotoMimeType

	ffjtInlineQueryResultPhotoWidth

	ffjtInlineQueryResultPhotoHeight

	ffjtInlineQueryResultPhotoThumbURL

	ffjtInlineQueryResultPhotoDescription

	ffjtInlineQueryResultPhotoCaption

	ffjtInlineQueryResultPhotoInputMessageContent

	ffjtInlineQueryResultPhotoType

	ffjtInlineQueryResultPhotoID

	ffjtInlineQueryResultPhotoTitle

	ffjtInlineQueryResultPhotoReplyMarkup
)

var ffjKeyInlineQueryResultPhotoURL = []byte("photo_url")

var ffjKeyInlineQueryResultPhotoMimeType = []byte("mime_type")

var ffjKeyInlineQueryResultPhotoWidth = []byte("photo_width")

var ffjKeyInlineQueryResultPhotoHeight = []byte("photo_height")

var ffjKeyInlineQueryResultPhotoThumbURL = []byte("thumb_url")

var ffjKeyInlineQueryResultPhotoDescription = []byte("description")

var ffjKeyInlineQueryResultPhotoCaption = []byte("caption")

var ffjKeyInlineQueryResultPhotoInputMessageContent = []byte("input_message_content")

var ffjKeyInlineQueryResultPhotoType = []byte("type")

var ffjKeyInlineQueryResultPhotoID = []byte("id")

var ffjKeyInlineQueryResultPhotoTitle = []byte("title")

var ffjKeyInlineQueryResultPhotoReplyMarkup = []byte("reply_markup")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InlineQueryResultPhoto) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InlineQueryResultPhoto) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInlineQueryResultPhotobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInlineQueryResultPhotonosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyInlineQueryResultPhotoCaption, kn) {
						currentKey = ffjtInlineQueryResultPhotoCaption
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyInlineQueryResultPhotoDescription, kn) {
						currentKey = ffjtInlineQueryResultPhotoDescription
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyInlineQueryResultPhotoInputMessageContent, kn) {
						currentKey = ffjtInlineQueryResultPhotoInputMessageContent
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultPhotoID, kn) {
						currentKey = ffjtInlineQueryResultPhotoID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyInlineQueryResultPhotoMimeType, kn) {
						currentKey = ffjtInlineQueryResultPhotoMimeType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyInlineQueryResultPhotoURL, kn) {
						currentKey = ffjtInlineQueryResultPhotoURL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultPhotoWidth, kn) {
						currentKey = ffjtInlineQueryResultPhotoWidth
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultPhotoHeight, kn) {
						currentKey = ffjtInlineQueryResultPhotoHeight
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyInlineQueryResultPhotoReplyMarkup, kn) {
						currentKey = ffjtInlineQueryResultPhotoReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyInlineQueryResultPhotoThumbURL, kn) {
						currentKey = ffjtInlineQueryResultPhotoThumbURL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultPhotoType, kn) {
						currentKey = ffjtInlineQueryResultPhotoType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultPhotoTitle, kn) {
						currentKey = ffjtInlineQueryResultPhotoTitle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultPhotoReplyMarkup, kn) {
					currentKey = ffjtInlineQueryResultPhotoReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultPhotoTitle, kn) {
					currentKey = ffjtInlineQueryResultPhotoTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultPhotoID, kn) {
					currentKey = ffjtInlineQueryResultPhotoID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultPhotoType, kn) {
					currentKey = ffjtInlineQueryResultPhotoType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultPhotoInputMessageContent, kn) {
					currentKey = ffjtInlineQueryResultPhotoInputMessageContent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultPhotoCaption, kn) {
					currentKey = ffjtInlineQueryResultPhotoCaption
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultPhotoDescription, kn) {
					currentKey = ffjtInlineQueryResultPhotoDescription
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultPhotoThumbURL, kn) {
					currentKey = ffjtInlineQueryResultPhotoThumbURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultPhotoHeight, kn) {
					currentKey = ffjtInlineQueryResultPhotoHeight
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultPhotoWidth, kn) {
					currentKey = ffjtInlineQueryResultPhotoWidth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultPhotoMimeType, kn) {
					currentKey = ffjtInlineQueryResultPhotoMimeType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultPhotoURL, kn) {
					currentKey = ffjtInlineQueryResultPhotoURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInlineQueryResultPhotonosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInlineQueryResultPhotoURL:
					goto handle_URL

				case ffjtInlineQueryResultPhotoMimeType:
					goto handle_MimeType

				case ffjtInlineQueryResultPhotoWidth:
					goto handle_Width

				case ffjtInlineQueryResultPhotoHeight:
					goto handle_Height

				case ffjtInlineQueryResultPhotoThumbURL:
					goto handle_ThumbURL

				case ffjtInlineQueryResultPhotoDescription:
					goto handle_Description

				case ffjtInlineQueryResultPhotoCaption:
					goto handle_Caption

				case ffjtInlineQueryResultPhotoInputMessageContent:
					goto handle_InputMessageContent

				case ffjtInlineQueryResultPhotoType:
					goto handle_Type

				case ffjtInlineQueryResultPhotoID:
					goto handle_ID

				case ffjtInlineQueryResultPhotoTitle:
					goto handle_Title

				case ffjtInlineQueryResultPhotoReplyMarkup:
					goto handle_ReplyMarkup

				case ffjtInlineQueryResultPhotonosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_URL:

	/* handler: j.URL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.URL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MimeType:

	/* handler: j.MimeType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.MimeType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Width:

	/* handler: j.Width type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Width = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Height:

	/* handler: j.Height type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Height = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ThumbURL:

	/* handler: j.ThumbURL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ThumbURL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Description:

	/* handler: j.Description type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Description = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Caption:

	/* handler: j.Caption type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Caption = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InputMessageContent:

	/* handler: j.InputMessageContent type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.InputMessageContent)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: j.Type type=tgbotapi.InlineQueryResultType kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for InlineQueryResultType", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = InlineQueryResultType(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: j.ReplyMarkup type=tgbotapi.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		/* Falling back. type=tgbotapi.InlineKeyboardMarkup kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.ReplyMarkup)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InlineQueryResultVenue) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InlineQueryResultVenue) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "latitude":`)
	fflib.AppendFloat(buf, float64(j.Latitude), 'g', -1, 64)
	buf.WriteString(`,"longitude":`)
	fflib.AppendFloat(buf, float64(j.Longitude), 'g', -1, 64)
	buf.WriteString(`,"address":`)
	fflib.WriteJsonString(buf, string(j.Address))
	buf.WriteByte(',')
	if j.InputMessageContent != nil {
		buf.WriteString(`"input_message_content":`)
		/* Interface types must use runtime reflection. type=interface {} kind=interface */
		err = buf.Encode(j.InputMessageContent)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	if len(j.ThumbURL) != 0 {
		buf.WriteString(`"thumb_url":`)
		fflib.WriteJsonString(buf, string(j.ThumbURL))
		buf.WriteByte(',')
	}
	if j.ThumbWidth != 0 {
		buf.WriteString(`"thumb_width":`)
		fflib.FormatBits2(buf, uint64(j.ThumbWidth), 10, j.ThumbWidth < 0)
		buf.WriteByte(',')
	}
	if j.ThumbHeight != 0 {
		buf.WriteString(`"thumb_height":`)
		fflib.FormatBits2(buf, uint64(j.ThumbHeight), 10, j.ThumbHeight < 0)
		buf.WriteByte(',')
	}
	buf.WriteString(`"type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteByte(',')
	if len(j.Title) != 0 {
		buf.WriteString(`"title":`)
		fflib.WriteJsonString(buf, string(j.Title))
		buf.WriteByte(',')
	}
	if j.ReplyMarkup != nil {
		if true {
			/* Struct fall back. type=tgbotapi.InlineKeyboardMarkup kind=struct */
			buf.WriteString(`"reply_markup":`)
			err = buf.Encode(j.ReplyMarkup)
			if err != nil {
				return err
			}
			buf.WriteByte(',')
		}
	}
	if len(j.FoursquareID) != 0 {
		buf.WriteString(`"foursquare_id":`)
		fflib.WriteJsonString(buf, string(j.FoursquareID))
		buf.WriteByte(',')
	}
	if len(j.FoursquareType) != 0 {
		buf.WriteString(`"foursquare_type":`)
		fflib.WriteJsonString(buf, string(j.FoursquareType))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInlineQueryResultVenuebase = iota
	ffjtInlineQueryResultVenuenosuchkey

	ffjtInlineQueryResultVenueLatitude

	ffjtInlineQueryResultVenueLongitude

	ffjtInlineQueryResultVenueAddress

	ffjtInlineQueryResultVenueInputMessageContent

	ffjtInlineQueryResultVenueThumbURL

	ffjtInlineQueryResultVenueThumbWidth

	ffjtInlineQueryResultVenueThumbHeight

	ffjtInlineQueryResultVenueType

	ffjtInlineQueryResultVenueID

	ffjtInlineQueryResultVenueTitle

	ffjtInlineQueryResultVenueReplyMarkup

	ffjtInlineQueryResultVenueFoursquareID

	ffjtInlineQueryResultVenueFoursquareType
)

var ffjKeyInlineQueryResultVenueLatitude = []byte("latitude")

var ffjKeyInlineQueryResultVenueLongitude = []byte("longitude")

var ffjKeyInlineQueryResultVenueAddress = []byte("address")

var ffjKeyInlineQueryResultVenueInputMessageContent = []byte("input_message_content")

var ffjKeyInlineQueryResultVenueThumbURL = []byte("thumb_url")

var ffjKeyInlineQueryResultVenueThumbWidth = []byte("thumb_width")

var ffjKeyInlineQueryResultVenueThumbHeight = []byte("thumb_height")

var ffjKeyInlineQueryResultVenueType = []byte("type")

var ffjKeyInlineQueryResultVenueID = []byte("id")

var ffjKeyInlineQueryResultVenueTitle = []byte("title")

var ffjKeyInlineQueryResultVenueReplyMarkup = []byte("reply_markup")

var ffjKeyInlineQueryResultVenueFoursquareID = []byte("foursquare_id")

var ffjKeyInlineQueryResultVenueFoursquareType = []byte("foursquare_type")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InlineQueryResultVenue) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InlineQueryResultVenue) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInlineQueryResultVenuebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInlineQueryResultVenuenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffjKeyInlineQueryResultVenueAddress, kn) {
						currentKey = ffjtInlineQueryResultVenueAddress
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyInlineQueryResultVenueFoursquareID, kn) {
						currentKey = ffjtInlineQueryResultVenueFoursquareID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultVenueFoursquareType, kn) {
						currentKey = ffjtInlineQueryResultVenueFoursquareType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyInlineQueryResultVenueInputMessageContent, kn) {
						currentKey = ffjtInlineQueryResultVenueInputMessageContent
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultVenueID, kn) {
						currentKey = ffjtInlineQueryResultVenueID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyInlineQueryResultVenueLatitude, kn) {
						currentKey = ffjtInlineQueryResultVenueLatitude
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultVenueLongitude, kn) {
						currentKey = ffjtInlineQueryResultVenueLongitude
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyInlineQueryResultVenueReplyMarkup, kn) {
						currentKey = ffjtInlineQueryResultVenueReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyInlineQueryResultVenueThumbURL, kn) {
						currentKey = ffjtInlineQueryResultVenueThumbURL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultVenueThumbWidth, kn) {
						currentKey = ffjtInlineQueryResultVenueThumbWidth
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultVenueThumbHeight, kn) {
						currentKey = ffjtInlineQueryResultVenueThumbHeight
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultVenueType, kn) {
						currentKey = ffjtInlineQueryResultVenueType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultVenueTitle, kn) {
						currentKey = ffjtInlineQueryResultVenueTitle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultVenueFoursquareType, kn) {
					currentKey = ffjtInlineQueryResultVenueFoursquareType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultVenueFoursquareID, kn) {
					currentKey = ffjtInlineQueryResultVenueFoursquareID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultVenueReplyMarkup, kn) {
					currentKey = ffjtInlineQueryResultVenueReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultVenueTitle, kn) {
					currentKey = ffjtInlineQueryResultVenueTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultVenueID, kn) {
					currentKey = ffjtInlineQueryResultVenueID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultVenueType, kn) {
					currentKey = ffjtInlineQueryResultVenueType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultVenueThumbHeight, kn) {
					currentKey = ffjtInlineQueryResultVenueThumbHeight
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultVenueThumbWidth, kn) {
					currentKey = ffjtInlineQueryResultVenueThumbWidth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultVenueThumbURL, kn) {
					currentKey = ffjtInlineQueryResultVenueThumbURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultVenueInputMessageContent, kn) {
					currentKey = ffjtInlineQueryResultVenueInputMessageContent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultVenueAddress, kn) {
					currentKey = ffjtInlineQueryResultVenueAddress
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultVenueLongitude, kn) {
					currentKey = ffjtInlineQueryResultVenueLongitude
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultVenueLatitude, kn) {
					currentKey = ffjtInlineQueryResultVenueLatitude
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInlineQueryResultVenuenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInlineQueryResultVenueLatitude:
					goto handle_Latitude

				case ffjtInlineQueryResultVenueLongitude:
					goto handle_Longitude

				case ffjtInlineQueryResultVenueAddress:
					goto handle_Address

				case ffjtInlineQueryResultVenueInputMessageContent:
					goto handle_InputMessageContent

				case ffjtInlineQueryResultVenueThumbURL:
					goto handle_ThumbURL

				case ffjtInlineQueryResultVenueThumbWidth:
					goto handle_ThumbWidth

				case ffjtInlineQueryResultVenueThumbHeight:
					goto handle_ThumbHeight

				case ffjtInlineQueryResultVenueType:
					goto handle_Type

				case ffjtInlineQueryResultVenueID:
					goto handle_ID

				case ffjtInlineQueryResultVenueTitle:
					goto handle_Title

				case ffjtInlineQueryResultVenueReplyMarkup:
					goto handle_ReplyMarkup

				case ffjtInlineQueryResultVenueFoursquareID:
					goto handle_FoursquareID

				case ffjtInlineQueryResultVenueFoursquareType:
					goto handle_FoursquareType

				case ffjtInlineQueryResultVenuenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Latitude:

	/* handler: j.Latitude type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Latitude = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Longitude:

	/* handler: j.Longitude type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Longitude = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Address:

	/* handler: j.Address type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Address = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InputMessageContent:

	/* handler: j.InputMessageContent type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.InputMessageContent)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ThumbURL:

	/* handler: j.ThumbURL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ThumbURL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ThumbWidth:

	/* handler: j.ThumbWidth type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ThumbWidth = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ThumbHeight:

	/* handler: j.ThumbHeight type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ThumbHeight = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: j.Type type=tgbotapi.InlineQueryResultType kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for InlineQueryResultType", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = InlineQueryResultType(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: j.ReplyMarkup type=tgbotapi.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		/* Falling back. type=tgbotapi.InlineKeyboardMarkup kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.ReplyMarkup)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FoursquareID:

	/* handler: j.FoursquareID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FoursquareID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FoursquareType:

	/* handler: j.FoursquareType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.FoursquareType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InlineQueryResultVideo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InlineQueryResultVideo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "video_url":`)
	fflib.WriteJsonString(buf, string(j.URL))
	buf.WriteString(`,"mime_type":`)
	fflib.WriteJsonString(buf, string(j.MimeType))
	buf.WriteString(`,"thumb_url":`)
	fflib.WriteJsonString(buf, string(j.ThumbURL))
	buf.WriteString(`,"caption":`)
	fflib.WriteJsonString(buf, string(j.Caption))
	buf.WriteString(`,"video_width":`)
	fflib.FormatBits2(buf, uint64(j.Width), 10, j.Width < 0)
	buf.WriteString(`,"video_height":`)
	fflib.FormatBits2(buf, uint64(j.Height), 10, j.Height < 0)
	buf.WriteString(`,"video_duration":`)
	fflib.FormatBits2(buf, uint64(j.Duration), 10, j.Duration < 0)
	buf.WriteString(`,"description":`)
	fflib.WriteJsonString(buf, string(j.Description))
	buf.WriteByte(',')
	if j.InputMessageContent != nil {
		buf.WriteString(`"input_message_content":`)
		/* Interface types must use runtime reflection. type=interface {} kind=interface */
		err = buf.Encode(j.InputMessageContent)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	buf.WriteString(`"type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteByte(',')
	if len(j.Title) != 0 {
		buf.WriteString(`"title":`)
		fflib.WriteJsonString(buf, string(j.Title))
		buf.WriteByte(',')
	}
	if j.ReplyMarkup != nil {
		if true {
			/* Struct fall back. type=tgbotapi.InlineKeyboardMarkup kind=struct */
			buf.WriteString(`"reply_markup":`)
			err = buf.Encode(j.ReplyMarkup)
			if err != nil {
				return err
			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInlineQueryResultVideobase = iota
	ffjtInlineQueryResultVideonosuchkey

	ffjtInlineQueryResultVideoURL

	ffjtInlineQueryResultVideoMimeType

	ffjtInlineQueryResultVideoThumbURL

	ffjtInlineQueryResultVideoCaption

	ffjtInlineQueryResultVideoWidth

	ffjtInlineQueryResultVideoHeight

	ffjtInlineQueryResultVideoDuration

	ffjtInlineQueryResultVideoDescription

	ffjtInlineQueryResultVideoInputMessageContent

	ffjtInlineQueryResultVideoType

	ffjtInlineQueryResultVideoID

	ffjtInlineQueryResultVideoTitle

	ffjtInlineQueryResultVideoReplyMarkup
)

var ffjKeyInlineQueryResultVideoURL = []byte("video_url")

var ffjKeyInlineQueryResultVideoMimeType = []byte("mime_type")

var ffjKeyInlineQueryResultVideoThumbURL = []byte("thumb_url")

var ffjKeyInlineQueryResultVideoCaption = []byte("caption")

var ffjKeyInlineQueryResultVideoWidth = []byte("video_width")

var ffjKeyInlineQueryResultVideoHeight = []byte("video_height")

var ffjKeyInlineQueryResultVideoDuration = []byte("video_duration")

var ffjKeyInlineQueryResultVideoDescription = []byte("description")

var ffjKeyInlineQueryResultVideoInputMessageContent = []byte("input_message_content")

var ffjKeyInlineQueryResultVideoType = []byte("type")

var ffjKeyInlineQueryResultVideoID = []byte("id")

var ffjKeyInlineQueryResultVideoTitle = []byte("title")

var ffjKeyInlineQueryResultVideoReplyMarkup = []byte("reply_markup")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InlineQueryResultVideo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InlineQueryResultVideo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInlineQueryResultVideobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInlineQueryResultVideonosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyInlineQueryResultVideoCaption, kn) {
						currentKey = ffjtInlineQueryResultVideoCaption
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyInlineQueryResultVideoDescription, kn) {
						currentKey = ffjtInlineQueryResultVideoDescription
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyInlineQueryResultVideoInputMessageContent, kn) {
						currentKey = ffjtInlineQueryResultVideoInputMessageContent
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultVideoID, kn) {
						currentKey = ffjtInlineQueryResultVideoID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyInlineQueryResultVideoMimeType, kn) {
						currentKey = ffjtInlineQueryResultVideoMimeType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyInlineQueryResultVideoReplyMarkup, kn) {
						currentKey = ffjtInlineQueryResultVideoReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyInlineQueryResultVideoThumbURL, kn) {
						currentKey = ffjtInlineQueryResultVideoThumbURL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultVideoType, kn) {
						currentKey = ffjtInlineQueryResultVideoType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultVideoTitle, kn) {
						currentKey = ffjtInlineQueryResultVideoTitle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffjKeyInlineQueryResultVideoURL, kn) {
						currentKey = ffjtInlineQueryResultVideoURL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultVideoWidth, kn) {
						currentKey = ffjtInlineQueryResultVideoWidth
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultVideoHeight, kn) {
						currentKey = ffjtInlineQueryResultVideoHeight
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultVideoDuration, kn) {
						currentKey = ffjtInlineQueryResultVideoDuration
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultVideoReplyMarkup, kn) {
					currentKey = ffjtInlineQueryResultVideoReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultVideoTitle, kn) {
					currentKey = ffjtInlineQueryResultVideoTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultVideoID, kn) {
					currentKey = ffjtInlineQueryResultVideoID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultVideoType, kn) {
					currentKey = ffjtInlineQueryResultVideoType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultVideoInputMessageContent, kn) {
					currentKey = ffjtInlineQueryResultVideoInputMessageContent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultVideoDescription, kn) {
					currentKey = ffjtInlineQueryResultVideoDescription
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultVideoDuration, kn) {
					currentKey = ffjtInlineQueryResultVideoDuration
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultVideoHeight, kn) {
					currentKey = ffjtInlineQueryResultVideoHeight
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultVideoWidth, kn) {
					currentKey = ffjtInlineQueryResultVideoWidth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultVideoCaption, kn) {
					currentKey = ffjtInlineQueryResultVideoCaption
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultVideoThumbURL, kn) {
					currentKey = ffjtInlineQueryResultVideoThumbURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultVideoMimeType, kn) {
					currentKey = ffjtInlineQueryResultVideoMimeType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultVideoURL, kn) {
					currentKey = ffjtInlineQueryResultVideoURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInlineQueryResultVideonosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInlineQueryResultVideoURL:
					goto handle_URL

				case ffjtInlineQueryResultVideoMimeType:
					goto handle_MimeType

				case ffjtInlineQueryResultVideoThumbURL:
					goto handle_ThumbURL

				case ffjtInlineQueryResultVideoCaption:
					goto handle_Caption

				case ffjtInlineQueryResultVideoWidth:
					goto handle_Width

				case ffjtInlineQueryResultVideoHeight:
					goto handle_Height

				case ffjtInlineQueryResultVideoDuration:
					goto handle_Duration

				case ffjtInlineQueryResultVideoDescription:
					goto handle_Description

				case ffjtInlineQueryResultVideoInputMessageContent:
					goto handle_InputMessageContent

				case ffjtInlineQueryResultVideoType:
					goto handle_Type

				case ffjtInlineQueryResultVideoID:
					goto handle_ID

				case ffjtInlineQueryResultVideoTitle:
					goto handle_Title

				case ffjtInlineQueryResultVideoReplyMarkup:
					goto handle_ReplyMarkup

				case ffjtInlineQueryResultVideonosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_URL:

	/* handler: j.URL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.URL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MimeType:

	/* handler: j.MimeType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.MimeType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ThumbURL:

	/* handler: j.ThumbURL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ThumbURL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Caption:

	/* handler: j.Caption type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Caption = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Width:

	/* handler: j.Width type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Width = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Height:

	/* handler: j.Height type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Height = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Duration:

	/* handler: j.Duration type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Duration = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Description:

	/* handler: j.Description type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Description = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InputMessageContent:

	/* handler: j.InputMessageContent type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.InputMessageContent)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: j.Type type=tgbotapi.InlineQueryResultType kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for InlineQueryResultType", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = InlineQueryResultType(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: j.ReplyMarkup type=tgbotapi.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		/* Falling back. type=tgbotapi.InlineKeyboardMarkup kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.ReplyMarkup)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *InlineQueryResultVoice) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *InlineQueryResultVoice) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "voice_url":`)
	fflib.WriteJsonString(buf, string(j.URL))
	buf.WriteString(`,"voice_duration":`)
	fflib.FormatBits2(buf, uint64(j.Duration), 10, j.Duration < 0)
	buf.WriteByte(',')
	if j.InputMessageContent != nil {
		buf.WriteString(`"input_message_content":`)
		/* Interface types must use runtime reflection. type=interface {} kind=interface */
		err = buf.Encode(j.InputMessageContent)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	buf.WriteString(`"type":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteByte(',')
	if len(j.Title) != 0 {
		buf.WriteString(`"title":`)
		fflib.WriteJsonString(buf, string(j.Title))
		buf.WriteByte(',')
	}
	if j.ReplyMarkup != nil {
		if true {
			/* Struct fall back. type=tgbotapi.InlineKeyboardMarkup kind=struct */
			buf.WriteString(`"reply_markup":`)
			err = buf.Encode(j.ReplyMarkup)
			if err != nil {
				return err
			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtInlineQueryResultVoicebase = iota
	ffjtInlineQueryResultVoicenosuchkey

	ffjtInlineQueryResultVoiceURL

	ffjtInlineQueryResultVoiceDuration

	ffjtInlineQueryResultVoiceInputMessageContent

	ffjtInlineQueryResultVoiceType

	ffjtInlineQueryResultVoiceID

	ffjtInlineQueryResultVoiceTitle

	ffjtInlineQueryResultVoiceReplyMarkup
)

var ffjKeyInlineQueryResultVoiceURL = []byte("voice_url")

var ffjKeyInlineQueryResultVoiceDuration = []byte("voice_duration")

var ffjKeyInlineQueryResultVoiceInputMessageContent = []byte("input_message_content")

var ffjKeyInlineQueryResultVoiceType = []byte("type")

var ffjKeyInlineQueryResultVoiceID = []byte("id")

var ffjKeyInlineQueryResultVoiceTitle = []byte("title")

var ffjKeyInlineQueryResultVoiceReplyMarkup = []byte("reply_markup")

// UnmarshalJSON umarshall json - template of ffjson
func (j *InlineQueryResultVoice) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *InlineQueryResultVoice) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtInlineQueryResultVoicebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtInlineQueryResultVoicenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'i':

					if bytes.Equal(ffjKeyInlineQueryResultVoiceInputMessageContent, kn) {
						currentKey = ffjtInlineQueryResultVoiceInputMessageContent
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultVoiceID, kn) {
						currentKey = ffjtInlineQueryResultVoiceID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyInlineQueryResultVoiceReplyMarkup, kn) {
						currentKey = ffjtInlineQueryResultVoiceReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyInlineQueryResultVoiceType, kn) {
						currentKey = ffjtInlineQueryResultVoiceType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultVoiceTitle, kn) {
						currentKey = ffjtInlineQueryResultVoiceTitle
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffjKeyInlineQueryResultVoiceURL, kn) {
						currentKey = ffjtInlineQueryResultVoiceURL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyInlineQueryResultVoiceDuration, kn) {
						currentKey = ffjtInlineQueryResultVoiceDuration
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultVoiceReplyMarkup, kn) {
					currentKey = ffjtInlineQueryResultVoiceReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultVoiceTitle, kn) {
					currentKey = ffjtInlineQueryResultVoiceTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultVoiceID, kn) {
					currentKey = ffjtInlineQueryResultVoiceID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyInlineQueryResultVoiceType, kn) {
					currentKey = ffjtInlineQueryResultVoiceType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyInlineQueryResultVoiceInputMessageContent, kn) {
					currentKey = ffjtInlineQueryResultVoiceInputMessageContent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultVoiceDuration, kn) {
					currentKey = ffjtInlineQueryResultVoiceDuration
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyInlineQueryResultVoiceURL, kn) {
					currentKey = ffjtInlineQueryResultVoiceURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtInlineQueryResultVoicenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtInlineQueryResultVoiceURL:
					goto handle_URL

				case ffjtInlineQueryResultVoiceDuration:
					goto handle_Duration

				case ffjtInlineQueryResultVoiceInputMessageContent:
					goto handle_InputMessageContent

				case ffjtInlineQueryResultVoiceType:
					goto handle_Type

				case ffjtInlineQueryResultVoiceID:
					goto handle_ID

				case ffjtInlineQueryResultVoiceTitle:
					goto handle_Title

				case ffjtInlineQueryResultVoiceReplyMarkup:
					goto handle_ReplyMarkup

				case ffjtInlineQueryResultVoicenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_URL:

	/* handler: j.URL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.URL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Duration:

	/* handler: j.Duration type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Duration = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InputMessageContent:

	/* handler: j.InputMessageContent type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.InputMessageContent)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: j.Type type=tgbotapi.InlineQueryResultType kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for InlineQueryResultType", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = InlineQueryResultType(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: j.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: j.ReplyMarkup type=tgbotapi.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		/* Falling back. type=tgbotapi.InlineKeyboardMarkup kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.ReplyMarkup)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}
