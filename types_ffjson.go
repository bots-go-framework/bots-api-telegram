// DO NOT EDIT!
// Code generated by ffjson <https://github.com/pquerna/ffjson>
// source: types.go
// DO NOT EDIT!

package tgbotapi

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	fflib "github.com/pquerna/ffjson/fflib/v1"
)

func (mj *APIResponse) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *APIResponse) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if mj.Ok {
		buf.WriteString(`{"ok":true`)
	} else {
		buf.WriteString(`{"ok":false`)
	}
	buf.WriteString(`,"result":`)

	{

		obj, err = mj.Result.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"error_code":`)
	fflib.FormatBits2(buf, uint64(mj.ErrorCode), 10, mj.ErrorCode < 0)
	buf.WriteString(`,"description":`)
	fflib.WriteJsonString(buf, string(mj.Description))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_APIResponsebase = iota
	ffj_t_APIResponseno_such_key

	ffj_t_APIResponse_Ok

	ffj_t_APIResponse_Result

	ffj_t_APIResponse_ErrorCode

	ffj_t_APIResponse_Description
)

var ffj_key_APIResponse_Ok = []byte("ok")

var ffj_key_APIResponse_Result = []byte("result")

var ffj_key_APIResponse_ErrorCode = []byte("error_code")

var ffj_key_APIResponse_Description = []byte("description")

func (uj *APIResponse) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *APIResponse) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_APIResponsebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_APIResponseno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffj_key_APIResponse_Description, kn) {
						currentKey = ffj_t_APIResponse_Description
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffj_key_APIResponse_ErrorCode, kn) {
						currentKey = ffj_t_APIResponse_ErrorCode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffj_key_APIResponse_Ok, kn) {
						currentKey = ffj_t_APIResponse_Ok
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_APIResponse_Result, kn) {
						currentKey = ffj_t_APIResponse_Result
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_APIResponse_Description, kn) {
					currentKey = ffj_t_APIResponse_Description
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_APIResponse_ErrorCode, kn) {
					currentKey = ffj_t_APIResponse_ErrorCode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_APIResponse_Result, kn) {
					currentKey = ffj_t_APIResponse_Result
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_APIResponse_Ok, kn) {
					currentKey = ffj_t_APIResponse_Ok
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_APIResponseno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_APIResponse_Ok:
					goto handle_Ok

				case ffj_t_APIResponse_Result:
					goto handle_Result

				case ffj_t_APIResponse_ErrorCode:
					goto handle_ErrorCode

				case ffj_t_APIResponse_Description:
					goto handle_Description

				case ffj_t_APIResponseno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Ok:

	/* handler: uj.Ok type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.Ok = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.Ok = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Result:

	/* handler: uj.Result type=json.RawMessage kind=slice quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = uj.Result.UnmarshalJSON(tbuf)
		if err != nil {
			return fs.WrapErr(err)
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ErrorCode:

	/* handler: uj.ErrorCode type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.ErrorCode = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Description:

	/* handler: uj.Description type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Description = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Audio) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Audio) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"file_id":`)
	fflib.WriteJsonString(buf, string(mj.FileID))
	buf.WriteString(`,"duration":`)
	fflib.FormatBits2(buf, uint64(mj.Duration), 10, mj.Duration < 0)
	buf.WriteString(`,"performer":`)
	fflib.WriteJsonString(buf, string(mj.Performer))
	buf.WriteString(`,"title":`)
	fflib.WriteJsonString(buf, string(mj.Title))
	buf.WriteString(`,"mime_type":`)
	fflib.WriteJsonString(buf, string(mj.MimeType))
	buf.WriteString(`,"file_size":`)
	fflib.FormatBits2(buf, uint64(mj.FileSize), 10, mj.FileSize < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Audiobase = iota
	ffj_t_Audiono_such_key

	ffj_t_Audio_FileID

	ffj_t_Audio_Duration

	ffj_t_Audio_Performer

	ffj_t_Audio_Title

	ffj_t_Audio_MimeType

	ffj_t_Audio_FileSize
)

var ffj_key_Audio_FileID = []byte("file_id")

var ffj_key_Audio_Duration = []byte("duration")

var ffj_key_Audio_Performer = []byte("performer")

var ffj_key_Audio_Title = []byte("title")

var ffj_key_Audio_MimeType = []byte("mime_type")

var ffj_key_Audio_FileSize = []byte("file_size")

func (uj *Audio) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Audio) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Audiobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Audiono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffj_key_Audio_Duration, kn) {
						currentKey = ffj_t_Audio_Duration
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffj_key_Audio_FileID, kn) {
						currentKey = ffj_t_Audio_FileID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Audio_FileSize, kn) {
						currentKey = ffj_t_Audio_FileSize
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_Audio_MimeType, kn) {
						currentKey = ffj_t_Audio_MimeType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_Audio_Performer, kn) {
						currentKey = ffj_t_Audio_Performer
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_Audio_Title, kn) {
						currentKey = ffj_t_Audio_Title
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Audio_FileSize, kn) {
					currentKey = ffj_t_Audio_FileSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Audio_MimeType, kn) {
					currentKey = ffj_t_Audio_MimeType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Audio_Title, kn) {
					currentKey = ffj_t_Audio_Title
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Audio_Performer, kn) {
					currentKey = ffj_t_Audio_Performer
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Audio_Duration, kn) {
					currentKey = ffj_t_Audio_Duration
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Audio_FileID, kn) {
					currentKey = ffj_t_Audio_FileID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Audiono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Audio_FileID:
					goto handle_FileID

				case ffj_t_Audio_Duration:
					goto handle_Duration

				case ffj_t_Audio_Performer:
					goto handle_Performer

				case ffj_t_Audio_Title:
					goto handle_Title

				case ffj_t_Audio_MimeType:
					goto handle_MimeType

				case ffj_t_Audio_FileSize:
					goto handle_FileSize

				case ffj_t_Audiono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_FileID:

	/* handler: uj.FileID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.FileID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Duration:

	/* handler: uj.Duration type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Duration = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Performer:

	/* handler: uj.Performer type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Performer = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: uj.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MimeType:

	/* handler: uj.MimeType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.MimeType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileSize:

	/* handler: uj.FileSize type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.FileSize = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *CallbackQuery) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *CallbackQuery) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "id":`)
	fflib.WriteJsonString(buf, string(mj.ID))
	if mj.From != nil {
		buf.WriteString(`,"from":`)

		{

			err = mj.From.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"from":null`)
	}
	buf.WriteByte(',')
	if mj.Message != nil {
		if true {
			buf.WriteString(`"message":`)

			{

				err = mj.Message.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(mj.InlineMessageID) != 0 {
		buf.WriteString(`"inline_message_id":`)
		fflib.WriteJsonString(buf, string(mj.InlineMessageID))
		buf.WriteByte(',')
	}
	if len(mj.Data) != 0 {
		buf.WriteString(`"data":`)
		fflib.WriteJsonString(buf, string(mj.Data))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_CallbackQuerybase = iota
	ffj_t_CallbackQueryno_such_key

	ffj_t_CallbackQuery_ID

	ffj_t_CallbackQuery_From

	ffj_t_CallbackQuery_Message

	ffj_t_CallbackQuery_InlineMessageID

	ffj_t_CallbackQuery_Data
)

var ffj_key_CallbackQuery_ID = []byte("id")

var ffj_key_CallbackQuery_From = []byte("from")

var ffj_key_CallbackQuery_Message = []byte("message")

var ffj_key_CallbackQuery_InlineMessageID = []byte("inline_message_id")

var ffj_key_CallbackQuery_Data = []byte("data")

func (uj *CallbackQuery) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *CallbackQuery) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_CallbackQuerybase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_CallbackQueryno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffj_key_CallbackQuery_Data, kn) {
						currentKey = ffj_t_CallbackQuery_Data
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffj_key_CallbackQuery_From, kn) {
						currentKey = ffj_t_CallbackQuery_From
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_CallbackQuery_ID, kn) {
						currentKey = ffj_t_CallbackQuery_ID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_CallbackQuery_InlineMessageID, kn) {
						currentKey = ffj_t_CallbackQuery_InlineMessageID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_CallbackQuery_Message, kn) {
						currentKey = ffj_t_CallbackQuery_Message
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_CallbackQuery_Data, kn) {
					currentKey = ffj_t_CallbackQuery_Data
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_CallbackQuery_InlineMessageID, kn) {
					currentKey = ffj_t_CallbackQuery_InlineMessageID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_CallbackQuery_Message, kn) {
					currentKey = ffj_t_CallbackQuery_Message
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_CallbackQuery_From, kn) {
					currentKey = ffj_t_CallbackQuery_From
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_CallbackQuery_ID, kn) {
					currentKey = ffj_t_CallbackQuery_ID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_CallbackQueryno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_CallbackQuery_ID:
					goto handle_ID

				case ffj_t_CallbackQuery_From:
					goto handle_From

				case ffj_t_CallbackQuery_Message:
					goto handle_Message

				case ffj_t_CallbackQuery_InlineMessageID:
					goto handle_InlineMessageID

				case ffj_t_CallbackQuery_Data:
					goto handle_Data

				case ffj_t_CallbackQueryno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: uj.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_From:

	/* handler: uj.From type=tgbotapi.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.From = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.From == nil {
			uj.From = new(User)
		}

		err = uj.From.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Message:

	/* handler: uj.Message type=tgbotapi.Message kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Message = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Message == nil {
			uj.Message = new(Message)
		}

		err = uj.Message.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InlineMessageID:

	/* handler: uj.InlineMessageID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.InlineMessageID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Data:

	/* handler: uj.Data type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Data = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Chat) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Chat) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"id":`)
	fflib.FormatBits2(buf, uint64(mj.ID), 10, mj.ID < 0)
	buf.WriteString(`,"type":`)
	fflib.WriteJsonString(buf, string(mj.Type))
	buf.WriteString(`,"title":`)
	fflib.WriteJsonString(buf, string(mj.Title))
	buf.WriteString(`,"username":`)
	fflib.WriteJsonString(buf, string(mj.UserName))
	buf.WriteString(`,"first_name":`)
	fflib.WriteJsonString(buf, string(mj.FirstName))
	buf.WriteString(`,"last_name":`)
	fflib.WriteJsonString(buf, string(mj.LastName))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Chatbase = iota
	ffj_t_Chatno_such_key

	ffj_t_Chat_ID

	ffj_t_Chat_Type

	ffj_t_Chat_Title

	ffj_t_Chat_UserName

	ffj_t_Chat_FirstName

	ffj_t_Chat_LastName
)

var ffj_key_Chat_ID = []byte("id")

var ffj_key_Chat_Type = []byte("type")

var ffj_key_Chat_Title = []byte("title")

var ffj_key_Chat_UserName = []byte("username")

var ffj_key_Chat_FirstName = []byte("first_name")

var ffj_key_Chat_LastName = []byte("last_name")

func (uj *Chat) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Chat) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Chatbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Chatno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffj_key_Chat_FirstName, kn) {
						currentKey = ffj_t_Chat_FirstName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_Chat_ID, kn) {
						currentKey = ffj_t_Chat_ID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_Chat_LastName, kn) {
						currentKey = ffj_t_Chat_LastName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_Chat_Type, kn) {
						currentKey = ffj_t_Chat_Type
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Chat_Title, kn) {
						currentKey = ffj_t_Chat_Title
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffj_key_Chat_UserName, kn) {
						currentKey = ffj_t_Chat_UserName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Chat_LastName, kn) {
					currentKey = ffj_t_Chat_LastName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Chat_FirstName, kn) {
					currentKey = ffj_t_Chat_FirstName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Chat_UserName, kn) {
					currentKey = ffj_t_Chat_UserName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Chat_Title, kn) {
					currentKey = ffj_t_Chat_Title
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Chat_Type, kn) {
					currentKey = ffj_t_Chat_Type
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Chat_ID, kn) {
					currentKey = ffj_t_Chat_ID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Chatno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Chat_ID:
					goto handle_ID

				case ffj_t_Chat_Type:
					goto handle_Type

				case ffj_t_Chat_Title:
					goto handle_Title

				case ffj_t_Chat_UserName:
					goto handle_UserName

				case ffj_t_Chat_FirstName:
					goto handle_FirstName

				case ffj_t_Chat_LastName:
					goto handle_LastName

				case ffj_t_Chatno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: uj.ID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.ID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: uj.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: uj.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UserName:

	/* handler: uj.UserName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.UserName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FirstName:

	/* handler: uj.FirstName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.FirstName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LastName:

	/* handler: uj.LastName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.LastName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *ChosenInlineResult) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ChosenInlineResult) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"result_id":`)
	fflib.WriteJsonString(buf, string(mj.ResultID))
	if mj.From != nil {
		buf.WriteString(`,"from":`)

		{

			err = mj.From.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"from":null`)
	}
	if mj.Location != nil {
		buf.WriteString(`,"location":`)

		{

			err = mj.Location.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"location":null`)
	}
	buf.WriteString(`,"inline_message_id":`)
	fflib.WriteJsonString(buf, string(mj.InlineMessageID))
	buf.WriteString(`,"query":`)
	fflib.WriteJsonString(buf, string(mj.Query))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ChosenInlineResultbase = iota
	ffj_t_ChosenInlineResultno_such_key

	ffj_t_ChosenInlineResult_ResultID

	ffj_t_ChosenInlineResult_From

	ffj_t_ChosenInlineResult_Location

	ffj_t_ChosenInlineResult_InlineMessageID

	ffj_t_ChosenInlineResult_Query
)

var ffj_key_ChosenInlineResult_ResultID = []byte("result_id")

var ffj_key_ChosenInlineResult_From = []byte("from")

var ffj_key_ChosenInlineResult_Location = []byte("location")

var ffj_key_ChosenInlineResult_InlineMessageID = []byte("inline_message_id")

var ffj_key_ChosenInlineResult_Query = []byte("query")

func (uj *ChosenInlineResult) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ChosenInlineResult) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ChosenInlineResultbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ChosenInlineResultno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffj_key_ChosenInlineResult_From, kn) {
						currentKey = ffj_t_ChosenInlineResult_From
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_ChosenInlineResult_InlineMessageID, kn) {
						currentKey = ffj_t_ChosenInlineResult_InlineMessageID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_ChosenInlineResult_Location, kn) {
						currentKey = ffj_t_ChosenInlineResult_Location
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'q':

					if bytes.Equal(ffj_key_ChosenInlineResult_Query, kn) {
						currentKey = ffj_t_ChosenInlineResult_Query
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_ChosenInlineResult_ResultID, kn) {
						currentKey = ffj_t_ChosenInlineResult_ResultID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_ChosenInlineResult_Query, kn) {
					currentKey = ffj_t_ChosenInlineResult_Query
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ChosenInlineResult_InlineMessageID, kn) {
					currentKey = ffj_t_ChosenInlineResult_InlineMessageID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ChosenInlineResult_Location, kn) {
					currentKey = ffj_t_ChosenInlineResult_Location
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_ChosenInlineResult_From, kn) {
					currentKey = ffj_t_ChosenInlineResult_From
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ChosenInlineResult_ResultID, kn) {
					currentKey = ffj_t_ChosenInlineResult_ResultID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ChosenInlineResultno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ChosenInlineResult_ResultID:
					goto handle_ResultID

				case ffj_t_ChosenInlineResult_From:
					goto handle_From

				case ffj_t_ChosenInlineResult_Location:
					goto handle_Location

				case ffj_t_ChosenInlineResult_InlineMessageID:
					goto handle_InlineMessageID

				case ffj_t_ChosenInlineResult_Query:
					goto handle_Query

				case ffj_t_ChosenInlineResultno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ResultID:

	/* handler: uj.ResultID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ResultID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_From:

	/* handler: uj.From type=tgbotapi.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.From = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.From == nil {
			uj.From = new(User)
		}

		err = uj.From.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Location:

	/* handler: uj.Location type=tgbotapi.Location kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Location = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Location == nil {
			uj.Location = new(Location)
		}

		err = uj.Location.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InlineMessageID:

	/* handler: uj.InlineMessageID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.InlineMessageID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Query:

	/* handler: uj.Query type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Query = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Contact) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Contact) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "phone_number":`)
	fflib.WriteJsonString(buf, string(mj.PhoneNumber))
	buf.WriteString(`,"first_name":`)
	fflib.WriteJsonString(buf, string(mj.FirstName))
	buf.WriteByte(',')
	if len(mj.LastName) != 0 {
		buf.WriteString(`"last_name":`)
		fflib.WriteJsonString(buf, string(mj.LastName))
		buf.WriteByte(',')
	}
	if mj.UserID != 0 {
		buf.WriteString(`"user_id":`)
		fflib.FormatBits2(buf, uint64(mj.UserID), 10, mj.UserID < 0)
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Contactbase = iota
	ffj_t_Contactno_such_key

	ffj_t_Contact_PhoneNumber

	ffj_t_Contact_FirstName

	ffj_t_Contact_LastName

	ffj_t_Contact_UserID
)

var ffj_key_Contact_PhoneNumber = []byte("phone_number")

var ffj_key_Contact_FirstName = []byte("first_name")

var ffj_key_Contact_LastName = []byte("last_name")

var ffj_key_Contact_UserID = []byte("user_id")

func (uj *Contact) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Contact) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Contactbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Contactno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffj_key_Contact_FirstName, kn) {
						currentKey = ffj_t_Contact_FirstName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_Contact_LastName, kn) {
						currentKey = ffj_t_Contact_LastName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_Contact_PhoneNumber, kn) {
						currentKey = ffj_t_Contact_PhoneNumber
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffj_key_Contact_UserID, kn) {
						currentKey = ffj_t_Contact_UserID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Contact_UserID, kn) {
					currentKey = ffj_t_Contact_UserID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Contact_LastName, kn) {
					currentKey = ffj_t_Contact_LastName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Contact_FirstName, kn) {
					currentKey = ffj_t_Contact_FirstName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Contact_PhoneNumber, kn) {
					currentKey = ffj_t_Contact_PhoneNumber
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Contactno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Contact_PhoneNumber:
					goto handle_PhoneNumber

				case ffj_t_Contact_FirstName:
					goto handle_FirstName

				case ffj_t_Contact_LastName:
					goto handle_LastName

				case ffj_t_Contact_UserID:
					goto handle_UserID

				case ffj_t_Contactno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_PhoneNumber:

	/* handler: uj.PhoneNumber type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.PhoneNumber = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FirstName:

	/* handler: uj.FirstName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.FirstName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LastName:

	/* handler: uj.LastName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.LastName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UserID:

	/* handler: uj.UserID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.UserID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Document) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Document) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "file_id":`)
	fflib.WriteJsonString(buf, string(mj.FileID))
	buf.WriteByte(',')
	if mj.Thumbnail != nil {
		if true {
			buf.WriteString(`"thumb":`)

			{

				err = mj.Thumbnail.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(mj.FileName) != 0 {
		buf.WriteString(`"file_name":`)
		fflib.WriteJsonString(buf, string(mj.FileName))
		buf.WriteByte(',')
	}
	if len(mj.MimeType) != 0 {
		buf.WriteString(`"mime_type":`)
		fflib.WriteJsonString(buf, string(mj.MimeType))
		buf.WriteByte(',')
	}
	if mj.FileSize != 0 {
		buf.WriteString(`"file_size":`)
		fflib.FormatBits2(buf, uint64(mj.FileSize), 10, mj.FileSize < 0)
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Documentbase = iota
	ffj_t_Documentno_such_key

	ffj_t_Document_FileID

	ffj_t_Document_Thumbnail

	ffj_t_Document_FileName

	ffj_t_Document_MimeType

	ffj_t_Document_FileSize
)

var ffj_key_Document_FileID = []byte("file_id")

var ffj_key_Document_Thumbnail = []byte("thumb")

var ffj_key_Document_FileName = []byte("file_name")

var ffj_key_Document_MimeType = []byte("mime_type")

var ffj_key_Document_FileSize = []byte("file_size")

func (uj *Document) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Document) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Documentbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Documentno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffj_key_Document_FileID, kn) {
						currentKey = ffj_t_Document_FileID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Document_FileName, kn) {
						currentKey = ffj_t_Document_FileName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Document_FileSize, kn) {
						currentKey = ffj_t_Document_FileSize
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_Document_MimeType, kn) {
						currentKey = ffj_t_Document_MimeType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_Document_Thumbnail, kn) {
						currentKey = ffj_t_Document_Thumbnail
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Document_FileSize, kn) {
					currentKey = ffj_t_Document_FileSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Document_MimeType, kn) {
					currentKey = ffj_t_Document_MimeType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Document_FileName, kn) {
					currentKey = ffj_t_Document_FileName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Document_Thumbnail, kn) {
					currentKey = ffj_t_Document_Thumbnail
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Document_FileID, kn) {
					currentKey = ffj_t_Document_FileID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Documentno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Document_FileID:
					goto handle_FileID

				case ffj_t_Document_Thumbnail:
					goto handle_Thumbnail

				case ffj_t_Document_FileName:
					goto handle_FileName

				case ffj_t_Document_MimeType:
					goto handle_MimeType

				case ffj_t_Document_FileSize:
					goto handle_FileSize

				case ffj_t_Documentno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_FileID:

	/* handler: uj.FileID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.FileID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Thumbnail:

	/* handler: uj.Thumbnail type=tgbotapi.PhotoSize kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Thumbnail = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Thumbnail == nil {
			uj.Thumbnail = new(PhotoSize)
		}

		err = uj.Thumbnail.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileName:

	/* handler: uj.FileName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.FileName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MimeType:

	/* handler: uj.MimeType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.MimeType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileSize:

	/* handler: uj.FileSize type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.FileSize = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *File) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *File) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "file_id":`)
	fflib.WriteJsonString(buf, string(mj.FileID))
	buf.WriteByte(',')
	if mj.FileSize != 0 {
		buf.WriteString(`"file_size":`)
		fflib.FormatBits2(buf, uint64(mj.FileSize), 10, mj.FileSize < 0)
		buf.WriteByte(',')
	}
	if len(mj.FilePath) != 0 {
		buf.WriteString(`"file_path":`)
		fflib.WriteJsonString(buf, string(mj.FilePath))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Filebase = iota
	ffj_t_Fileno_such_key

	ffj_t_File_FileID

	ffj_t_File_FileSize

	ffj_t_File_FilePath
)

var ffj_key_File_FileID = []byte("file_id")

var ffj_key_File_FileSize = []byte("file_size")

var ffj_key_File_FilePath = []byte("file_path")

func (uj *File) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *File) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Filebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Fileno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffj_key_File_FileID, kn) {
						currentKey = ffj_t_File_FileID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_File_FileSize, kn) {
						currentKey = ffj_t_File_FileSize
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_File_FilePath, kn) {
						currentKey = ffj_t_File_FilePath
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_File_FilePath, kn) {
					currentKey = ffj_t_File_FilePath
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_File_FileSize, kn) {
					currentKey = ffj_t_File_FileSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_File_FileID, kn) {
					currentKey = ffj_t_File_FileID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Fileno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_File_FileID:
					goto handle_FileID

				case ffj_t_File_FileSize:
					goto handle_FileSize

				case ffj_t_File_FilePath:
					goto handle_FilePath

				case ffj_t_Fileno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_FileID:

	/* handler: uj.FileID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.FileID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileSize:

	/* handler: uj.FileSize type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.FileSize = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FilePath:

	/* handler: uj.FilePath type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.FilePath = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *ForceReply) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ForceReply) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if mj.ForceReply {
		buf.WriteString(`{"force_reply":true`)
	} else {
		buf.WriteString(`{"force_reply":false`)
	}
	if mj.Selective {
		buf.WriteString(`,"selective":true`)
	} else {
		buf.WriteString(`,"selective":false`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ForceReplybase = iota
	ffj_t_ForceReplyno_such_key

	ffj_t_ForceReply_ForceReply

	ffj_t_ForceReply_Selective
)

var ffj_key_ForceReply_ForceReply = []byte("force_reply")

var ffj_key_ForceReply_Selective = []byte("selective")

func (uj *ForceReply) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ForceReply) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ForceReplybase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ForceReplyno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffj_key_ForceReply_ForceReply, kn) {
						currentKey = ffj_t_ForceReply_ForceReply
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_ForceReply_Selective, kn) {
						currentKey = ffj_t_ForceReply_Selective
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_ForceReply_Selective, kn) {
					currentKey = ffj_t_ForceReply_Selective
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_ForceReply_ForceReply, kn) {
					currentKey = ffj_t_ForceReply_ForceReply
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ForceReplyno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ForceReply_ForceReply:
					goto handle_ForceReply

				case ffj_t_ForceReply_Selective:
					goto handle_Selective

				case ffj_t_ForceReplyno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ForceReply:

	/* handler: uj.ForceReply type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.ForceReply = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.ForceReply = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Selective:

	/* handler: uj.Selective type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.Selective = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.Selective = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *GroupChat) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *GroupChat) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"id":`)
	fflib.FormatBits2(buf, uint64(mj.ID), 10, mj.ID < 0)
	buf.WriteString(`,"title":`)
	fflib.WriteJsonString(buf, string(mj.Title))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_GroupChatbase = iota
	ffj_t_GroupChatno_such_key

	ffj_t_GroupChat_ID

	ffj_t_GroupChat_Title
)

var ffj_key_GroupChat_ID = []byte("id")

var ffj_key_GroupChat_Title = []byte("title")

func (uj *GroupChat) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *GroupChat) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_GroupChatbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_GroupChatno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'i':

					if bytes.Equal(ffj_key_GroupChat_ID, kn) {
						currentKey = ffj_t_GroupChat_ID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_GroupChat_Title, kn) {
						currentKey = ffj_t_GroupChat_Title
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_GroupChat_Title, kn) {
					currentKey = ffj_t_GroupChat_Title
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_GroupChat_ID, kn) {
					currentKey = ffj_t_GroupChat_ID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_GroupChatno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_GroupChat_ID:
					goto handle_ID

				case ffj_t_GroupChat_Title:
					goto handle_Title

				case ffj_t_GroupChatno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: uj.ID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.ID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: uj.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *InlineKeyboardButton) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *InlineKeyboardButton) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "text":`)
	fflib.WriteJsonString(buf, string(mj.Text))
	buf.WriteByte(',')
	if len(mj.URL) != 0 {
		buf.WriteString(`"url":`)
		fflib.WriteJsonString(buf, string(mj.URL))
		buf.WriteByte(',')
	}
	if len(mj.CallbackData) != 0 {
		buf.WriteString(`"callback_data":`)
		fflib.WriteJsonString(buf, string(mj.CallbackData))
		buf.WriteByte(',')
	}
	if mj.SwitchInlineQuery != nil {
		if true {
			buf.WriteString(`"switch_inline_query":`)
			fflib.WriteJsonString(buf, string(*mj.SwitchInlineQuery))
			buf.WriteByte(',')
		}
	}
	if mj.SwitchInlineQueryCurrentChat != nil {
		if true {
			buf.WriteString(`"switch_inline_query_current_chat":`)
			fflib.WriteJsonString(buf, string(*mj.SwitchInlineQueryCurrentChat))
			buf.WriteByte(',')
		}
	}
	if mj.Pay != false {
		if mj.Pay {
			buf.WriteString(`"pay":true`)
		} else {
			buf.WriteString(`"pay":false`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_InlineKeyboardButtonbase = iota
	ffj_t_InlineKeyboardButtonno_such_key

	ffj_t_InlineKeyboardButton_Text

	ffj_t_InlineKeyboardButton_URL

	ffj_t_InlineKeyboardButton_CallbackData

	ffj_t_InlineKeyboardButton_SwitchInlineQuery

	ffj_t_InlineKeyboardButton_SwitchInlineQueryCurrentChat

	ffj_t_InlineKeyboardButton_Pay
)

var ffj_key_InlineKeyboardButton_Text = []byte("text")

var ffj_key_InlineKeyboardButton_URL = []byte("url")

var ffj_key_InlineKeyboardButton_CallbackData = []byte("callback_data")

var ffj_key_InlineKeyboardButton_SwitchInlineQuery = []byte("switch_inline_query")

var ffj_key_InlineKeyboardButton_SwitchInlineQueryCurrentChat = []byte("switch_inline_query_current_chat")

var ffj_key_InlineKeyboardButton_Pay = []byte("pay")

func (uj *InlineKeyboardButton) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *InlineKeyboardButton) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_InlineKeyboardButtonbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_InlineKeyboardButtonno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_InlineKeyboardButton_CallbackData, kn) {
						currentKey = ffj_t_InlineKeyboardButton_CallbackData
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_InlineKeyboardButton_Pay, kn) {
						currentKey = ffj_t_InlineKeyboardButton_Pay
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_InlineKeyboardButton_SwitchInlineQuery, kn) {
						currentKey = ffj_t_InlineKeyboardButton_SwitchInlineQuery
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InlineKeyboardButton_SwitchInlineQueryCurrentChat, kn) {
						currentKey = ffj_t_InlineKeyboardButton_SwitchInlineQueryCurrentChat
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_InlineKeyboardButton_Text, kn) {
						currentKey = ffj_t_InlineKeyboardButton_Text
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffj_key_InlineKeyboardButton_URL, kn) {
						currentKey = ffj_t_InlineKeyboardButton_URL
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_InlineKeyboardButton_Pay, kn) {
					currentKey = ffj_t_InlineKeyboardButton_Pay
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_InlineKeyboardButton_SwitchInlineQueryCurrentChat, kn) {
					currentKey = ffj_t_InlineKeyboardButton_SwitchInlineQueryCurrentChat
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_InlineKeyboardButton_SwitchInlineQuery, kn) {
					currentKey = ffj_t_InlineKeyboardButton_SwitchInlineQuery
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_InlineKeyboardButton_CallbackData, kn) {
					currentKey = ffj_t_InlineKeyboardButton_CallbackData
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InlineKeyboardButton_URL, kn) {
					currentKey = ffj_t_InlineKeyboardButton_URL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InlineKeyboardButton_Text, kn) {
					currentKey = ffj_t_InlineKeyboardButton_Text
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_InlineKeyboardButtonno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_InlineKeyboardButton_Text:
					goto handle_Text

				case ffj_t_InlineKeyboardButton_URL:
					goto handle_URL

				case ffj_t_InlineKeyboardButton_CallbackData:
					goto handle_CallbackData

				case ffj_t_InlineKeyboardButton_SwitchInlineQuery:
					goto handle_SwitchInlineQuery

				case ffj_t_InlineKeyboardButton_SwitchInlineQueryCurrentChat:
					goto handle_SwitchInlineQueryCurrentChat

				case ffj_t_InlineKeyboardButton_Pay:
					goto handle_Pay

				case ffj_t_InlineKeyboardButtonno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Text:

	/* handler: uj.Text type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Text = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_URL:

	/* handler: uj.URL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.URL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CallbackData:

	/* handler: uj.CallbackData type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.CallbackData = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SwitchInlineQuery:

	/* handler: uj.SwitchInlineQuery type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.SwitchInlineQuery = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.SwitchInlineQuery = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SwitchInlineQueryCurrentChat:

	/* handler: uj.SwitchInlineQueryCurrentChat type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

			uj.SwitchInlineQueryCurrentChat = nil

		} else {

			var tval string
			outBuf := fs.Output.Bytes()

			tval = string(string(outBuf))
			uj.SwitchInlineQueryCurrentChat = &tval

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Pay:

	/* handler: uj.Pay type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.Pay = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.Pay = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *InlineKeyboardMarkup) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *InlineKeyboardMarkup) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"inline_keyboard":`)
	if mj.InlineKeyboard != nil {
		buf.WriteString(`[`)
		for i, v := range mj.InlineKeyboard {
			if i != 0 {
				buf.WriteString(`,`)
			}
			if v != nil {
				buf.WriteString(`[`)
				for i, v := range v {
					if i != 0 {
						buf.WriteString(`,`)
					}

					{

						err = v.MarshalJSONBuf(buf)
						if err != nil {
							return err
						}

					}
				}
				buf.WriteString(`]`)
			} else {
				buf.WriteString(`null`)
			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_InlineKeyboardMarkupbase = iota
	ffj_t_InlineKeyboardMarkupno_such_key

	ffj_t_InlineKeyboardMarkup_InlineKeyboard
)

var ffj_key_InlineKeyboardMarkup_InlineKeyboard = []byte("inline_keyboard")

func (uj *InlineKeyboardMarkup) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *InlineKeyboardMarkup) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_InlineKeyboardMarkupbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_InlineKeyboardMarkupno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'i':

					if bytes.Equal(ffj_key_InlineKeyboardMarkup_InlineKeyboard, kn) {
						currentKey = ffj_t_InlineKeyboardMarkup_InlineKeyboard
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_InlineKeyboardMarkup_InlineKeyboard, kn) {
					currentKey = ffj_t_InlineKeyboardMarkup_InlineKeyboard
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_InlineKeyboardMarkupno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_InlineKeyboardMarkup_InlineKeyboard:
					goto handle_InlineKeyboard

				case ffj_t_InlineKeyboardMarkupno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_InlineKeyboard:

	/* handler: uj.InlineKeyboard type=[][]tgbotapi.InlineKeyboardButton kind=slice quoted=false*/

	{
		/* Falling back. type=[][]tgbotapi.InlineKeyboardButton kind=slice */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.InlineKeyboard)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *InlineQuery) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *InlineQuery) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"id":`)
	fflib.WriteJsonString(buf, string(mj.ID))
	if mj.From != nil {
		buf.WriteString(`,"from":`)

		{

			err = mj.From.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"from":null`)
	}
	buf.WriteByte(',')
	if mj.Location != nil {
		if true {
			buf.WriteString(`"location":`)

			{

				err = mj.Location.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.WriteString(`"query":`)
	fflib.WriteJsonString(buf, string(mj.Query))
	buf.WriteString(`,"offset":`)
	fflib.WriteJsonString(buf, string(mj.Offset))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_InlineQuerybase = iota
	ffj_t_InlineQueryno_such_key

	ffj_t_InlineQuery_ID

	ffj_t_InlineQuery_From

	ffj_t_InlineQuery_Location

	ffj_t_InlineQuery_Query

	ffj_t_InlineQuery_Offset
)

var ffj_key_InlineQuery_ID = []byte("id")

var ffj_key_InlineQuery_From = []byte("from")

var ffj_key_InlineQuery_Location = []byte("location")

var ffj_key_InlineQuery_Query = []byte("query")

var ffj_key_InlineQuery_Offset = []byte("offset")

func (uj *InlineQuery) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *InlineQuery) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_InlineQuerybase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_InlineQueryno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffj_key_InlineQuery_From, kn) {
						currentKey = ffj_t_InlineQuery_From
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_InlineQuery_ID, kn) {
						currentKey = ffj_t_InlineQuery_ID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_InlineQuery_Location, kn) {
						currentKey = ffj_t_InlineQuery_Location
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffj_key_InlineQuery_Offset, kn) {
						currentKey = ffj_t_InlineQuery_Offset
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'q':

					if bytes.Equal(ffj_key_InlineQuery_Query, kn) {
						currentKey = ffj_t_InlineQuery_Query
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_InlineQuery_Offset, kn) {
					currentKey = ffj_t_InlineQuery_Offset
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InlineQuery_Query, kn) {
					currentKey = ffj_t_InlineQuery_Query
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InlineQuery_Location, kn) {
					currentKey = ffj_t_InlineQuery_Location
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InlineQuery_From, kn) {
					currentKey = ffj_t_InlineQuery_From
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InlineQuery_ID, kn) {
					currentKey = ffj_t_InlineQuery_ID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_InlineQueryno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_InlineQuery_ID:
					goto handle_ID

				case ffj_t_InlineQuery_From:
					goto handle_From

				case ffj_t_InlineQuery_Location:
					goto handle_Location

				case ffj_t_InlineQuery_Query:
					goto handle_Query

				case ffj_t_InlineQuery_Offset:
					goto handle_Offset

				case ffj_t_InlineQueryno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: uj.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_From:

	/* handler: uj.From type=tgbotapi.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.From = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.From == nil {
			uj.From = new(User)
		}

		err = uj.From.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Location:

	/* handler: uj.Location type=tgbotapi.Location kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Location = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Location == nil {
			uj.Location = new(Location)
		}

		err = uj.Location.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Query:

	/* handler: uj.Query type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Query = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Offset:

	/* handler: uj.Offset type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Offset = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *InlineQueryResultArticle) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *InlineQueryResultArticle) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "type":`)
	fflib.WriteJsonString(buf, string(mj.Type))
	buf.WriteString(`,"id":`)
	fflib.WriteJsonString(buf, string(mj.ID))
	buf.WriteString(`,"title":`)
	fflib.WriteJsonString(buf, string(mj.Title))
	buf.WriteString(`,"input_message_content":`)
	/* Interface types must use runtime reflection. type=interface {} kind=interface */
	err = buf.Encode(mj.InputMessageContent)
	if err != nil {
		return err
	}
	buf.WriteByte(',')
	if mj.ReplyMarkup != nil {
		if true {
			buf.WriteString(`"reply_markup":`)

			{

				err = mj.ReplyMarkup.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(mj.URL) != 0 {
		buf.WriteString(`"url":`)
		fflib.WriteJsonString(buf, string(mj.URL))
		buf.WriteByte(',')
	}
	if mj.HideURL != false {
		if mj.HideURL {
			buf.WriteString(`"hide_url":true`)
		} else {
			buf.WriteString(`"hide_url":false`)
		}
		buf.WriteByte(',')
	}
	if len(mj.Description) != 0 {
		buf.WriteString(`"description":`)
		fflib.WriteJsonString(buf, string(mj.Description))
		buf.WriteByte(',')
	}
	if len(mj.ThumbURL) != 0 {
		buf.WriteString(`"thumb_url":`)
		fflib.WriteJsonString(buf, string(mj.ThumbURL))
		buf.WriteByte(',')
	}
	if mj.ThumbWidth != 0 {
		buf.WriteString(`"thumb_width":`)
		fflib.FormatBits2(buf, uint64(mj.ThumbWidth), 10, mj.ThumbWidth < 0)
		buf.WriteByte(',')
	}
	if mj.ThumbHeight != 0 {
		buf.WriteString(`"thumb_height":`)
		fflib.FormatBits2(buf, uint64(mj.ThumbHeight), 10, mj.ThumbHeight < 0)
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_InlineQueryResultArticlebase = iota
	ffj_t_InlineQueryResultArticleno_such_key

	ffj_t_InlineQueryResultArticle_Type

	ffj_t_InlineQueryResultArticle_ID

	ffj_t_InlineQueryResultArticle_Title

	ffj_t_InlineQueryResultArticle_InputMessageContent

	ffj_t_InlineQueryResultArticle_ReplyMarkup

	ffj_t_InlineQueryResultArticle_URL

	ffj_t_InlineQueryResultArticle_HideURL

	ffj_t_InlineQueryResultArticle_Description

	ffj_t_InlineQueryResultArticle_ThumbURL

	ffj_t_InlineQueryResultArticle_ThumbWidth

	ffj_t_InlineQueryResultArticle_ThumbHeight
)

var ffj_key_InlineQueryResultArticle_Type = []byte("type")

var ffj_key_InlineQueryResultArticle_ID = []byte("id")

var ffj_key_InlineQueryResultArticle_Title = []byte("title")

var ffj_key_InlineQueryResultArticle_InputMessageContent = []byte("input_message_content")

var ffj_key_InlineQueryResultArticle_ReplyMarkup = []byte("reply_markup")

var ffj_key_InlineQueryResultArticle_URL = []byte("url")

var ffj_key_InlineQueryResultArticle_HideURL = []byte("hide_url")

var ffj_key_InlineQueryResultArticle_Description = []byte("description")

var ffj_key_InlineQueryResultArticle_ThumbURL = []byte("thumb_url")

var ffj_key_InlineQueryResultArticle_ThumbWidth = []byte("thumb_width")

var ffj_key_InlineQueryResultArticle_ThumbHeight = []byte("thumb_height")

func (uj *InlineQueryResultArticle) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *InlineQueryResultArticle) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_InlineQueryResultArticlebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_InlineQueryResultArticleno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffj_key_InlineQueryResultArticle_Description, kn) {
						currentKey = ffj_t_InlineQueryResultArticle_Description
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffj_key_InlineQueryResultArticle_HideURL, kn) {
						currentKey = ffj_t_InlineQueryResultArticle_HideURL
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_InlineQueryResultArticle_ID, kn) {
						currentKey = ffj_t_InlineQueryResultArticle_ID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InlineQueryResultArticle_InputMessageContent, kn) {
						currentKey = ffj_t_InlineQueryResultArticle_InputMessageContent
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_InlineQueryResultArticle_ReplyMarkup, kn) {
						currentKey = ffj_t_InlineQueryResultArticle_ReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_InlineQueryResultArticle_Type, kn) {
						currentKey = ffj_t_InlineQueryResultArticle_Type
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InlineQueryResultArticle_Title, kn) {
						currentKey = ffj_t_InlineQueryResultArticle_Title
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InlineQueryResultArticle_ThumbURL, kn) {
						currentKey = ffj_t_InlineQueryResultArticle_ThumbURL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InlineQueryResultArticle_ThumbWidth, kn) {
						currentKey = ffj_t_InlineQueryResultArticle_ThumbWidth
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InlineQueryResultArticle_ThumbHeight, kn) {
						currentKey = ffj_t_InlineQueryResultArticle_ThumbHeight
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffj_key_InlineQueryResultArticle_URL, kn) {
						currentKey = ffj_t_InlineQueryResultArticle_URL
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_InlineQueryResultArticle_ThumbHeight, kn) {
					currentKey = ffj_t_InlineQueryResultArticle_ThumbHeight
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_InlineQueryResultArticle_ThumbWidth, kn) {
					currentKey = ffj_t_InlineQueryResultArticle_ThumbWidth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_InlineQueryResultArticle_ThumbURL, kn) {
					currentKey = ffj_t_InlineQueryResultArticle_ThumbURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_InlineQueryResultArticle_Description, kn) {
					currentKey = ffj_t_InlineQueryResultArticle_Description
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_InlineQueryResultArticle_HideURL, kn) {
					currentKey = ffj_t_InlineQueryResultArticle_HideURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InlineQueryResultArticle_URL, kn) {
					currentKey = ffj_t_InlineQueryResultArticle_URL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_InlineQueryResultArticle_ReplyMarkup, kn) {
					currentKey = ffj_t_InlineQueryResultArticle_ReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_InlineQueryResultArticle_InputMessageContent, kn) {
					currentKey = ffj_t_InlineQueryResultArticle_InputMessageContent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InlineQueryResultArticle_Title, kn) {
					currentKey = ffj_t_InlineQueryResultArticle_Title
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InlineQueryResultArticle_ID, kn) {
					currentKey = ffj_t_InlineQueryResultArticle_ID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InlineQueryResultArticle_Type, kn) {
					currentKey = ffj_t_InlineQueryResultArticle_Type
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_InlineQueryResultArticleno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_InlineQueryResultArticle_Type:
					goto handle_Type

				case ffj_t_InlineQueryResultArticle_ID:
					goto handle_ID

				case ffj_t_InlineQueryResultArticle_Title:
					goto handle_Title

				case ffj_t_InlineQueryResultArticle_InputMessageContent:
					goto handle_InputMessageContent

				case ffj_t_InlineQueryResultArticle_ReplyMarkup:
					goto handle_ReplyMarkup

				case ffj_t_InlineQueryResultArticle_URL:
					goto handle_URL

				case ffj_t_InlineQueryResultArticle_HideURL:
					goto handle_HideURL

				case ffj_t_InlineQueryResultArticle_Description:
					goto handle_Description

				case ffj_t_InlineQueryResultArticle_ThumbURL:
					goto handle_ThumbURL

				case ffj_t_InlineQueryResultArticle_ThumbWidth:
					goto handle_ThumbWidth

				case ffj_t_InlineQueryResultArticle_ThumbHeight:
					goto handle_ThumbHeight

				case ffj_t_InlineQueryResultArticleno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: uj.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: uj.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: uj.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InputMessageContent:

	/* handler: uj.InputMessageContent type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.InputMessageContent)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: uj.ReplyMarkup type=tgbotapi.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.ReplyMarkup = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.ReplyMarkup == nil {
			uj.ReplyMarkup = new(InlineKeyboardMarkup)
		}

		err = uj.ReplyMarkup.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_URL:

	/* handler: uj.URL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.URL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_HideURL:

	/* handler: uj.HideURL type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.HideURL = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.HideURL = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Description:

	/* handler: uj.Description type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Description = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ThumbURL:

	/* handler: uj.ThumbURL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ThumbURL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ThumbWidth:

	/* handler: uj.ThumbWidth type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.ThumbWidth = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ThumbHeight:

	/* handler: uj.ThumbHeight type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.ThumbHeight = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *InlineQueryResultAudio) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *InlineQueryResultAudio) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "type":`)
	fflib.WriteJsonString(buf, string(mj.Type))
	buf.WriteString(`,"id":`)
	fflib.WriteJsonString(buf, string(mj.ID))
	buf.WriteString(`,"audio_url":`)
	fflib.WriteJsonString(buf, string(mj.URL))
	buf.WriteString(`,"title":`)
	fflib.WriteJsonString(buf, string(mj.Title))
	buf.WriteString(`,"performer":`)
	fflib.WriteJsonString(buf, string(mj.Performer))
	buf.WriteString(`,"audio_duration":`)
	fflib.FormatBits2(buf, uint64(mj.Duration), 10, mj.Duration < 0)
	buf.WriteByte(',')
	if mj.ReplyMarkup != nil {
		if true {
			buf.WriteString(`"reply_markup":`)

			{

				err = mj.ReplyMarkup.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.InputMessageContent != nil {
		buf.WriteString(`"input_message_content":`)
		/* Interface types must use runtime reflection. type=interface {} kind=interface */
		err = buf.Encode(mj.InputMessageContent)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_InlineQueryResultAudiobase = iota
	ffj_t_InlineQueryResultAudiono_such_key

	ffj_t_InlineQueryResultAudio_Type

	ffj_t_InlineQueryResultAudio_ID

	ffj_t_InlineQueryResultAudio_URL

	ffj_t_InlineQueryResultAudio_Title

	ffj_t_InlineQueryResultAudio_Performer

	ffj_t_InlineQueryResultAudio_Duration

	ffj_t_InlineQueryResultAudio_ReplyMarkup

	ffj_t_InlineQueryResultAudio_InputMessageContent
)

var ffj_key_InlineQueryResultAudio_Type = []byte("type")

var ffj_key_InlineQueryResultAudio_ID = []byte("id")

var ffj_key_InlineQueryResultAudio_URL = []byte("audio_url")

var ffj_key_InlineQueryResultAudio_Title = []byte("title")

var ffj_key_InlineQueryResultAudio_Performer = []byte("performer")

var ffj_key_InlineQueryResultAudio_Duration = []byte("audio_duration")

var ffj_key_InlineQueryResultAudio_ReplyMarkup = []byte("reply_markup")

var ffj_key_InlineQueryResultAudio_InputMessageContent = []byte("input_message_content")

func (uj *InlineQueryResultAudio) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *InlineQueryResultAudio) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_InlineQueryResultAudiobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_InlineQueryResultAudiono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_InlineQueryResultAudio_URL, kn) {
						currentKey = ffj_t_InlineQueryResultAudio_URL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InlineQueryResultAudio_Duration, kn) {
						currentKey = ffj_t_InlineQueryResultAudio_Duration
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_InlineQueryResultAudio_ID, kn) {
						currentKey = ffj_t_InlineQueryResultAudio_ID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InlineQueryResultAudio_InputMessageContent, kn) {
						currentKey = ffj_t_InlineQueryResultAudio_InputMessageContent
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_InlineQueryResultAudio_Performer, kn) {
						currentKey = ffj_t_InlineQueryResultAudio_Performer
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_InlineQueryResultAudio_ReplyMarkup, kn) {
						currentKey = ffj_t_InlineQueryResultAudio_ReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_InlineQueryResultAudio_Type, kn) {
						currentKey = ffj_t_InlineQueryResultAudio_Type
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InlineQueryResultAudio_Title, kn) {
						currentKey = ffj_t_InlineQueryResultAudio_Title
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_InlineQueryResultAudio_InputMessageContent, kn) {
					currentKey = ffj_t_InlineQueryResultAudio_InputMessageContent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_InlineQueryResultAudio_ReplyMarkup, kn) {
					currentKey = ffj_t_InlineQueryResultAudio_ReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_InlineQueryResultAudio_Duration, kn) {
					currentKey = ffj_t_InlineQueryResultAudio_Duration
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InlineQueryResultAudio_Performer, kn) {
					currentKey = ffj_t_InlineQueryResultAudio_Performer
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InlineQueryResultAudio_Title, kn) {
					currentKey = ffj_t_InlineQueryResultAudio_Title
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_InlineQueryResultAudio_URL, kn) {
					currentKey = ffj_t_InlineQueryResultAudio_URL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InlineQueryResultAudio_ID, kn) {
					currentKey = ffj_t_InlineQueryResultAudio_ID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InlineQueryResultAudio_Type, kn) {
					currentKey = ffj_t_InlineQueryResultAudio_Type
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_InlineQueryResultAudiono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_InlineQueryResultAudio_Type:
					goto handle_Type

				case ffj_t_InlineQueryResultAudio_ID:
					goto handle_ID

				case ffj_t_InlineQueryResultAudio_URL:
					goto handle_URL

				case ffj_t_InlineQueryResultAudio_Title:
					goto handle_Title

				case ffj_t_InlineQueryResultAudio_Performer:
					goto handle_Performer

				case ffj_t_InlineQueryResultAudio_Duration:
					goto handle_Duration

				case ffj_t_InlineQueryResultAudio_ReplyMarkup:
					goto handle_ReplyMarkup

				case ffj_t_InlineQueryResultAudio_InputMessageContent:
					goto handle_InputMessageContent

				case ffj_t_InlineQueryResultAudiono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: uj.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: uj.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_URL:

	/* handler: uj.URL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.URL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: uj.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Performer:

	/* handler: uj.Performer type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Performer = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Duration:

	/* handler: uj.Duration type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Duration = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: uj.ReplyMarkup type=tgbotapi.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.ReplyMarkup = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.ReplyMarkup == nil {
			uj.ReplyMarkup = new(InlineKeyboardMarkup)
		}

		err = uj.ReplyMarkup.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InputMessageContent:

	/* handler: uj.InputMessageContent type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.InputMessageContent)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *InlineQueryResultDocument) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *InlineQueryResultDocument) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"type":`)
	fflib.WriteJsonString(buf, string(mj.Type))
	buf.WriteString(`,"id":`)
	fflib.WriteJsonString(buf, string(mj.ID))
	buf.WriteString(`,"title":`)
	fflib.WriteJsonString(buf, string(mj.Title))
	buf.WriteString(`,"caption":`)
	fflib.WriteJsonString(buf, string(mj.Caption))
	buf.WriteString(`,"document_url":`)
	fflib.WriteJsonString(buf, string(mj.URL))
	buf.WriteString(`,"mime_type":`)
	fflib.WriteJsonString(buf, string(mj.MimeType))
	buf.WriteString(`,"description":`)
	fflib.WriteJsonString(buf, string(mj.Description))
	buf.WriteByte(',')
	if mj.ReplyMarkup != nil {
		if true {
			buf.WriteString(`"reply_markup":`)

			{

				err = mj.ReplyMarkup.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.InputMessageContent != nil {
		buf.WriteString(`"input_message_content":`)
		/* Interface types must use runtime reflection. type=interface {} kind=interface */
		err = buf.Encode(mj.InputMessageContent)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	buf.WriteString(`"thumb_url":`)
	fflib.WriteJsonString(buf, string(mj.ThumbURL))
	buf.WriteString(`,"thumb_width":`)
	fflib.FormatBits2(buf, uint64(mj.ThumbWidth), 10, mj.ThumbWidth < 0)
	buf.WriteString(`,"thumb_height":`)
	fflib.FormatBits2(buf, uint64(mj.ThumbHeight), 10, mj.ThumbHeight < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_InlineQueryResultDocumentbase = iota
	ffj_t_InlineQueryResultDocumentno_such_key

	ffj_t_InlineQueryResultDocument_Type

	ffj_t_InlineQueryResultDocument_ID

	ffj_t_InlineQueryResultDocument_Title

	ffj_t_InlineQueryResultDocument_Caption

	ffj_t_InlineQueryResultDocument_URL

	ffj_t_InlineQueryResultDocument_MimeType

	ffj_t_InlineQueryResultDocument_Description

	ffj_t_InlineQueryResultDocument_ReplyMarkup

	ffj_t_InlineQueryResultDocument_InputMessageContent

	ffj_t_InlineQueryResultDocument_ThumbURL

	ffj_t_InlineQueryResultDocument_ThumbWidth

	ffj_t_InlineQueryResultDocument_ThumbHeight
)

var ffj_key_InlineQueryResultDocument_Type = []byte("type")

var ffj_key_InlineQueryResultDocument_ID = []byte("id")

var ffj_key_InlineQueryResultDocument_Title = []byte("title")

var ffj_key_InlineQueryResultDocument_Caption = []byte("caption")

var ffj_key_InlineQueryResultDocument_URL = []byte("document_url")

var ffj_key_InlineQueryResultDocument_MimeType = []byte("mime_type")

var ffj_key_InlineQueryResultDocument_Description = []byte("description")

var ffj_key_InlineQueryResultDocument_ReplyMarkup = []byte("reply_markup")

var ffj_key_InlineQueryResultDocument_InputMessageContent = []byte("input_message_content")

var ffj_key_InlineQueryResultDocument_ThumbURL = []byte("thumb_url")

var ffj_key_InlineQueryResultDocument_ThumbWidth = []byte("thumb_width")

var ffj_key_InlineQueryResultDocument_ThumbHeight = []byte("thumb_height")

func (uj *InlineQueryResultDocument) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *InlineQueryResultDocument) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_InlineQueryResultDocumentbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_InlineQueryResultDocumentno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_InlineQueryResultDocument_Caption, kn) {
						currentKey = ffj_t_InlineQueryResultDocument_Caption
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_InlineQueryResultDocument_URL, kn) {
						currentKey = ffj_t_InlineQueryResultDocument_URL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InlineQueryResultDocument_Description, kn) {
						currentKey = ffj_t_InlineQueryResultDocument_Description
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_InlineQueryResultDocument_ID, kn) {
						currentKey = ffj_t_InlineQueryResultDocument_ID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InlineQueryResultDocument_InputMessageContent, kn) {
						currentKey = ffj_t_InlineQueryResultDocument_InputMessageContent
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_InlineQueryResultDocument_MimeType, kn) {
						currentKey = ffj_t_InlineQueryResultDocument_MimeType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_InlineQueryResultDocument_ReplyMarkup, kn) {
						currentKey = ffj_t_InlineQueryResultDocument_ReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_InlineQueryResultDocument_Type, kn) {
						currentKey = ffj_t_InlineQueryResultDocument_Type
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InlineQueryResultDocument_Title, kn) {
						currentKey = ffj_t_InlineQueryResultDocument_Title
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InlineQueryResultDocument_ThumbURL, kn) {
						currentKey = ffj_t_InlineQueryResultDocument_ThumbURL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InlineQueryResultDocument_ThumbWidth, kn) {
						currentKey = ffj_t_InlineQueryResultDocument_ThumbWidth
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InlineQueryResultDocument_ThumbHeight, kn) {
						currentKey = ffj_t_InlineQueryResultDocument_ThumbHeight
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_InlineQueryResultDocument_ThumbHeight, kn) {
					currentKey = ffj_t_InlineQueryResultDocument_ThumbHeight
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_InlineQueryResultDocument_ThumbWidth, kn) {
					currentKey = ffj_t_InlineQueryResultDocument_ThumbWidth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_InlineQueryResultDocument_ThumbURL, kn) {
					currentKey = ffj_t_InlineQueryResultDocument_ThumbURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_InlineQueryResultDocument_InputMessageContent, kn) {
					currentKey = ffj_t_InlineQueryResultDocument_InputMessageContent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_InlineQueryResultDocument_ReplyMarkup, kn) {
					currentKey = ffj_t_InlineQueryResultDocument_ReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_InlineQueryResultDocument_Description, kn) {
					currentKey = ffj_t_InlineQueryResultDocument_Description
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_InlineQueryResultDocument_MimeType, kn) {
					currentKey = ffj_t_InlineQueryResultDocument_MimeType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_InlineQueryResultDocument_URL, kn) {
					currentKey = ffj_t_InlineQueryResultDocument_URL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InlineQueryResultDocument_Caption, kn) {
					currentKey = ffj_t_InlineQueryResultDocument_Caption
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InlineQueryResultDocument_Title, kn) {
					currentKey = ffj_t_InlineQueryResultDocument_Title
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InlineQueryResultDocument_ID, kn) {
					currentKey = ffj_t_InlineQueryResultDocument_ID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InlineQueryResultDocument_Type, kn) {
					currentKey = ffj_t_InlineQueryResultDocument_Type
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_InlineQueryResultDocumentno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_InlineQueryResultDocument_Type:
					goto handle_Type

				case ffj_t_InlineQueryResultDocument_ID:
					goto handle_ID

				case ffj_t_InlineQueryResultDocument_Title:
					goto handle_Title

				case ffj_t_InlineQueryResultDocument_Caption:
					goto handle_Caption

				case ffj_t_InlineQueryResultDocument_URL:
					goto handle_URL

				case ffj_t_InlineQueryResultDocument_MimeType:
					goto handle_MimeType

				case ffj_t_InlineQueryResultDocument_Description:
					goto handle_Description

				case ffj_t_InlineQueryResultDocument_ReplyMarkup:
					goto handle_ReplyMarkup

				case ffj_t_InlineQueryResultDocument_InputMessageContent:
					goto handle_InputMessageContent

				case ffj_t_InlineQueryResultDocument_ThumbURL:
					goto handle_ThumbURL

				case ffj_t_InlineQueryResultDocument_ThumbWidth:
					goto handle_ThumbWidth

				case ffj_t_InlineQueryResultDocument_ThumbHeight:
					goto handle_ThumbHeight

				case ffj_t_InlineQueryResultDocumentno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: uj.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: uj.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: uj.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Caption:

	/* handler: uj.Caption type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Caption = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_URL:

	/* handler: uj.URL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.URL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MimeType:

	/* handler: uj.MimeType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.MimeType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Description:

	/* handler: uj.Description type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Description = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: uj.ReplyMarkup type=tgbotapi.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.ReplyMarkup = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.ReplyMarkup == nil {
			uj.ReplyMarkup = new(InlineKeyboardMarkup)
		}

		err = uj.ReplyMarkup.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InputMessageContent:

	/* handler: uj.InputMessageContent type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.InputMessageContent)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ThumbURL:

	/* handler: uj.ThumbURL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ThumbURL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ThumbWidth:

	/* handler: uj.ThumbWidth type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.ThumbWidth = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ThumbHeight:

	/* handler: uj.ThumbHeight type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.ThumbHeight = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *InlineQueryResultGIF) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *InlineQueryResultGIF) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "type":`)
	fflib.WriteJsonString(buf, string(mj.Type))
	buf.WriteString(`,"id":`)
	fflib.WriteJsonString(buf, string(mj.ID))
	buf.WriteString(`,"gif_url":`)
	fflib.WriteJsonString(buf, string(mj.URL))
	buf.WriteByte(',')
	if mj.Width != 0 {
		buf.WriteString(`"gif_width":`)
		fflib.FormatBits2(buf, uint64(mj.Width), 10, mj.Width < 0)
		buf.WriteByte(',')
	}
	if mj.Height != 0 {
		buf.WriteString(`"gif_height":`)
		fflib.FormatBits2(buf, uint64(mj.Height), 10, mj.Height < 0)
		buf.WriteByte(',')
	}
	if len(mj.ThumbURL) != 0 {
		buf.WriteString(`"thumb_url":`)
		fflib.WriteJsonString(buf, string(mj.ThumbURL))
		buf.WriteByte(',')
	}
	if len(mj.Title) != 0 {
		buf.WriteString(`"title":`)
		fflib.WriteJsonString(buf, string(mj.Title))
		buf.WriteByte(',')
	}
	if len(mj.Caption) != 0 {
		buf.WriteString(`"caption":`)
		fflib.WriteJsonString(buf, string(mj.Caption))
		buf.WriteByte(',')
	}
	if mj.ReplyMarkup != nil {
		if true {
			buf.WriteString(`"reply_markup":`)

			{

				err = mj.ReplyMarkup.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.InputMessageContent != nil {
		buf.WriteString(`"input_message_content":`)
		/* Interface types must use runtime reflection. type=interface {} kind=interface */
		err = buf.Encode(mj.InputMessageContent)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_InlineQueryResultGIFbase = iota
	ffj_t_InlineQueryResultGIFno_such_key

	ffj_t_InlineQueryResultGIF_Type

	ffj_t_InlineQueryResultGIF_ID

	ffj_t_InlineQueryResultGIF_URL

	ffj_t_InlineQueryResultGIF_Width

	ffj_t_InlineQueryResultGIF_Height

	ffj_t_InlineQueryResultGIF_ThumbURL

	ffj_t_InlineQueryResultGIF_Title

	ffj_t_InlineQueryResultGIF_Caption

	ffj_t_InlineQueryResultGIF_ReplyMarkup

	ffj_t_InlineQueryResultGIF_InputMessageContent
)

var ffj_key_InlineQueryResultGIF_Type = []byte("type")

var ffj_key_InlineQueryResultGIF_ID = []byte("id")

var ffj_key_InlineQueryResultGIF_URL = []byte("gif_url")

var ffj_key_InlineQueryResultGIF_Width = []byte("gif_width")

var ffj_key_InlineQueryResultGIF_Height = []byte("gif_height")

var ffj_key_InlineQueryResultGIF_ThumbURL = []byte("thumb_url")

var ffj_key_InlineQueryResultGIF_Title = []byte("title")

var ffj_key_InlineQueryResultGIF_Caption = []byte("caption")

var ffj_key_InlineQueryResultGIF_ReplyMarkup = []byte("reply_markup")

var ffj_key_InlineQueryResultGIF_InputMessageContent = []byte("input_message_content")

func (uj *InlineQueryResultGIF) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *InlineQueryResultGIF) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_InlineQueryResultGIFbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_InlineQueryResultGIFno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_InlineQueryResultGIF_Caption, kn) {
						currentKey = ffj_t_InlineQueryResultGIF_Caption
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffj_key_InlineQueryResultGIF_URL, kn) {
						currentKey = ffj_t_InlineQueryResultGIF_URL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InlineQueryResultGIF_Width, kn) {
						currentKey = ffj_t_InlineQueryResultGIF_Width
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InlineQueryResultGIF_Height, kn) {
						currentKey = ffj_t_InlineQueryResultGIF_Height
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_InlineQueryResultGIF_ID, kn) {
						currentKey = ffj_t_InlineQueryResultGIF_ID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InlineQueryResultGIF_InputMessageContent, kn) {
						currentKey = ffj_t_InlineQueryResultGIF_InputMessageContent
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_InlineQueryResultGIF_ReplyMarkup, kn) {
						currentKey = ffj_t_InlineQueryResultGIF_ReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_InlineQueryResultGIF_Type, kn) {
						currentKey = ffj_t_InlineQueryResultGIF_Type
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InlineQueryResultGIF_ThumbURL, kn) {
						currentKey = ffj_t_InlineQueryResultGIF_ThumbURL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InlineQueryResultGIF_Title, kn) {
						currentKey = ffj_t_InlineQueryResultGIF_Title
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_InlineQueryResultGIF_InputMessageContent, kn) {
					currentKey = ffj_t_InlineQueryResultGIF_InputMessageContent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_InlineQueryResultGIF_ReplyMarkup, kn) {
					currentKey = ffj_t_InlineQueryResultGIF_ReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InlineQueryResultGIF_Caption, kn) {
					currentKey = ffj_t_InlineQueryResultGIF_Caption
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InlineQueryResultGIF_Title, kn) {
					currentKey = ffj_t_InlineQueryResultGIF_Title
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_InlineQueryResultGIF_ThumbURL, kn) {
					currentKey = ffj_t_InlineQueryResultGIF_ThumbURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_InlineQueryResultGIF_Height, kn) {
					currentKey = ffj_t_InlineQueryResultGIF_Height
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_InlineQueryResultGIF_Width, kn) {
					currentKey = ffj_t_InlineQueryResultGIF_Width
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_InlineQueryResultGIF_URL, kn) {
					currentKey = ffj_t_InlineQueryResultGIF_URL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InlineQueryResultGIF_ID, kn) {
					currentKey = ffj_t_InlineQueryResultGIF_ID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InlineQueryResultGIF_Type, kn) {
					currentKey = ffj_t_InlineQueryResultGIF_Type
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_InlineQueryResultGIFno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_InlineQueryResultGIF_Type:
					goto handle_Type

				case ffj_t_InlineQueryResultGIF_ID:
					goto handle_ID

				case ffj_t_InlineQueryResultGIF_URL:
					goto handle_URL

				case ffj_t_InlineQueryResultGIF_Width:
					goto handle_Width

				case ffj_t_InlineQueryResultGIF_Height:
					goto handle_Height

				case ffj_t_InlineQueryResultGIF_ThumbURL:
					goto handle_ThumbURL

				case ffj_t_InlineQueryResultGIF_Title:
					goto handle_Title

				case ffj_t_InlineQueryResultGIF_Caption:
					goto handle_Caption

				case ffj_t_InlineQueryResultGIF_ReplyMarkup:
					goto handle_ReplyMarkup

				case ffj_t_InlineQueryResultGIF_InputMessageContent:
					goto handle_InputMessageContent

				case ffj_t_InlineQueryResultGIFno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: uj.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: uj.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_URL:

	/* handler: uj.URL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.URL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Width:

	/* handler: uj.Width type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Width = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Height:

	/* handler: uj.Height type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Height = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ThumbURL:

	/* handler: uj.ThumbURL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ThumbURL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: uj.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Caption:

	/* handler: uj.Caption type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Caption = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: uj.ReplyMarkup type=tgbotapi.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.ReplyMarkup = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.ReplyMarkup == nil {
			uj.ReplyMarkup = new(InlineKeyboardMarkup)
		}

		err = uj.ReplyMarkup.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InputMessageContent:

	/* handler: uj.InputMessageContent type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.InputMessageContent)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *InlineQueryResultLocation) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *InlineQueryResultLocation) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"type":`)
	fflib.WriteJsonString(buf, string(mj.Type))
	buf.WriteString(`,"id":`)
	fflib.WriteJsonString(buf, string(mj.ID))
	buf.WriteString(`,"latitude":`)
	fflib.AppendFloat(buf, float64(mj.Latitude), 'g', -1, 64)
	buf.WriteString(`,"longitude":`)
	fflib.AppendFloat(buf, float64(mj.Longitude), 'g', -1, 64)
	buf.WriteString(`,"title":`)
	fflib.WriteJsonString(buf, string(mj.Title))
	buf.WriteByte(',')
	if mj.ReplyMarkup != nil {
		if true {
			buf.WriteString(`"reply_markup":`)

			{

				err = mj.ReplyMarkup.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.InputMessageContent != nil {
		buf.WriteString(`"input_message_content":`)
		/* Interface types must use runtime reflection. type=interface {} kind=interface */
		err = buf.Encode(mj.InputMessageContent)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	buf.WriteString(`"thumb_url":`)
	fflib.WriteJsonString(buf, string(mj.ThumbURL))
	buf.WriteString(`,"thumb_width":`)
	fflib.FormatBits2(buf, uint64(mj.ThumbWidth), 10, mj.ThumbWidth < 0)
	buf.WriteString(`,"thumb_height":`)
	fflib.FormatBits2(buf, uint64(mj.ThumbHeight), 10, mj.ThumbHeight < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_InlineQueryResultLocationbase = iota
	ffj_t_InlineQueryResultLocationno_such_key

	ffj_t_InlineQueryResultLocation_Type

	ffj_t_InlineQueryResultLocation_ID

	ffj_t_InlineQueryResultLocation_Latitude

	ffj_t_InlineQueryResultLocation_Longitude

	ffj_t_InlineQueryResultLocation_Title

	ffj_t_InlineQueryResultLocation_ReplyMarkup

	ffj_t_InlineQueryResultLocation_InputMessageContent

	ffj_t_InlineQueryResultLocation_ThumbURL

	ffj_t_InlineQueryResultLocation_ThumbWidth

	ffj_t_InlineQueryResultLocation_ThumbHeight
)

var ffj_key_InlineQueryResultLocation_Type = []byte("type")

var ffj_key_InlineQueryResultLocation_ID = []byte("id")

var ffj_key_InlineQueryResultLocation_Latitude = []byte("latitude")

var ffj_key_InlineQueryResultLocation_Longitude = []byte("longitude")

var ffj_key_InlineQueryResultLocation_Title = []byte("title")

var ffj_key_InlineQueryResultLocation_ReplyMarkup = []byte("reply_markup")

var ffj_key_InlineQueryResultLocation_InputMessageContent = []byte("input_message_content")

var ffj_key_InlineQueryResultLocation_ThumbURL = []byte("thumb_url")

var ffj_key_InlineQueryResultLocation_ThumbWidth = []byte("thumb_width")

var ffj_key_InlineQueryResultLocation_ThumbHeight = []byte("thumb_height")

func (uj *InlineQueryResultLocation) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *InlineQueryResultLocation) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_InlineQueryResultLocationbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_InlineQueryResultLocationno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'i':

					if bytes.Equal(ffj_key_InlineQueryResultLocation_ID, kn) {
						currentKey = ffj_t_InlineQueryResultLocation_ID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InlineQueryResultLocation_InputMessageContent, kn) {
						currentKey = ffj_t_InlineQueryResultLocation_InputMessageContent
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_InlineQueryResultLocation_Latitude, kn) {
						currentKey = ffj_t_InlineQueryResultLocation_Latitude
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InlineQueryResultLocation_Longitude, kn) {
						currentKey = ffj_t_InlineQueryResultLocation_Longitude
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_InlineQueryResultLocation_ReplyMarkup, kn) {
						currentKey = ffj_t_InlineQueryResultLocation_ReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_InlineQueryResultLocation_Type, kn) {
						currentKey = ffj_t_InlineQueryResultLocation_Type
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InlineQueryResultLocation_Title, kn) {
						currentKey = ffj_t_InlineQueryResultLocation_Title
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InlineQueryResultLocation_ThumbURL, kn) {
						currentKey = ffj_t_InlineQueryResultLocation_ThumbURL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InlineQueryResultLocation_ThumbWidth, kn) {
						currentKey = ffj_t_InlineQueryResultLocation_ThumbWidth
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InlineQueryResultLocation_ThumbHeight, kn) {
						currentKey = ffj_t_InlineQueryResultLocation_ThumbHeight
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_InlineQueryResultLocation_ThumbHeight, kn) {
					currentKey = ffj_t_InlineQueryResultLocation_ThumbHeight
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_InlineQueryResultLocation_ThumbWidth, kn) {
					currentKey = ffj_t_InlineQueryResultLocation_ThumbWidth
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_InlineQueryResultLocation_ThumbURL, kn) {
					currentKey = ffj_t_InlineQueryResultLocation_ThumbURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_InlineQueryResultLocation_InputMessageContent, kn) {
					currentKey = ffj_t_InlineQueryResultLocation_InputMessageContent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_InlineQueryResultLocation_ReplyMarkup, kn) {
					currentKey = ffj_t_InlineQueryResultLocation_ReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InlineQueryResultLocation_Title, kn) {
					currentKey = ffj_t_InlineQueryResultLocation_Title
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InlineQueryResultLocation_Longitude, kn) {
					currentKey = ffj_t_InlineQueryResultLocation_Longitude
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InlineQueryResultLocation_Latitude, kn) {
					currentKey = ffj_t_InlineQueryResultLocation_Latitude
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InlineQueryResultLocation_ID, kn) {
					currentKey = ffj_t_InlineQueryResultLocation_ID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InlineQueryResultLocation_Type, kn) {
					currentKey = ffj_t_InlineQueryResultLocation_Type
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_InlineQueryResultLocationno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_InlineQueryResultLocation_Type:
					goto handle_Type

				case ffj_t_InlineQueryResultLocation_ID:
					goto handle_ID

				case ffj_t_InlineQueryResultLocation_Latitude:
					goto handle_Latitude

				case ffj_t_InlineQueryResultLocation_Longitude:
					goto handle_Longitude

				case ffj_t_InlineQueryResultLocation_Title:
					goto handle_Title

				case ffj_t_InlineQueryResultLocation_ReplyMarkup:
					goto handle_ReplyMarkup

				case ffj_t_InlineQueryResultLocation_InputMessageContent:
					goto handle_InputMessageContent

				case ffj_t_InlineQueryResultLocation_ThumbURL:
					goto handle_ThumbURL

				case ffj_t_InlineQueryResultLocation_ThumbWidth:
					goto handle_ThumbWidth

				case ffj_t_InlineQueryResultLocation_ThumbHeight:
					goto handle_ThumbHeight

				case ffj_t_InlineQueryResultLocationno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: uj.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: uj.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Latitude:

	/* handler: uj.Latitude type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Latitude = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Longitude:

	/* handler: uj.Longitude type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Longitude = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: uj.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: uj.ReplyMarkup type=tgbotapi.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.ReplyMarkup = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.ReplyMarkup == nil {
			uj.ReplyMarkup = new(InlineKeyboardMarkup)
		}

		err = uj.ReplyMarkup.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InputMessageContent:

	/* handler: uj.InputMessageContent type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.InputMessageContent)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ThumbURL:

	/* handler: uj.ThumbURL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ThumbURL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ThumbWidth:

	/* handler: uj.ThumbWidth type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.ThumbWidth = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ThumbHeight:

	/* handler: uj.ThumbHeight type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.ThumbHeight = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *InlineQueryResultMPEG4GIF) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *InlineQueryResultMPEG4GIF) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "type":`)
	fflib.WriteJsonString(buf, string(mj.Type))
	buf.WriteString(`,"id":`)
	fflib.WriteJsonString(buf, string(mj.ID))
	buf.WriteString(`,"mpeg4_url":`)
	fflib.WriteJsonString(buf, string(mj.URL))
	buf.WriteString(`,"mpeg4_width":`)
	fflib.FormatBits2(buf, uint64(mj.Width), 10, mj.Width < 0)
	buf.WriteString(`,"mpeg4_height":`)
	fflib.FormatBits2(buf, uint64(mj.Height), 10, mj.Height < 0)
	buf.WriteString(`,"thumb_url":`)
	fflib.WriteJsonString(buf, string(mj.ThumbURL))
	buf.WriteString(`,"title":`)
	fflib.WriteJsonString(buf, string(mj.Title))
	buf.WriteString(`,"caption":`)
	fflib.WriteJsonString(buf, string(mj.Caption))
	buf.WriteByte(',')
	if mj.ReplyMarkup != nil {
		if true {
			buf.WriteString(`"reply_markup":`)

			{

				err = mj.ReplyMarkup.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.InputMessageContent != nil {
		buf.WriteString(`"input_message_content":`)
		/* Interface types must use runtime reflection. type=interface {} kind=interface */
		err = buf.Encode(mj.InputMessageContent)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_InlineQueryResultMPEG4GIFbase = iota
	ffj_t_InlineQueryResultMPEG4GIFno_such_key

	ffj_t_InlineQueryResultMPEG4GIF_Type

	ffj_t_InlineQueryResultMPEG4GIF_ID

	ffj_t_InlineQueryResultMPEG4GIF_URL

	ffj_t_InlineQueryResultMPEG4GIF_Width

	ffj_t_InlineQueryResultMPEG4GIF_Height

	ffj_t_InlineQueryResultMPEG4GIF_ThumbURL

	ffj_t_InlineQueryResultMPEG4GIF_Title

	ffj_t_InlineQueryResultMPEG4GIF_Caption

	ffj_t_InlineQueryResultMPEG4GIF_ReplyMarkup

	ffj_t_InlineQueryResultMPEG4GIF_InputMessageContent
)

var ffj_key_InlineQueryResultMPEG4GIF_Type = []byte("type")

var ffj_key_InlineQueryResultMPEG4GIF_ID = []byte("id")

var ffj_key_InlineQueryResultMPEG4GIF_URL = []byte("mpeg4_url")

var ffj_key_InlineQueryResultMPEG4GIF_Width = []byte("mpeg4_width")

var ffj_key_InlineQueryResultMPEG4GIF_Height = []byte("mpeg4_height")

var ffj_key_InlineQueryResultMPEG4GIF_ThumbURL = []byte("thumb_url")

var ffj_key_InlineQueryResultMPEG4GIF_Title = []byte("title")

var ffj_key_InlineQueryResultMPEG4GIF_Caption = []byte("caption")

var ffj_key_InlineQueryResultMPEG4GIF_ReplyMarkup = []byte("reply_markup")

var ffj_key_InlineQueryResultMPEG4GIF_InputMessageContent = []byte("input_message_content")

func (uj *InlineQueryResultMPEG4GIF) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *InlineQueryResultMPEG4GIF) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_InlineQueryResultMPEG4GIFbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_InlineQueryResultMPEG4GIFno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_InlineQueryResultMPEG4GIF_Caption, kn) {
						currentKey = ffj_t_InlineQueryResultMPEG4GIF_Caption
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_InlineQueryResultMPEG4GIF_ID, kn) {
						currentKey = ffj_t_InlineQueryResultMPEG4GIF_ID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InlineQueryResultMPEG4GIF_InputMessageContent, kn) {
						currentKey = ffj_t_InlineQueryResultMPEG4GIF_InputMessageContent
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_InlineQueryResultMPEG4GIF_URL, kn) {
						currentKey = ffj_t_InlineQueryResultMPEG4GIF_URL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InlineQueryResultMPEG4GIF_Width, kn) {
						currentKey = ffj_t_InlineQueryResultMPEG4GIF_Width
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InlineQueryResultMPEG4GIF_Height, kn) {
						currentKey = ffj_t_InlineQueryResultMPEG4GIF_Height
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_InlineQueryResultMPEG4GIF_ReplyMarkup, kn) {
						currentKey = ffj_t_InlineQueryResultMPEG4GIF_ReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_InlineQueryResultMPEG4GIF_Type, kn) {
						currentKey = ffj_t_InlineQueryResultMPEG4GIF_Type
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InlineQueryResultMPEG4GIF_ThumbURL, kn) {
						currentKey = ffj_t_InlineQueryResultMPEG4GIF_ThumbURL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InlineQueryResultMPEG4GIF_Title, kn) {
						currentKey = ffj_t_InlineQueryResultMPEG4GIF_Title
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_InlineQueryResultMPEG4GIF_InputMessageContent, kn) {
					currentKey = ffj_t_InlineQueryResultMPEG4GIF_InputMessageContent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_InlineQueryResultMPEG4GIF_ReplyMarkup, kn) {
					currentKey = ffj_t_InlineQueryResultMPEG4GIF_ReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InlineQueryResultMPEG4GIF_Caption, kn) {
					currentKey = ffj_t_InlineQueryResultMPEG4GIF_Caption
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InlineQueryResultMPEG4GIF_Title, kn) {
					currentKey = ffj_t_InlineQueryResultMPEG4GIF_Title
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_InlineQueryResultMPEG4GIF_ThumbURL, kn) {
					currentKey = ffj_t_InlineQueryResultMPEG4GIF_ThumbURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_InlineQueryResultMPEG4GIF_Height, kn) {
					currentKey = ffj_t_InlineQueryResultMPEG4GIF_Height
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_InlineQueryResultMPEG4GIF_Width, kn) {
					currentKey = ffj_t_InlineQueryResultMPEG4GIF_Width
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_InlineQueryResultMPEG4GIF_URL, kn) {
					currentKey = ffj_t_InlineQueryResultMPEG4GIF_URL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InlineQueryResultMPEG4GIF_ID, kn) {
					currentKey = ffj_t_InlineQueryResultMPEG4GIF_ID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InlineQueryResultMPEG4GIF_Type, kn) {
					currentKey = ffj_t_InlineQueryResultMPEG4GIF_Type
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_InlineQueryResultMPEG4GIFno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_InlineQueryResultMPEG4GIF_Type:
					goto handle_Type

				case ffj_t_InlineQueryResultMPEG4GIF_ID:
					goto handle_ID

				case ffj_t_InlineQueryResultMPEG4GIF_URL:
					goto handle_URL

				case ffj_t_InlineQueryResultMPEG4GIF_Width:
					goto handle_Width

				case ffj_t_InlineQueryResultMPEG4GIF_Height:
					goto handle_Height

				case ffj_t_InlineQueryResultMPEG4GIF_ThumbURL:
					goto handle_ThumbURL

				case ffj_t_InlineQueryResultMPEG4GIF_Title:
					goto handle_Title

				case ffj_t_InlineQueryResultMPEG4GIF_Caption:
					goto handle_Caption

				case ffj_t_InlineQueryResultMPEG4GIF_ReplyMarkup:
					goto handle_ReplyMarkup

				case ffj_t_InlineQueryResultMPEG4GIF_InputMessageContent:
					goto handle_InputMessageContent

				case ffj_t_InlineQueryResultMPEG4GIFno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: uj.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: uj.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_URL:

	/* handler: uj.URL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.URL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Width:

	/* handler: uj.Width type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Width = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Height:

	/* handler: uj.Height type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Height = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ThumbURL:

	/* handler: uj.ThumbURL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ThumbURL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: uj.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Caption:

	/* handler: uj.Caption type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Caption = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: uj.ReplyMarkup type=tgbotapi.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.ReplyMarkup = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.ReplyMarkup == nil {
			uj.ReplyMarkup = new(InlineKeyboardMarkup)
		}

		err = uj.ReplyMarkup.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InputMessageContent:

	/* handler: uj.InputMessageContent type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.InputMessageContent)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *InlineQueryResultPhoto) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *InlineQueryResultPhoto) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "type":`)
	fflib.WriteJsonString(buf, string(mj.Type))
	buf.WriteString(`,"id":`)
	fflib.WriteJsonString(buf, string(mj.ID))
	buf.WriteString(`,"photo_url":`)
	fflib.WriteJsonString(buf, string(mj.URL))
	buf.WriteByte(',')
	if len(mj.MimeType) != 0 {
		buf.WriteString(`"mime_type":`)
		fflib.WriteJsonString(buf, string(mj.MimeType))
		buf.WriteByte(',')
	}
	if mj.Width != 0 {
		buf.WriteString(`"photo_width":`)
		fflib.FormatBits2(buf, uint64(mj.Width), 10, mj.Width < 0)
		buf.WriteByte(',')
	}
	if mj.Height != 0 {
		buf.WriteString(`"photo_height":`)
		fflib.FormatBits2(buf, uint64(mj.Height), 10, mj.Height < 0)
		buf.WriteByte(',')
	}
	if len(mj.ThumbURL) != 0 {
		buf.WriteString(`"thumb_url":`)
		fflib.WriteJsonString(buf, string(mj.ThumbURL))
		buf.WriteByte(',')
	}
	if len(mj.Title) != 0 {
		buf.WriteString(`"title":`)
		fflib.WriteJsonString(buf, string(mj.Title))
		buf.WriteByte(',')
	}
	if len(mj.Description) != 0 {
		buf.WriteString(`"description":`)
		fflib.WriteJsonString(buf, string(mj.Description))
		buf.WriteByte(',')
	}
	if len(mj.Caption) != 0 {
		buf.WriteString(`"caption":`)
		fflib.WriteJsonString(buf, string(mj.Caption))
		buf.WriteByte(',')
	}
	if mj.ReplyMarkup != nil {
		if true {
			buf.WriteString(`"reply_markup":`)

			{

				err = mj.ReplyMarkup.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.InputMessageContent != nil {
		buf.WriteString(`"input_message_content":`)
		/* Interface types must use runtime reflection. type=interface {} kind=interface */
		err = buf.Encode(mj.InputMessageContent)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_InlineQueryResultPhotobase = iota
	ffj_t_InlineQueryResultPhotono_such_key

	ffj_t_InlineQueryResultPhoto_Type

	ffj_t_InlineQueryResultPhoto_ID

	ffj_t_InlineQueryResultPhoto_URL

	ffj_t_InlineQueryResultPhoto_MimeType

	ffj_t_InlineQueryResultPhoto_Width

	ffj_t_InlineQueryResultPhoto_Height

	ffj_t_InlineQueryResultPhoto_ThumbURL

	ffj_t_InlineQueryResultPhoto_Title

	ffj_t_InlineQueryResultPhoto_Description

	ffj_t_InlineQueryResultPhoto_Caption

	ffj_t_InlineQueryResultPhoto_ReplyMarkup

	ffj_t_InlineQueryResultPhoto_InputMessageContent
)

var ffj_key_InlineQueryResultPhoto_Type = []byte("type")

var ffj_key_InlineQueryResultPhoto_ID = []byte("id")

var ffj_key_InlineQueryResultPhoto_URL = []byte("photo_url")

var ffj_key_InlineQueryResultPhoto_MimeType = []byte("mime_type")

var ffj_key_InlineQueryResultPhoto_Width = []byte("photo_width")

var ffj_key_InlineQueryResultPhoto_Height = []byte("photo_height")

var ffj_key_InlineQueryResultPhoto_ThumbURL = []byte("thumb_url")

var ffj_key_InlineQueryResultPhoto_Title = []byte("title")

var ffj_key_InlineQueryResultPhoto_Description = []byte("description")

var ffj_key_InlineQueryResultPhoto_Caption = []byte("caption")

var ffj_key_InlineQueryResultPhoto_ReplyMarkup = []byte("reply_markup")

var ffj_key_InlineQueryResultPhoto_InputMessageContent = []byte("input_message_content")

func (uj *InlineQueryResultPhoto) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *InlineQueryResultPhoto) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_InlineQueryResultPhotobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_InlineQueryResultPhotono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_InlineQueryResultPhoto_Caption, kn) {
						currentKey = ffj_t_InlineQueryResultPhoto_Caption
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_InlineQueryResultPhoto_Description, kn) {
						currentKey = ffj_t_InlineQueryResultPhoto_Description
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_InlineQueryResultPhoto_ID, kn) {
						currentKey = ffj_t_InlineQueryResultPhoto_ID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InlineQueryResultPhoto_InputMessageContent, kn) {
						currentKey = ffj_t_InlineQueryResultPhoto_InputMessageContent
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_InlineQueryResultPhoto_MimeType, kn) {
						currentKey = ffj_t_InlineQueryResultPhoto_MimeType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_InlineQueryResultPhoto_URL, kn) {
						currentKey = ffj_t_InlineQueryResultPhoto_URL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InlineQueryResultPhoto_Width, kn) {
						currentKey = ffj_t_InlineQueryResultPhoto_Width
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InlineQueryResultPhoto_Height, kn) {
						currentKey = ffj_t_InlineQueryResultPhoto_Height
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_InlineQueryResultPhoto_ReplyMarkup, kn) {
						currentKey = ffj_t_InlineQueryResultPhoto_ReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_InlineQueryResultPhoto_Type, kn) {
						currentKey = ffj_t_InlineQueryResultPhoto_Type
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InlineQueryResultPhoto_ThumbURL, kn) {
						currentKey = ffj_t_InlineQueryResultPhoto_ThumbURL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InlineQueryResultPhoto_Title, kn) {
						currentKey = ffj_t_InlineQueryResultPhoto_Title
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_InlineQueryResultPhoto_InputMessageContent, kn) {
					currentKey = ffj_t_InlineQueryResultPhoto_InputMessageContent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_InlineQueryResultPhoto_ReplyMarkup, kn) {
					currentKey = ffj_t_InlineQueryResultPhoto_ReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InlineQueryResultPhoto_Caption, kn) {
					currentKey = ffj_t_InlineQueryResultPhoto_Caption
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_InlineQueryResultPhoto_Description, kn) {
					currentKey = ffj_t_InlineQueryResultPhoto_Description
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InlineQueryResultPhoto_Title, kn) {
					currentKey = ffj_t_InlineQueryResultPhoto_Title
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_InlineQueryResultPhoto_ThumbURL, kn) {
					currentKey = ffj_t_InlineQueryResultPhoto_ThumbURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_InlineQueryResultPhoto_Height, kn) {
					currentKey = ffj_t_InlineQueryResultPhoto_Height
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_InlineQueryResultPhoto_Width, kn) {
					currentKey = ffj_t_InlineQueryResultPhoto_Width
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_InlineQueryResultPhoto_MimeType, kn) {
					currentKey = ffj_t_InlineQueryResultPhoto_MimeType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_InlineQueryResultPhoto_URL, kn) {
					currentKey = ffj_t_InlineQueryResultPhoto_URL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InlineQueryResultPhoto_ID, kn) {
					currentKey = ffj_t_InlineQueryResultPhoto_ID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InlineQueryResultPhoto_Type, kn) {
					currentKey = ffj_t_InlineQueryResultPhoto_Type
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_InlineQueryResultPhotono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_InlineQueryResultPhoto_Type:
					goto handle_Type

				case ffj_t_InlineQueryResultPhoto_ID:
					goto handle_ID

				case ffj_t_InlineQueryResultPhoto_URL:
					goto handle_URL

				case ffj_t_InlineQueryResultPhoto_MimeType:
					goto handle_MimeType

				case ffj_t_InlineQueryResultPhoto_Width:
					goto handle_Width

				case ffj_t_InlineQueryResultPhoto_Height:
					goto handle_Height

				case ffj_t_InlineQueryResultPhoto_ThumbURL:
					goto handle_ThumbURL

				case ffj_t_InlineQueryResultPhoto_Title:
					goto handle_Title

				case ffj_t_InlineQueryResultPhoto_Description:
					goto handle_Description

				case ffj_t_InlineQueryResultPhoto_Caption:
					goto handle_Caption

				case ffj_t_InlineQueryResultPhoto_ReplyMarkup:
					goto handle_ReplyMarkup

				case ffj_t_InlineQueryResultPhoto_InputMessageContent:
					goto handle_InputMessageContent

				case ffj_t_InlineQueryResultPhotono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: uj.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: uj.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_URL:

	/* handler: uj.URL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.URL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MimeType:

	/* handler: uj.MimeType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.MimeType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Width:

	/* handler: uj.Width type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Width = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Height:

	/* handler: uj.Height type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Height = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ThumbURL:

	/* handler: uj.ThumbURL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ThumbURL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: uj.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Description:

	/* handler: uj.Description type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Description = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Caption:

	/* handler: uj.Caption type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Caption = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: uj.ReplyMarkup type=tgbotapi.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.ReplyMarkup = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.ReplyMarkup == nil {
			uj.ReplyMarkup = new(InlineKeyboardMarkup)
		}

		err = uj.ReplyMarkup.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InputMessageContent:

	/* handler: uj.InputMessageContent type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.InputMessageContent)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *InlineQueryResultVideo) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *InlineQueryResultVideo) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "type":`)
	fflib.WriteJsonString(buf, string(mj.Type))
	buf.WriteString(`,"id":`)
	fflib.WriteJsonString(buf, string(mj.ID))
	buf.WriteString(`,"video_url":`)
	fflib.WriteJsonString(buf, string(mj.URL))
	buf.WriteString(`,"mime_type":`)
	fflib.WriteJsonString(buf, string(mj.MimeType))
	buf.WriteString(`,"thumb_url":`)
	fflib.WriteJsonString(buf, string(mj.ThumbURL))
	buf.WriteString(`,"title":`)
	fflib.WriteJsonString(buf, string(mj.Title))
	buf.WriteString(`,"caption":`)
	fflib.WriteJsonString(buf, string(mj.Caption))
	buf.WriteString(`,"video_width":`)
	fflib.FormatBits2(buf, uint64(mj.Width), 10, mj.Width < 0)
	buf.WriteString(`,"video_height":`)
	fflib.FormatBits2(buf, uint64(mj.Height), 10, mj.Height < 0)
	buf.WriteString(`,"video_duration":`)
	fflib.FormatBits2(buf, uint64(mj.Duration), 10, mj.Duration < 0)
	buf.WriteString(`,"description":`)
	fflib.WriteJsonString(buf, string(mj.Description))
	buf.WriteByte(',')
	if mj.ReplyMarkup != nil {
		if true {
			buf.WriteString(`"reply_markup":`)

			{

				err = mj.ReplyMarkup.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.InputMessageContent != nil {
		buf.WriteString(`"input_message_content":`)
		/* Interface types must use runtime reflection. type=interface {} kind=interface */
		err = buf.Encode(mj.InputMessageContent)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_InlineQueryResultVideobase = iota
	ffj_t_InlineQueryResultVideono_such_key

	ffj_t_InlineQueryResultVideo_Type

	ffj_t_InlineQueryResultVideo_ID

	ffj_t_InlineQueryResultVideo_URL

	ffj_t_InlineQueryResultVideo_MimeType

	ffj_t_InlineQueryResultVideo_ThumbURL

	ffj_t_InlineQueryResultVideo_Title

	ffj_t_InlineQueryResultVideo_Caption

	ffj_t_InlineQueryResultVideo_Width

	ffj_t_InlineQueryResultVideo_Height

	ffj_t_InlineQueryResultVideo_Duration

	ffj_t_InlineQueryResultVideo_Description

	ffj_t_InlineQueryResultVideo_ReplyMarkup

	ffj_t_InlineQueryResultVideo_InputMessageContent
)

var ffj_key_InlineQueryResultVideo_Type = []byte("type")

var ffj_key_InlineQueryResultVideo_ID = []byte("id")

var ffj_key_InlineQueryResultVideo_URL = []byte("video_url")

var ffj_key_InlineQueryResultVideo_MimeType = []byte("mime_type")

var ffj_key_InlineQueryResultVideo_ThumbURL = []byte("thumb_url")

var ffj_key_InlineQueryResultVideo_Title = []byte("title")

var ffj_key_InlineQueryResultVideo_Caption = []byte("caption")

var ffj_key_InlineQueryResultVideo_Width = []byte("video_width")

var ffj_key_InlineQueryResultVideo_Height = []byte("video_height")

var ffj_key_InlineQueryResultVideo_Duration = []byte("video_duration")

var ffj_key_InlineQueryResultVideo_Description = []byte("description")

var ffj_key_InlineQueryResultVideo_ReplyMarkup = []byte("reply_markup")

var ffj_key_InlineQueryResultVideo_InputMessageContent = []byte("input_message_content")

func (uj *InlineQueryResultVideo) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *InlineQueryResultVideo) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_InlineQueryResultVideobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_InlineQueryResultVideono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_InlineQueryResultVideo_Caption, kn) {
						currentKey = ffj_t_InlineQueryResultVideo_Caption
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_InlineQueryResultVideo_Description, kn) {
						currentKey = ffj_t_InlineQueryResultVideo_Description
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_InlineQueryResultVideo_ID, kn) {
						currentKey = ffj_t_InlineQueryResultVideo_ID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InlineQueryResultVideo_InputMessageContent, kn) {
						currentKey = ffj_t_InlineQueryResultVideo_InputMessageContent
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_InlineQueryResultVideo_MimeType, kn) {
						currentKey = ffj_t_InlineQueryResultVideo_MimeType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_InlineQueryResultVideo_ReplyMarkup, kn) {
						currentKey = ffj_t_InlineQueryResultVideo_ReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_InlineQueryResultVideo_Type, kn) {
						currentKey = ffj_t_InlineQueryResultVideo_Type
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InlineQueryResultVideo_ThumbURL, kn) {
						currentKey = ffj_t_InlineQueryResultVideo_ThumbURL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InlineQueryResultVideo_Title, kn) {
						currentKey = ffj_t_InlineQueryResultVideo_Title
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffj_key_InlineQueryResultVideo_URL, kn) {
						currentKey = ffj_t_InlineQueryResultVideo_URL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InlineQueryResultVideo_Width, kn) {
						currentKey = ffj_t_InlineQueryResultVideo_Width
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InlineQueryResultVideo_Height, kn) {
						currentKey = ffj_t_InlineQueryResultVideo_Height
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InlineQueryResultVideo_Duration, kn) {
						currentKey = ffj_t_InlineQueryResultVideo_Duration
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_InlineQueryResultVideo_InputMessageContent, kn) {
					currentKey = ffj_t_InlineQueryResultVideo_InputMessageContent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_InlineQueryResultVideo_ReplyMarkup, kn) {
					currentKey = ffj_t_InlineQueryResultVideo_ReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_InlineQueryResultVideo_Description, kn) {
					currentKey = ffj_t_InlineQueryResultVideo_Description
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_InlineQueryResultVideo_Duration, kn) {
					currentKey = ffj_t_InlineQueryResultVideo_Duration
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_InlineQueryResultVideo_Height, kn) {
					currentKey = ffj_t_InlineQueryResultVideo_Height
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_InlineQueryResultVideo_Width, kn) {
					currentKey = ffj_t_InlineQueryResultVideo_Width
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InlineQueryResultVideo_Caption, kn) {
					currentKey = ffj_t_InlineQueryResultVideo_Caption
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InlineQueryResultVideo_Title, kn) {
					currentKey = ffj_t_InlineQueryResultVideo_Title
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_InlineQueryResultVideo_ThumbURL, kn) {
					currentKey = ffj_t_InlineQueryResultVideo_ThumbURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_InlineQueryResultVideo_MimeType, kn) {
					currentKey = ffj_t_InlineQueryResultVideo_MimeType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_InlineQueryResultVideo_URL, kn) {
					currentKey = ffj_t_InlineQueryResultVideo_URL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InlineQueryResultVideo_ID, kn) {
					currentKey = ffj_t_InlineQueryResultVideo_ID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InlineQueryResultVideo_Type, kn) {
					currentKey = ffj_t_InlineQueryResultVideo_Type
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_InlineQueryResultVideono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_InlineQueryResultVideo_Type:
					goto handle_Type

				case ffj_t_InlineQueryResultVideo_ID:
					goto handle_ID

				case ffj_t_InlineQueryResultVideo_URL:
					goto handle_URL

				case ffj_t_InlineQueryResultVideo_MimeType:
					goto handle_MimeType

				case ffj_t_InlineQueryResultVideo_ThumbURL:
					goto handle_ThumbURL

				case ffj_t_InlineQueryResultVideo_Title:
					goto handle_Title

				case ffj_t_InlineQueryResultVideo_Caption:
					goto handle_Caption

				case ffj_t_InlineQueryResultVideo_Width:
					goto handle_Width

				case ffj_t_InlineQueryResultVideo_Height:
					goto handle_Height

				case ffj_t_InlineQueryResultVideo_Duration:
					goto handle_Duration

				case ffj_t_InlineQueryResultVideo_Description:
					goto handle_Description

				case ffj_t_InlineQueryResultVideo_ReplyMarkup:
					goto handle_ReplyMarkup

				case ffj_t_InlineQueryResultVideo_InputMessageContent:
					goto handle_InputMessageContent

				case ffj_t_InlineQueryResultVideono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: uj.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: uj.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_URL:

	/* handler: uj.URL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.URL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MimeType:

	/* handler: uj.MimeType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.MimeType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ThumbURL:

	/* handler: uj.ThumbURL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ThumbURL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: uj.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Caption:

	/* handler: uj.Caption type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Caption = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Width:

	/* handler: uj.Width type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Width = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Height:

	/* handler: uj.Height type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Height = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Duration:

	/* handler: uj.Duration type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Duration = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Description:

	/* handler: uj.Description type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Description = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: uj.ReplyMarkup type=tgbotapi.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.ReplyMarkup = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.ReplyMarkup == nil {
			uj.ReplyMarkup = new(InlineKeyboardMarkup)
		}

		err = uj.ReplyMarkup.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InputMessageContent:

	/* handler: uj.InputMessageContent type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.InputMessageContent)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *InlineQueryResultVoice) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *InlineQueryResultVoice) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "type":`)
	fflib.WriteJsonString(buf, string(mj.Type))
	buf.WriteString(`,"id":`)
	fflib.WriteJsonString(buf, string(mj.ID))
	buf.WriteString(`,"voice_url":`)
	fflib.WriteJsonString(buf, string(mj.URL))
	buf.WriteString(`,"title":`)
	fflib.WriteJsonString(buf, string(mj.Title))
	buf.WriteString(`,"voice_duration":`)
	fflib.FormatBits2(buf, uint64(mj.Duration), 10, mj.Duration < 0)
	buf.WriteByte(',')
	if mj.ReplyMarkup != nil {
		if true {
			buf.WriteString(`"reply_markup":`)

			{

				err = mj.ReplyMarkup.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.InputMessageContent != nil {
		buf.WriteString(`"input_message_content":`)
		/* Interface types must use runtime reflection. type=interface {} kind=interface */
		err = buf.Encode(mj.InputMessageContent)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_InlineQueryResultVoicebase = iota
	ffj_t_InlineQueryResultVoiceno_such_key

	ffj_t_InlineQueryResultVoice_Type

	ffj_t_InlineQueryResultVoice_ID

	ffj_t_InlineQueryResultVoice_URL

	ffj_t_InlineQueryResultVoice_Title

	ffj_t_InlineQueryResultVoice_Duration

	ffj_t_InlineQueryResultVoice_ReplyMarkup

	ffj_t_InlineQueryResultVoice_InputMessageContent
)

var ffj_key_InlineQueryResultVoice_Type = []byte("type")

var ffj_key_InlineQueryResultVoice_ID = []byte("id")

var ffj_key_InlineQueryResultVoice_URL = []byte("voice_url")

var ffj_key_InlineQueryResultVoice_Title = []byte("title")

var ffj_key_InlineQueryResultVoice_Duration = []byte("voice_duration")

var ffj_key_InlineQueryResultVoice_ReplyMarkup = []byte("reply_markup")

var ffj_key_InlineQueryResultVoice_InputMessageContent = []byte("input_message_content")

func (uj *InlineQueryResultVoice) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *InlineQueryResultVoice) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_InlineQueryResultVoicebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_InlineQueryResultVoiceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'i':

					if bytes.Equal(ffj_key_InlineQueryResultVoice_ID, kn) {
						currentKey = ffj_t_InlineQueryResultVoice_ID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InlineQueryResultVoice_InputMessageContent, kn) {
						currentKey = ffj_t_InlineQueryResultVoice_InputMessageContent
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_InlineQueryResultVoice_ReplyMarkup, kn) {
						currentKey = ffj_t_InlineQueryResultVoice_ReplyMarkup
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_InlineQueryResultVoice_Type, kn) {
						currentKey = ffj_t_InlineQueryResultVoice_Type
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InlineQueryResultVoice_Title, kn) {
						currentKey = ffj_t_InlineQueryResultVoice_Title
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffj_key_InlineQueryResultVoice_URL, kn) {
						currentKey = ffj_t_InlineQueryResultVoice_URL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InlineQueryResultVoice_Duration, kn) {
						currentKey = ffj_t_InlineQueryResultVoice_Duration
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_InlineQueryResultVoice_InputMessageContent, kn) {
					currentKey = ffj_t_InlineQueryResultVoice_InputMessageContent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_InlineQueryResultVoice_ReplyMarkup, kn) {
					currentKey = ffj_t_InlineQueryResultVoice_ReplyMarkup
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_InlineQueryResultVoice_Duration, kn) {
					currentKey = ffj_t_InlineQueryResultVoice_Duration
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InlineQueryResultVoice_Title, kn) {
					currentKey = ffj_t_InlineQueryResultVoice_Title
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_InlineQueryResultVoice_URL, kn) {
					currentKey = ffj_t_InlineQueryResultVoice_URL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InlineQueryResultVoice_ID, kn) {
					currentKey = ffj_t_InlineQueryResultVoice_ID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InlineQueryResultVoice_Type, kn) {
					currentKey = ffj_t_InlineQueryResultVoice_Type
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_InlineQueryResultVoiceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_InlineQueryResultVoice_Type:
					goto handle_Type

				case ffj_t_InlineQueryResultVoice_ID:
					goto handle_ID

				case ffj_t_InlineQueryResultVoice_URL:
					goto handle_URL

				case ffj_t_InlineQueryResultVoice_Title:
					goto handle_Title

				case ffj_t_InlineQueryResultVoice_Duration:
					goto handle_Duration

				case ffj_t_InlineQueryResultVoice_ReplyMarkup:
					goto handle_ReplyMarkup

				case ffj_t_InlineQueryResultVoice_InputMessageContent:
					goto handle_InputMessageContent

				case ffj_t_InlineQueryResultVoiceno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: uj.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: uj.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_URL:

	/* handler: uj.URL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.URL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: uj.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Duration:

	/* handler: uj.Duration type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Duration = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyMarkup:

	/* handler: uj.ReplyMarkup type=tgbotapi.InlineKeyboardMarkup kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.ReplyMarkup = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.ReplyMarkup == nil {
			uj.ReplyMarkup = new(InlineKeyboardMarkup)
		}

		err = uj.ReplyMarkup.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InputMessageContent:

	/* handler: uj.InputMessageContent type=interface {} kind=interface quoted=false*/

	{
		/* Falling back. type=interface {} kind=interface */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.InputMessageContent)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *InputContactMessageContent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *InputContactMessageContent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"phone_number":`)
	fflib.WriteJsonString(buf, string(mj.PhoneNumber))
	buf.WriteString(`,"first_name":`)
	fflib.WriteJsonString(buf, string(mj.FirstName))
	buf.WriteString(`,"last_name":`)
	fflib.WriteJsonString(buf, string(mj.LastName))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_InputContactMessageContentbase = iota
	ffj_t_InputContactMessageContentno_such_key

	ffj_t_InputContactMessageContent_PhoneNumber

	ffj_t_InputContactMessageContent_FirstName

	ffj_t_InputContactMessageContent_LastName
)

var ffj_key_InputContactMessageContent_PhoneNumber = []byte("phone_number")

var ffj_key_InputContactMessageContent_FirstName = []byte("first_name")

var ffj_key_InputContactMessageContent_LastName = []byte("last_name")

func (uj *InputContactMessageContent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *InputContactMessageContent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_InputContactMessageContentbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_InputContactMessageContentno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffj_key_InputContactMessageContent_FirstName, kn) {
						currentKey = ffj_t_InputContactMessageContent_FirstName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_InputContactMessageContent_LastName, kn) {
						currentKey = ffj_t_InputContactMessageContent_LastName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_InputContactMessageContent_PhoneNumber, kn) {
						currentKey = ffj_t_InputContactMessageContent_PhoneNumber
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_InputContactMessageContent_LastName, kn) {
					currentKey = ffj_t_InputContactMessageContent_LastName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_InputContactMessageContent_FirstName, kn) {
					currentKey = ffj_t_InputContactMessageContent_FirstName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_InputContactMessageContent_PhoneNumber, kn) {
					currentKey = ffj_t_InputContactMessageContent_PhoneNumber
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_InputContactMessageContentno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_InputContactMessageContent_PhoneNumber:
					goto handle_PhoneNumber

				case ffj_t_InputContactMessageContent_FirstName:
					goto handle_FirstName

				case ffj_t_InputContactMessageContent_LastName:
					goto handle_LastName

				case ffj_t_InputContactMessageContentno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_PhoneNumber:

	/* handler: uj.PhoneNumber type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.PhoneNumber = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FirstName:

	/* handler: uj.FirstName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.FirstName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LastName:

	/* handler: uj.LastName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.LastName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *InputLocationMessageContent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *InputLocationMessageContent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"latitude":`)
	fflib.AppendFloat(buf, float64(mj.Latitude), 'g', -1, 64)
	buf.WriteString(`,"longitude":`)
	fflib.AppendFloat(buf, float64(mj.Longitude), 'g', -1, 64)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_InputLocationMessageContentbase = iota
	ffj_t_InputLocationMessageContentno_such_key

	ffj_t_InputLocationMessageContent_Latitude

	ffj_t_InputLocationMessageContent_Longitude
)

var ffj_key_InputLocationMessageContent_Latitude = []byte("latitude")

var ffj_key_InputLocationMessageContent_Longitude = []byte("longitude")

func (uj *InputLocationMessageContent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *InputLocationMessageContent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_InputLocationMessageContentbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_InputLocationMessageContentno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'l':

					if bytes.Equal(ffj_key_InputLocationMessageContent_Latitude, kn) {
						currentKey = ffj_t_InputLocationMessageContent_Latitude
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InputLocationMessageContent_Longitude, kn) {
						currentKey = ffj_t_InputLocationMessageContent_Longitude
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_InputLocationMessageContent_Longitude, kn) {
					currentKey = ffj_t_InputLocationMessageContent_Longitude
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InputLocationMessageContent_Latitude, kn) {
					currentKey = ffj_t_InputLocationMessageContent_Latitude
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_InputLocationMessageContentno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_InputLocationMessageContent_Latitude:
					goto handle_Latitude

				case ffj_t_InputLocationMessageContent_Longitude:
					goto handle_Longitude

				case ffj_t_InputLocationMessageContentno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Latitude:

	/* handler: uj.Latitude type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Latitude = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Longitude:

	/* handler: uj.Longitude type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Longitude = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *InputTextMessageContent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *InputTextMessageContent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"message_text":`)
	fflib.WriteJsonString(buf, string(mj.Text))
	buf.WriteString(`,"parse_mode":`)
	fflib.WriteJsonString(buf, string(mj.ParseMode))
	if mj.DisableWebPagePreview {
		buf.WriteString(`,"disable_web_page_preview":true`)
	} else {
		buf.WriteString(`,"disable_web_page_preview":false`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_InputTextMessageContentbase = iota
	ffj_t_InputTextMessageContentno_such_key

	ffj_t_InputTextMessageContent_Text

	ffj_t_InputTextMessageContent_ParseMode

	ffj_t_InputTextMessageContent_DisableWebPagePreview
)

var ffj_key_InputTextMessageContent_Text = []byte("message_text")

var ffj_key_InputTextMessageContent_ParseMode = []byte("parse_mode")

var ffj_key_InputTextMessageContent_DisableWebPagePreview = []byte("disable_web_page_preview")

func (uj *InputTextMessageContent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *InputTextMessageContent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_InputTextMessageContentbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_InputTextMessageContentno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffj_key_InputTextMessageContent_DisableWebPagePreview, kn) {
						currentKey = ffj_t_InputTextMessageContent_DisableWebPagePreview
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_InputTextMessageContent_Text, kn) {
						currentKey = ffj_t_InputTextMessageContent_Text
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_InputTextMessageContent_ParseMode, kn) {
						currentKey = ffj_t_InputTextMessageContent_ParseMode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_InputTextMessageContent_DisableWebPagePreview, kn) {
					currentKey = ffj_t_InputTextMessageContent_DisableWebPagePreview
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_InputTextMessageContent_ParseMode, kn) {
					currentKey = ffj_t_InputTextMessageContent_ParseMode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_InputTextMessageContent_Text, kn) {
					currentKey = ffj_t_InputTextMessageContent_Text
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_InputTextMessageContentno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_InputTextMessageContent_Text:
					goto handle_Text

				case ffj_t_InputTextMessageContent_ParseMode:
					goto handle_ParseMode

				case ffj_t_InputTextMessageContent_DisableWebPagePreview:
					goto handle_DisableWebPagePreview

				case ffj_t_InputTextMessageContentno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Text:

	/* handler: uj.Text type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Text = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ParseMode:

	/* handler: uj.ParseMode type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.ParseMode = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DisableWebPagePreview:

	/* handler: uj.DisableWebPagePreview type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.DisableWebPagePreview = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.DisableWebPagePreview = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *InputVenueMessageContent) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *InputVenueMessageContent) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"latitude":`)
	fflib.AppendFloat(buf, float64(mj.Latitude), 'g', -1, 64)
	buf.WriteString(`,"longitude":`)
	fflib.AppendFloat(buf, float64(mj.Longitude), 'g', -1, 64)
	buf.WriteString(`,"title":`)
	fflib.WriteJsonString(buf, string(mj.Title))
	buf.WriteString(`,"address":`)
	fflib.WriteJsonString(buf, string(mj.Address))
	buf.WriteString(`,"foursquare_id":`)
	fflib.WriteJsonString(buf, string(mj.FoursquareID))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_InputVenueMessageContentbase = iota
	ffj_t_InputVenueMessageContentno_such_key

	ffj_t_InputVenueMessageContent_Latitude

	ffj_t_InputVenueMessageContent_Longitude

	ffj_t_InputVenueMessageContent_Title

	ffj_t_InputVenueMessageContent_Address

	ffj_t_InputVenueMessageContent_FoursquareID
)

var ffj_key_InputVenueMessageContent_Latitude = []byte("latitude")

var ffj_key_InputVenueMessageContent_Longitude = []byte("longitude")

var ffj_key_InputVenueMessageContent_Title = []byte("title")

var ffj_key_InputVenueMessageContent_Address = []byte("address")

var ffj_key_InputVenueMessageContent_FoursquareID = []byte("foursquare_id")

func (uj *InputVenueMessageContent) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *InputVenueMessageContent) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_InputVenueMessageContentbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_InputVenueMessageContentno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_InputVenueMessageContent_Address, kn) {
						currentKey = ffj_t_InputVenueMessageContent_Address
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffj_key_InputVenueMessageContent_FoursquareID, kn) {
						currentKey = ffj_t_InputVenueMessageContent_FoursquareID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_InputVenueMessageContent_Latitude, kn) {
						currentKey = ffj_t_InputVenueMessageContent_Latitude
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_InputVenueMessageContent_Longitude, kn) {
						currentKey = ffj_t_InputVenueMessageContent_Longitude
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_InputVenueMessageContent_Title, kn) {
						currentKey = ffj_t_InputVenueMessageContent_Title
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_InputVenueMessageContent_FoursquareID, kn) {
					currentKey = ffj_t_InputVenueMessageContent_FoursquareID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_InputVenueMessageContent_Address, kn) {
					currentKey = ffj_t_InputVenueMessageContent_Address
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InputVenueMessageContent_Title, kn) {
					currentKey = ffj_t_InputVenueMessageContent_Title
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InputVenueMessageContent_Longitude, kn) {
					currentKey = ffj_t_InputVenueMessageContent_Longitude
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_InputVenueMessageContent_Latitude, kn) {
					currentKey = ffj_t_InputVenueMessageContent_Latitude
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_InputVenueMessageContentno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_InputVenueMessageContent_Latitude:
					goto handle_Latitude

				case ffj_t_InputVenueMessageContent_Longitude:
					goto handle_Longitude

				case ffj_t_InputVenueMessageContent_Title:
					goto handle_Title

				case ffj_t_InputVenueMessageContent_Address:
					goto handle_Address

				case ffj_t_InputVenueMessageContent_FoursquareID:
					goto handle_FoursquareID

				case ffj_t_InputVenueMessageContentno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Latitude:

	/* handler: uj.Latitude type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Latitude = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Longitude:

	/* handler: uj.Longitude type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Longitude = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: uj.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Address:

	/* handler: uj.Address type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Address = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FoursquareID:

	/* handler: uj.FoursquareID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.FoursquareID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *KeyboardButton) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *KeyboardButton) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"text":`)
	fflib.WriteJsonString(buf, string(mj.Text))
	if mj.RequestContact {
		buf.WriteString(`,"request_contact":true`)
	} else {
		buf.WriteString(`,"request_contact":false`)
	}
	if mj.RequestLocation {
		buf.WriteString(`,"request_location":true`)
	} else {
		buf.WriteString(`,"request_location":false`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_KeyboardButtonbase = iota
	ffj_t_KeyboardButtonno_such_key

	ffj_t_KeyboardButton_Text

	ffj_t_KeyboardButton_RequestContact

	ffj_t_KeyboardButton_RequestLocation
)

var ffj_key_KeyboardButton_Text = []byte("text")

var ffj_key_KeyboardButton_RequestContact = []byte("request_contact")

var ffj_key_KeyboardButton_RequestLocation = []byte("request_location")

func (uj *KeyboardButton) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *KeyboardButton) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_KeyboardButtonbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_KeyboardButtonno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'r':

					if bytes.Equal(ffj_key_KeyboardButton_RequestContact, kn) {
						currentKey = ffj_t_KeyboardButton_RequestContact
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_KeyboardButton_RequestLocation, kn) {
						currentKey = ffj_t_KeyboardButton_RequestLocation
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_KeyboardButton_Text, kn) {
						currentKey = ffj_t_KeyboardButton_Text
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_KeyboardButton_RequestLocation, kn) {
					currentKey = ffj_t_KeyboardButton_RequestLocation
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_KeyboardButton_RequestContact, kn) {
					currentKey = ffj_t_KeyboardButton_RequestContact
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_KeyboardButton_Text, kn) {
					currentKey = ffj_t_KeyboardButton_Text
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_KeyboardButtonno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_KeyboardButton_Text:
					goto handle_Text

				case ffj_t_KeyboardButton_RequestContact:
					goto handle_RequestContact

				case ffj_t_KeyboardButton_RequestLocation:
					goto handle_RequestLocation

				case ffj_t_KeyboardButtonno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Text:

	/* handler: uj.Text type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Text = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RequestContact:

	/* handler: uj.RequestContact type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.RequestContact = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.RequestContact = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RequestLocation:

	/* handler: uj.RequestLocation type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.RequestLocation = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.RequestLocation = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Location) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Location) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"longitude":`)
	fflib.AppendFloat(buf, float64(mj.Longitude), 'g', -1, 64)
	buf.WriteString(`,"latitude":`)
	fflib.AppendFloat(buf, float64(mj.Latitude), 'g', -1, 64)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Locationbase = iota
	ffj_t_Locationno_such_key

	ffj_t_Location_Longitude

	ffj_t_Location_Latitude
)

var ffj_key_Location_Longitude = []byte("longitude")

var ffj_key_Location_Latitude = []byte("latitude")

func (uj *Location) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Location) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Locationbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Locationno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'l':

					if bytes.Equal(ffj_key_Location_Longitude, kn) {
						currentKey = ffj_t_Location_Longitude
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Location_Latitude, kn) {
						currentKey = ffj_t_Location_Latitude
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_Location_Latitude, kn) {
					currentKey = ffj_t_Location_Latitude
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Location_Longitude, kn) {
					currentKey = ffj_t_Location_Longitude
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Locationno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Location_Longitude:
					goto handle_Longitude

				case ffj_t_Location_Latitude:
					goto handle_Latitude

				case ffj_t_Locationno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Longitude:

	/* handler: uj.Longitude type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Longitude = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Latitude:

	/* handler: uj.Latitude type=float64 kind=float64 quoted=false*/

	{
		if tok != fflib.FFTok_double && tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for float64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseFloat(fs.Output.Bytes(), 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Latitude = float64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Message) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Message) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "message_id":`)
	fflib.FormatBits2(buf, uint64(mj.MessageID), 10, mj.MessageID < 0)
	if mj.From != nil {
		buf.WriteString(`,"from":`)

		{

			err = mj.From.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"from":null`)
	}
	buf.WriteString(`,"date":`)
	fflib.FormatBits2(buf, uint64(mj.Date), 10, mj.Date < 0)
	if mj.Chat != nil {
		buf.WriteString(`,"chat":`)

		{

			err = mj.Chat.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"chat":null`)
	}
	buf.WriteByte(',')
	if mj.ForwardFrom != nil {
		if true {
			buf.WriteString(`"forward_from":`)

			{

				err = mj.ForwardFrom.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.ForwardDate != 0 {
		buf.WriteString(`"forward_date":`)
		fflib.FormatBits2(buf, uint64(mj.ForwardDate), 10, mj.ForwardDate < 0)
		buf.WriteByte(',')
	}
	if mj.ReplyToMessage != nil {
		if true {
			buf.WriteString(`"reply_to_message":`)

			{

				err = mj.ReplyToMessage.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(mj.Text) != 0 {
		buf.WriteString(`"text":`)
		fflib.WriteJsonString(buf, string(mj.Text))
		buf.WriteByte(',')
	}
	if mj.Entities != nil {
		if true {
			buf.WriteString(`"entities":`)
			if mj.Entities != nil {
				buf.WriteString(`[`)
				for i, v := range *mj.Entities {
					if i != 0 {
						buf.WriteString(`,`)
					}

					{

						err = v.MarshalJSONBuf(buf)
						if err != nil {
							return err
						}

					}
				}
				buf.WriteString(`]`)
			} else {
				buf.WriteString(`null`)
			}
			buf.WriteByte(',')
		}
	}
	if mj.Audio != nil {
		if true {
			buf.WriteString(`"audio":`)

			{

				err = mj.Audio.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Document != nil {
		if true {
			buf.WriteString(`"document":`)

			{

				err = mj.Document.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Photo != nil {
		if true {
			buf.WriteString(`"photo":`)
			if mj.Photo != nil {
				buf.WriteString(`[`)
				for i, v := range *mj.Photo {
					if i != 0 {
						buf.WriteString(`,`)
					}

					{

						err = v.MarshalJSONBuf(buf)
						if err != nil {
							return err
						}

					}
				}
				buf.WriteString(`]`)
			} else {
				buf.WriteString(`null`)
			}
			buf.WriteByte(',')
		}
	}
	if mj.Sticker != nil {
		if true {
			buf.WriteString(`"sticker":`)

			{

				err = mj.Sticker.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Video != nil {
		if true {
			buf.WriteString(`"video":`)

			{

				err = mj.Video.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Voice != nil {
		if true {
			buf.WriteString(`"voice":`)

			{

				err = mj.Voice.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(mj.Caption) != 0 {
		buf.WriteString(`"caption":`)
		fflib.WriteJsonString(buf, string(mj.Caption))
		buf.WriteByte(',')
	}
	if mj.Contact != nil {
		if true {
			buf.WriteString(`"contact":`)

			{

				err = mj.Contact.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Location != nil {
		if true {
			buf.WriteString(`"location":`)

			{

				err = mj.Location.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.Venue != nil {
		if true {
			buf.WriteString(`"venue":`)

			{

				err = mj.Venue.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.NewChatMember != nil {
		if true {
			buf.WriteString(`"new_chat_member":`)

			{

				err = mj.NewChatMember.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(mj.NewChatMembers) != 0 {
		buf.WriteString(`"new_chat_members":`)
		if mj.NewChatMembers != nil {
			buf.WriteString(`[`)
			for i, v := range mj.NewChatMembers {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					if v == nil {
						buf.WriteString("null")
						return nil
					}

					err = v.MarshalJSONBuf(buf)
					if err != nil {
						return err
					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if mj.LeftChatMember != nil {
		if true {
			buf.WriteString(`"left_chat_member":`)

			{

				err = mj.LeftChatMember.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(mj.NewChatTitle) != 0 {
		buf.WriteString(`"new_chat_title":`)
		fflib.WriteJsonString(buf, string(mj.NewChatTitle))
		buf.WriteByte(',')
	}
	if mj.NewChatPhoto != nil {
		if true {
			buf.WriteString(`"new_chat_photo":`)
			if mj.NewChatPhoto != nil {
				buf.WriteString(`[`)
				for i, v := range *mj.NewChatPhoto {
					if i != 0 {
						buf.WriteString(`,`)
					}

					{

						err = v.MarshalJSONBuf(buf)
						if err != nil {
							return err
						}

					}
				}
				buf.WriteString(`]`)
			} else {
				buf.WriteString(`null`)
			}
			buf.WriteByte(',')
		}
	}
	if mj.DeleteChatPhoto != false {
		if mj.DeleteChatPhoto {
			buf.WriteString(`"delete_chat_photo":true`)
		} else {
			buf.WriteString(`"delete_chat_photo":false`)
		}
		buf.WriteByte(',')
	}
	if mj.GroupChatCreated != false {
		if mj.GroupChatCreated {
			buf.WriteString(`"group_chat_created":true`)
		} else {
			buf.WriteString(`"group_chat_created":false`)
		}
		buf.WriteByte(',')
	}
	if mj.SuperGroupChatCreated != false {
		if mj.SuperGroupChatCreated {
			buf.WriteString(`"supergroup_chat_created":true`)
		} else {
			buf.WriteString(`"supergroup_chat_created":false`)
		}
		buf.WriteByte(',')
	}
	if mj.ChannelChatCreated != false {
		if mj.ChannelChatCreated {
			buf.WriteString(`"channel_chat_created":true`)
		} else {
			buf.WriteString(`"channel_chat_created":false`)
		}
		buf.WriteByte(',')
	}
	if mj.MigrateToChatID != 0 {
		buf.WriteString(`"migrate_to_chat_id":`)
		fflib.FormatBits2(buf, uint64(mj.MigrateToChatID), 10, mj.MigrateToChatID < 0)
		buf.WriteByte(',')
	}
	if mj.MigrateFromChatID != 0 {
		buf.WriteString(`"migrate_from_chat_id":`)
		fflib.FormatBits2(buf, uint64(mj.MigrateFromChatID), 10, mj.MigrateFromChatID < 0)
		buf.WriteByte(',')
	}
	if mj.PinnedMessage != nil {
		if true {
			buf.WriteString(`"pinned_message":`)

			{

				err = mj.PinnedMessage.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Messagebase = iota
	ffj_t_Messageno_such_key

	ffj_t_Message_MessageID

	ffj_t_Message_From

	ffj_t_Message_Date

	ffj_t_Message_Chat

	ffj_t_Message_ForwardFrom

	ffj_t_Message_ForwardDate

	ffj_t_Message_ReplyToMessage

	ffj_t_Message_Text

	ffj_t_Message_Entities

	ffj_t_Message_Audio

	ffj_t_Message_Document

	ffj_t_Message_Photo

	ffj_t_Message_Sticker

	ffj_t_Message_Video

	ffj_t_Message_Voice

	ffj_t_Message_Caption

	ffj_t_Message_Contact

	ffj_t_Message_Location

	ffj_t_Message_Venue

	ffj_t_Message_NewChatMember

	ffj_t_Message_NewChatMembers

	ffj_t_Message_LeftChatMember

	ffj_t_Message_NewChatTitle

	ffj_t_Message_NewChatPhoto

	ffj_t_Message_DeleteChatPhoto

	ffj_t_Message_GroupChatCreated

	ffj_t_Message_SuperGroupChatCreated

	ffj_t_Message_ChannelChatCreated

	ffj_t_Message_MigrateToChatID

	ffj_t_Message_MigrateFromChatID

	ffj_t_Message_PinnedMessage
)

var ffj_key_Message_MessageID = []byte("message_id")

var ffj_key_Message_From = []byte("from")

var ffj_key_Message_Date = []byte("date")

var ffj_key_Message_Chat = []byte("chat")

var ffj_key_Message_ForwardFrom = []byte("forward_from")

var ffj_key_Message_ForwardDate = []byte("forward_date")

var ffj_key_Message_ReplyToMessage = []byte("reply_to_message")

var ffj_key_Message_Text = []byte("text")

var ffj_key_Message_Entities = []byte("entities")

var ffj_key_Message_Audio = []byte("audio")

var ffj_key_Message_Document = []byte("document")

var ffj_key_Message_Photo = []byte("photo")

var ffj_key_Message_Sticker = []byte("sticker")

var ffj_key_Message_Video = []byte("video")

var ffj_key_Message_Voice = []byte("voice")

var ffj_key_Message_Caption = []byte("caption")

var ffj_key_Message_Contact = []byte("contact")

var ffj_key_Message_Location = []byte("location")

var ffj_key_Message_Venue = []byte("venue")

var ffj_key_Message_NewChatMember = []byte("new_chat_member")

var ffj_key_Message_NewChatMembers = []byte("new_chat_members")

var ffj_key_Message_LeftChatMember = []byte("left_chat_member")

var ffj_key_Message_NewChatTitle = []byte("new_chat_title")

var ffj_key_Message_NewChatPhoto = []byte("new_chat_photo")

var ffj_key_Message_DeleteChatPhoto = []byte("delete_chat_photo")

var ffj_key_Message_GroupChatCreated = []byte("group_chat_created")

var ffj_key_Message_SuperGroupChatCreated = []byte("supergroup_chat_created")

var ffj_key_Message_ChannelChatCreated = []byte("channel_chat_created")

var ffj_key_Message_MigrateToChatID = []byte("migrate_to_chat_id")

var ffj_key_Message_MigrateFromChatID = []byte("migrate_from_chat_id")

var ffj_key_Message_PinnedMessage = []byte("pinned_message")

func (uj *Message) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Message) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Messagebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Messageno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_Message_Audio, kn) {
						currentKey = ffj_t_Message_Audio
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_Message_Chat, kn) {
						currentKey = ffj_t_Message_Chat
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Message_Caption, kn) {
						currentKey = ffj_t_Message_Caption
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Message_Contact, kn) {
						currentKey = ffj_t_Message_Contact
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Message_ChannelChatCreated, kn) {
						currentKey = ffj_t_Message_ChannelChatCreated
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_Message_Date, kn) {
						currentKey = ffj_t_Message_Date
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Message_Document, kn) {
						currentKey = ffj_t_Message_Document
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Message_DeleteChatPhoto, kn) {
						currentKey = ffj_t_Message_DeleteChatPhoto
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffj_key_Message_Entities, kn) {
						currentKey = ffj_t_Message_Entities
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffj_key_Message_From, kn) {
						currentKey = ffj_t_Message_From
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Message_ForwardFrom, kn) {
						currentKey = ffj_t_Message_ForwardFrom
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Message_ForwardDate, kn) {
						currentKey = ffj_t_Message_ForwardDate
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'g':

					if bytes.Equal(ffj_key_Message_GroupChatCreated, kn) {
						currentKey = ffj_t_Message_GroupChatCreated
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_Message_Location, kn) {
						currentKey = ffj_t_Message_Location
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Message_LeftChatMember, kn) {
						currentKey = ffj_t_Message_LeftChatMember
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_Message_MessageID, kn) {
						currentKey = ffj_t_Message_MessageID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Message_MigrateToChatID, kn) {
						currentKey = ffj_t_Message_MigrateToChatID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Message_MigrateFromChatID, kn) {
						currentKey = ffj_t_Message_MigrateFromChatID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffj_key_Message_NewChatMember, kn) {
						currentKey = ffj_t_Message_NewChatMember
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Message_NewChatMembers, kn) {
						currentKey = ffj_t_Message_NewChatMembers
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Message_NewChatTitle, kn) {
						currentKey = ffj_t_Message_NewChatTitle
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Message_NewChatPhoto, kn) {
						currentKey = ffj_t_Message_NewChatPhoto
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_Message_Photo, kn) {
						currentKey = ffj_t_Message_Photo
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Message_PinnedMessage, kn) {
						currentKey = ffj_t_Message_PinnedMessage
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_Message_ReplyToMessage, kn) {
						currentKey = ffj_t_Message_ReplyToMessage
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_Message_Sticker, kn) {
						currentKey = ffj_t_Message_Sticker
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Message_SuperGroupChatCreated, kn) {
						currentKey = ffj_t_Message_SuperGroupChatCreated
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_Message_Text, kn) {
						currentKey = ffj_t_Message_Text
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffj_key_Message_Video, kn) {
						currentKey = ffj_t_Message_Video
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Message_Voice, kn) {
						currentKey = ffj_t_Message_Voice
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Message_Venue, kn) {
						currentKey = ffj_t_Message_Venue
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Message_PinnedMessage, kn) {
					currentKey = ffj_t_Message_PinnedMessage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Message_MigrateFromChatID, kn) {
					currentKey = ffj_t_Message_MigrateFromChatID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Message_MigrateToChatID, kn) {
					currentKey = ffj_t_Message_MigrateToChatID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Message_ChannelChatCreated, kn) {
					currentKey = ffj_t_Message_ChannelChatCreated
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Message_SuperGroupChatCreated, kn) {
					currentKey = ffj_t_Message_SuperGroupChatCreated
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Message_GroupChatCreated, kn) {
					currentKey = ffj_t_Message_GroupChatCreated
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Message_DeleteChatPhoto, kn) {
					currentKey = ffj_t_Message_DeleteChatPhoto
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Message_NewChatPhoto, kn) {
					currentKey = ffj_t_Message_NewChatPhoto
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Message_NewChatTitle, kn) {
					currentKey = ffj_t_Message_NewChatTitle
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Message_LeftChatMember, kn) {
					currentKey = ffj_t_Message_LeftChatMember
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Message_NewChatMembers, kn) {
					currentKey = ffj_t_Message_NewChatMembers
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Message_NewChatMember, kn) {
					currentKey = ffj_t_Message_NewChatMember
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Message_Venue, kn) {
					currentKey = ffj_t_Message_Venue
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Message_Location, kn) {
					currentKey = ffj_t_Message_Location
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Message_Contact, kn) {
					currentKey = ffj_t_Message_Contact
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Message_Caption, kn) {
					currentKey = ffj_t_Message_Caption
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Message_Voice, kn) {
					currentKey = ffj_t_Message_Voice
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Message_Video, kn) {
					currentKey = ffj_t_Message_Video
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Message_Sticker, kn) {
					currentKey = ffj_t_Message_Sticker
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Message_Photo, kn) {
					currentKey = ffj_t_Message_Photo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Message_Document, kn) {
					currentKey = ffj_t_Message_Document
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Message_Audio, kn) {
					currentKey = ffj_t_Message_Audio
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Message_Entities, kn) {
					currentKey = ffj_t_Message_Entities
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Message_Text, kn) {
					currentKey = ffj_t_Message_Text
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Message_ReplyToMessage, kn) {
					currentKey = ffj_t_Message_ReplyToMessage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Message_ForwardDate, kn) {
					currentKey = ffj_t_Message_ForwardDate
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Message_ForwardFrom, kn) {
					currentKey = ffj_t_Message_ForwardFrom
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Message_Chat, kn) {
					currentKey = ffj_t_Message_Chat
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Message_Date, kn) {
					currentKey = ffj_t_Message_Date
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Message_From, kn) {
					currentKey = ffj_t_Message_From
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Message_MessageID, kn) {
					currentKey = ffj_t_Message_MessageID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Messageno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Message_MessageID:
					goto handle_MessageID

				case ffj_t_Message_From:
					goto handle_From

				case ffj_t_Message_Date:
					goto handle_Date

				case ffj_t_Message_Chat:
					goto handle_Chat

				case ffj_t_Message_ForwardFrom:
					goto handle_ForwardFrom

				case ffj_t_Message_ForwardDate:
					goto handle_ForwardDate

				case ffj_t_Message_ReplyToMessage:
					goto handle_ReplyToMessage

				case ffj_t_Message_Text:
					goto handle_Text

				case ffj_t_Message_Entities:
					goto handle_Entities

				case ffj_t_Message_Audio:
					goto handle_Audio

				case ffj_t_Message_Document:
					goto handle_Document

				case ffj_t_Message_Photo:
					goto handle_Photo

				case ffj_t_Message_Sticker:
					goto handle_Sticker

				case ffj_t_Message_Video:
					goto handle_Video

				case ffj_t_Message_Voice:
					goto handle_Voice

				case ffj_t_Message_Caption:
					goto handle_Caption

				case ffj_t_Message_Contact:
					goto handle_Contact

				case ffj_t_Message_Location:
					goto handle_Location

				case ffj_t_Message_Venue:
					goto handle_Venue

				case ffj_t_Message_NewChatMember:
					goto handle_NewChatMember

				case ffj_t_Message_NewChatMembers:
					goto handle_NewChatMembers

				case ffj_t_Message_LeftChatMember:
					goto handle_LeftChatMember

				case ffj_t_Message_NewChatTitle:
					goto handle_NewChatTitle

				case ffj_t_Message_NewChatPhoto:
					goto handle_NewChatPhoto

				case ffj_t_Message_DeleteChatPhoto:
					goto handle_DeleteChatPhoto

				case ffj_t_Message_GroupChatCreated:
					goto handle_GroupChatCreated

				case ffj_t_Message_SuperGroupChatCreated:
					goto handle_SuperGroupChatCreated

				case ffj_t_Message_ChannelChatCreated:
					goto handle_ChannelChatCreated

				case ffj_t_Message_MigrateToChatID:
					goto handle_MigrateToChatID

				case ffj_t_Message_MigrateFromChatID:
					goto handle_MigrateFromChatID

				case ffj_t_Message_PinnedMessage:
					goto handle_PinnedMessage

				case ffj_t_Messageno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_MessageID:

	/* handler: uj.MessageID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.MessageID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_From:

	/* handler: uj.From type=tgbotapi.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.From = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.From == nil {
			uj.From = new(User)
		}

		err = uj.From.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Date:

	/* handler: uj.Date type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Date = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Chat:

	/* handler: uj.Chat type=tgbotapi.Chat kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Chat = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Chat == nil {
			uj.Chat = new(Chat)
		}

		err = uj.Chat.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ForwardFrom:

	/* handler: uj.ForwardFrom type=tgbotapi.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.ForwardFrom = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.ForwardFrom == nil {
			uj.ForwardFrom = new(User)
		}

		err = uj.ForwardFrom.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ForwardDate:

	/* handler: uj.ForwardDate type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.ForwardDate = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReplyToMessage:

	/* handler: uj.ReplyToMessage type=tgbotapi.Message kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.ReplyToMessage = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.ReplyToMessage == nil {
			uj.ReplyToMessage = new(Message)
		}

		err = uj.ReplyToMessage.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Text:

	/* handler: uj.Text type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Text = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Entities:

	/* handler: uj.Entities type=[]tgbotapi.MessageEntity kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Entities = nil
		} else {

			uj.Entities = &[]MessageEntity{}

			wantVal := true

			for {

				var tmp_uj__Entities MessageEntity

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__Entities type=tgbotapi.MessageEntity kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = tmp_uj__Entities.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				*uj.Entities = append(*uj.Entities, tmp_uj__Entities)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Audio:

	/* handler: uj.Audio type=tgbotapi.Audio kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Audio = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Audio == nil {
			uj.Audio = new(Audio)
		}

		err = uj.Audio.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Document:

	/* handler: uj.Document type=tgbotapi.Document kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Document = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Document == nil {
			uj.Document = new(Document)
		}

		err = uj.Document.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Photo:

	/* handler: uj.Photo type=[]tgbotapi.PhotoSize kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Photo = nil
		} else {

			uj.Photo = &[]PhotoSize{}

			wantVal := true

			for {

				var tmp_uj__Photo PhotoSize

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__Photo type=tgbotapi.PhotoSize kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = tmp_uj__Photo.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				*uj.Photo = append(*uj.Photo, tmp_uj__Photo)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Sticker:

	/* handler: uj.Sticker type=tgbotapi.Sticker kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Sticker = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Sticker == nil {
			uj.Sticker = new(Sticker)
		}

		err = uj.Sticker.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Video:

	/* handler: uj.Video type=tgbotapi.Video kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Video = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Video == nil {
			uj.Video = new(Video)
		}

		err = uj.Video.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Voice:

	/* handler: uj.Voice type=tgbotapi.Voice kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Voice = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Voice == nil {
			uj.Voice = new(Voice)
		}

		err = uj.Voice.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Caption:

	/* handler: uj.Caption type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Caption = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Contact:

	/* handler: uj.Contact type=tgbotapi.Contact kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Contact = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Contact == nil {
			uj.Contact = new(Contact)
		}

		err = uj.Contact.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Location:

	/* handler: uj.Location type=tgbotapi.Location kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Location = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Location == nil {
			uj.Location = new(Location)
		}

		err = uj.Location.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Venue:

	/* handler: uj.Venue type=tgbotapi.Venue kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Venue = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Venue == nil {
			uj.Venue = new(Venue)
		}

		err = uj.Venue.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NewChatMember:

	/* handler: uj.NewChatMember type=tgbotapi.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.NewChatMember = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.NewChatMember == nil {
			uj.NewChatMember = new(User)
		}

		err = uj.NewChatMember.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NewChatMembers:

	/* handler: uj.NewChatMembers type=[]*tgbotapi.User kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.NewChatMembers = nil
		} else {

			uj.NewChatMembers = []*User{}

			wantVal := true

			for {

				var tmp_uj__NewChatMembers *User

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__NewChatMembers type=*tgbotapi.User kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						tmp_uj__NewChatMembers = nil

						state = fflib.FFParse_after_value
						goto mainparse
					}

					if tmp_uj__NewChatMembers == nil {
						tmp_uj__NewChatMembers = new(User)
					}

					err = tmp_uj__NewChatMembers.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.NewChatMembers = append(uj.NewChatMembers, tmp_uj__NewChatMembers)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LeftChatMember:

	/* handler: uj.LeftChatMember type=tgbotapi.User kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.LeftChatMember = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.LeftChatMember == nil {
			uj.LeftChatMember = new(User)
		}

		err = uj.LeftChatMember.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NewChatTitle:

	/* handler: uj.NewChatTitle type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.NewChatTitle = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NewChatPhoto:

	/* handler: uj.NewChatPhoto type=[]tgbotapi.PhotoSize kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.NewChatPhoto = nil
		} else {

			uj.NewChatPhoto = &[]PhotoSize{}

			wantVal := true

			for {

				var tmp_uj__NewChatPhoto PhotoSize

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__NewChatPhoto type=tgbotapi.PhotoSize kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = tmp_uj__NewChatPhoto.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				*uj.NewChatPhoto = append(*uj.NewChatPhoto, tmp_uj__NewChatPhoto)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DeleteChatPhoto:

	/* handler: uj.DeleteChatPhoto type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.DeleteChatPhoto = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.DeleteChatPhoto = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_GroupChatCreated:

	/* handler: uj.GroupChatCreated type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.GroupChatCreated = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.GroupChatCreated = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SuperGroupChatCreated:

	/* handler: uj.SuperGroupChatCreated type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.SuperGroupChatCreated = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.SuperGroupChatCreated = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChannelChatCreated:

	/* handler: uj.ChannelChatCreated type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.ChannelChatCreated = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.ChannelChatCreated = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MigrateToChatID:

	/* handler: uj.MigrateToChatID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.MigrateToChatID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MigrateFromChatID:

	/* handler: uj.MigrateFromChatID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.MigrateFromChatID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PinnedMessage:

	/* handler: uj.PinnedMessage type=tgbotapi.Message kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.PinnedMessage = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.PinnedMessage == nil {
			uj.PinnedMessage = new(Message)
		}

		err = uj.PinnedMessage.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *MessageEntity) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *MessageEntity) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "type":`)
	fflib.WriteJsonString(buf, string(mj.Type))
	buf.WriteString(`,"offset":`)
	fflib.FormatBits2(buf, uint64(mj.Offset), 10, mj.Offset < 0)
	buf.WriteString(`,"length":`)
	fflib.FormatBits2(buf, uint64(mj.Length), 10, mj.Length < 0)
	buf.WriteByte(',')
	if len(mj.URL) != 0 {
		buf.WriteString(`"url":`)
		fflib.WriteJsonString(buf, string(mj.URL))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_MessageEntitybase = iota
	ffj_t_MessageEntityno_such_key

	ffj_t_MessageEntity_Type

	ffj_t_MessageEntity_Offset

	ffj_t_MessageEntity_Length

	ffj_t_MessageEntity_URL
)

var ffj_key_MessageEntity_Type = []byte("type")

var ffj_key_MessageEntity_Offset = []byte("offset")

var ffj_key_MessageEntity_Length = []byte("length")

var ffj_key_MessageEntity_URL = []byte("url")

func (uj *MessageEntity) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *MessageEntity) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_MessageEntitybase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_MessageEntityno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'l':

					if bytes.Equal(ffj_key_MessageEntity_Length, kn) {
						currentKey = ffj_t_MessageEntity_Length
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffj_key_MessageEntity_Offset, kn) {
						currentKey = ffj_t_MessageEntity_Offset
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_MessageEntity_Type, kn) {
						currentKey = ffj_t_MessageEntity_Type
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffj_key_MessageEntity_URL, kn) {
						currentKey = ffj_t_MessageEntity_URL
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_MessageEntity_URL, kn) {
					currentKey = ffj_t_MessageEntity_URL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MessageEntity_Length, kn) {
					currentKey = ffj_t_MessageEntity_Length
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_MessageEntity_Offset, kn) {
					currentKey = ffj_t_MessageEntity_Offset
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_MessageEntity_Type, kn) {
					currentKey = ffj_t_MessageEntity_Type
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_MessageEntityno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_MessageEntity_Type:
					goto handle_Type

				case ffj_t_MessageEntity_Offset:
					goto handle_Offset

				case ffj_t_MessageEntity_Length:
					goto handle_Length

				case ffj_t_MessageEntity_URL:
					goto handle_URL

				case ffj_t_MessageEntityno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: uj.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Offset:

	/* handler: uj.Offset type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Offset = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Length:

	/* handler: uj.Length type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Length = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_URL:

	/* handler: uj.URL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.URL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *PhotoSize) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *PhotoSize) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "file_id":`)
	fflib.WriteJsonString(buf, string(mj.FileID))
	buf.WriteString(`,"width":`)
	fflib.FormatBits2(buf, uint64(mj.Width), 10, mj.Width < 0)
	buf.WriteString(`,"height":`)
	fflib.FormatBits2(buf, uint64(mj.Height), 10, mj.Height < 0)
	buf.WriteByte(',')
	if mj.FileSize != 0 {
		buf.WriteString(`"file_size":`)
		fflib.FormatBits2(buf, uint64(mj.FileSize), 10, mj.FileSize < 0)
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_PhotoSizebase = iota
	ffj_t_PhotoSizeno_such_key

	ffj_t_PhotoSize_FileID

	ffj_t_PhotoSize_Width

	ffj_t_PhotoSize_Height

	ffj_t_PhotoSize_FileSize
)

var ffj_key_PhotoSize_FileID = []byte("file_id")

var ffj_key_PhotoSize_Width = []byte("width")

var ffj_key_PhotoSize_Height = []byte("height")

var ffj_key_PhotoSize_FileSize = []byte("file_size")

func (uj *PhotoSize) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *PhotoSize) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_PhotoSizebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_PhotoSizeno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffj_key_PhotoSize_FileID, kn) {
						currentKey = ffj_t_PhotoSize_FileID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_PhotoSize_FileSize, kn) {
						currentKey = ffj_t_PhotoSize_FileSize
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffj_key_PhotoSize_Height, kn) {
						currentKey = ffj_t_PhotoSize_Height
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'w':

					if bytes.Equal(ffj_key_PhotoSize_Width, kn) {
						currentKey = ffj_t_PhotoSize_Width
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_PhotoSize_FileSize, kn) {
					currentKey = ffj_t_PhotoSize_FileSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_PhotoSize_Height, kn) {
					currentKey = ffj_t_PhotoSize_Height
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_PhotoSize_Width, kn) {
					currentKey = ffj_t_PhotoSize_Width
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_PhotoSize_FileID, kn) {
					currentKey = ffj_t_PhotoSize_FileID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_PhotoSizeno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_PhotoSize_FileID:
					goto handle_FileID

				case ffj_t_PhotoSize_Width:
					goto handle_Width

				case ffj_t_PhotoSize_Height:
					goto handle_Height

				case ffj_t_PhotoSize_FileSize:
					goto handle_FileSize

				case ffj_t_PhotoSizeno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_FileID:

	/* handler: uj.FileID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.FileID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Width:

	/* handler: uj.Width type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Width = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Height:

	/* handler: uj.Height type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Height = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileSize:

	/* handler: uj.FileSize type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.FileSize = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *ReplyKeyboardHide) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ReplyKeyboardHide) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if mj.HideKeyboard {
		buf.WriteString(`{ "hide_keyboard":true`)
	} else {
		buf.WriteString(`{ "hide_keyboard":false`)
	}
	buf.WriteByte(',')
	if mj.Selective != false {
		if mj.Selective {
			buf.WriteString(`"selective":true`)
		} else {
			buf.WriteString(`"selective":false`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ReplyKeyboardHidebase = iota
	ffj_t_ReplyKeyboardHideno_such_key

	ffj_t_ReplyKeyboardHide_HideKeyboard

	ffj_t_ReplyKeyboardHide_Selective
)

var ffj_key_ReplyKeyboardHide_HideKeyboard = []byte("hide_keyboard")

var ffj_key_ReplyKeyboardHide_Selective = []byte("selective")

func (uj *ReplyKeyboardHide) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ReplyKeyboardHide) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ReplyKeyboardHidebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ReplyKeyboardHideno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'h':

					if bytes.Equal(ffj_key_ReplyKeyboardHide_HideKeyboard, kn) {
						currentKey = ffj_t_ReplyKeyboardHide_HideKeyboard
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_ReplyKeyboardHide_Selective, kn) {
						currentKey = ffj_t_ReplyKeyboardHide_Selective
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_ReplyKeyboardHide_Selective, kn) {
					currentKey = ffj_t_ReplyKeyboardHide_Selective
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ReplyKeyboardHide_HideKeyboard, kn) {
					currentKey = ffj_t_ReplyKeyboardHide_HideKeyboard
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ReplyKeyboardHideno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ReplyKeyboardHide_HideKeyboard:
					goto handle_HideKeyboard

				case ffj_t_ReplyKeyboardHide_Selective:
					goto handle_Selective

				case ffj_t_ReplyKeyboardHideno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_HideKeyboard:

	/* handler: uj.HideKeyboard type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.HideKeyboard = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.HideKeyboard = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Selective:

	/* handler: uj.Selective type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.Selective = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.Selective = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *ReplyKeyboardMarkup) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *ReplyKeyboardMarkup) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "keyboard":`)
	if mj.Keyboard != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Keyboard {
			if i != 0 {
				buf.WriteString(`,`)
			}
			if v != nil {
				buf.WriteString(`[`)
				for i, v := range v {
					if i != 0 {
						buf.WriteString(`,`)
					}

					{

						err = v.MarshalJSONBuf(buf)
						if err != nil {
							return err
						}

					}
				}
				buf.WriteString(`]`)
			} else {
				buf.WriteString(`null`)
			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte(',')
	if mj.ResizeKeyboard != false {
		if mj.ResizeKeyboard {
			buf.WriteString(`"resize_keyboard":true`)
		} else {
			buf.WriteString(`"resize_keyboard":false`)
		}
		buf.WriteByte(',')
	}
	if mj.OneTimeKeyboard != false {
		if mj.OneTimeKeyboard {
			buf.WriteString(`"one_time_keyboard":true`)
		} else {
			buf.WriteString(`"one_time_keyboard":false`)
		}
		buf.WriteByte(',')
	}
	if mj.Selective != false {
		if mj.Selective {
			buf.WriteString(`"selective":true`)
		} else {
			buf.WriteString(`"selective":false`)
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_ReplyKeyboardMarkupbase = iota
	ffj_t_ReplyKeyboardMarkupno_such_key

	ffj_t_ReplyKeyboardMarkup_Keyboard

	ffj_t_ReplyKeyboardMarkup_ResizeKeyboard

	ffj_t_ReplyKeyboardMarkup_OneTimeKeyboard

	ffj_t_ReplyKeyboardMarkup_Selective
)

var ffj_key_ReplyKeyboardMarkup_Keyboard = []byte("keyboard")

var ffj_key_ReplyKeyboardMarkup_ResizeKeyboard = []byte("resize_keyboard")

var ffj_key_ReplyKeyboardMarkup_OneTimeKeyboard = []byte("one_time_keyboard")

var ffj_key_ReplyKeyboardMarkup_Selective = []byte("selective")

func (uj *ReplyKeyboardMarkup) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *ReplyKeyboardMarkup) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_ReplyKeyboardMarkupbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_ReplyKeyboardMarkupno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'k':

					if bytes.Equal(ffj_key_ReplyKeyboardMarkup_Keyboard, kn) {
						currentKey = ffj_t_ReplyKeyboardMarkup_Keyboard
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffj_key_ReplyKeyboardMarkup_OneTimeKeyboard, kn) {
						currentKey = ffj_t_ReplyKeyboardMarkup_OneTimeKeyboard
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffj_key_ReplyKeyboardMarkup_ResizeKeyboard, kn) {
						currentKey = ffj_t_ReplyKeyboardMarkup_ResizeKeyboard
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffj_key_ReplyKeyboardMarkup_Selective, kn) {
						currentKey = ffj_t_ReplyKeyboardMarkup_Selective
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_ReplyKeyboardMarkup_Selective, kn) {
					currentKey = ffj_t_ReplyKeyboardMarkup_Selective
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ReplyKeyboardMarkup_OneTimeKeyboard, kn) {
					currentKey = ffj_t_ReplyKeyboardMarkup_OneTimeKeyboard
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ReplyKeyboardMarkup_ResizeKeyboard, kn) {
					currentKey = ffj_t_ReplyKeyboardMarkup_ResizeKeyboard
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_ReplyKeyboardMarkup_Keyboard, kn) {
					currentKey = ffj_t_ReplyKeyboardMarkup_Keyboard
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_ReplyKeyboardMarkupno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_ReplyKeyboardMarkup_Keyboard:
					goto handle_Keyboard

				case ffj_t_ReplyKeyboardMarkup_ResizeKeyboard:
					goto handle_ResizeKeyboard

				case ffj_t_ReplyKeyboardMarkup_OneTimeKeyboard:
					goto handle_OneTimeKeyboard

				case ffj_t_ReplyKeyboardMarkup_Selective:
					goto handle_Selective

				case ffj_t_ReplyKeyboardMarkupno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Keyboard:

	/* handler: uj.Keyboard type=[][]tgbotapi.KeyboardButton kind=slice quoted=false*/

	{
		/* Falling back. type=[][]tgbotapi.KeyboardButton kind=slice */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.Keyboard)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ResizeKeyboard:

	/* handler: uj.ResizeKeyboard type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.ResizeKeyboard = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.ResizeKeyboard = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OneTimeKeyboard:

	/* handler: uj.OneTimeKeyboard type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.OneTimeKeyboard = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.OneTimeKeyboard = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Selective:

	/* handler: uj.Selective type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.Selective = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.Selective = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Sticker) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Sticker) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "file_id":`)
	fflib.WriteJsonString(buf, string(mj.FileID))
	buf.WriteString(`,"width":`)
	fflib.FormatBits2(buf, uint64(mj.Width), 10, mj.Width < 0)
	buf.WriteString(`,"height":`)
	fflib.FormatBits2(buf, uint64(mj.Height), 10, mj.Height < 0)
	buf.WriteByte(',')
	if mj.Thumbnail != nil {
		if true {
			buf.WriteString(`"thumb":`)

			{

				err = mj.Thumbnail.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if mj.FileSize != 0 {
		buf.WriteString(`"file_size":`)
		fflib.FormatBits2(buf, uint64(mj.FileSize), 10, mj.FileSize < 0)
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Stickerbase = iota
	ffj_t_Stickerno_such_key

	ffj_t_Sticker_FileID

	ffj_t_Sticker_Width

	ffj_t_Sticker_Height

	ffj_t_Sticker_Thumbnail

	ffj_t_Sticker_FileSize
)

var ffj_key_Sticker_FileID = []byte("file_id")

var ffj_key_Sticker_Width = []byte("width")

var ffj_key_Sticker_Height = []byte("height")

var ffj_key_Sticker_Thumbnail = []byte("thumb")

var ffj_key_Sticker_FileSize = []byte("file_size")

func (uj *Sticker) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Sticker) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Stickerbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Stickerno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffj_key_Sticker_FileID, kn) {
						currentKey = ffj_t_Sticker_FileID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Sticker_FileSize, kn) {
						currentKey = ffj_t_Sticker_FileSize
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffj_key_Sticker_Height, kn) {
						currentKey = ffj_t_Sticker_Height
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_Sticker_Thumbnail, kn) {
						currentKey = ffj_t_Sticker_Thumbnail
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'w':

					if bytes.Equal(ffj_key_Sticker_Width, kn) {
						currentKey = ffj_t_Sticker_Width
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Sticker_FileSize, kn) {
					currentKey = ffj_t_Sticker_FileSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Sticker_Thumbnail, kn) {
					currentKey = ffj_t_Sticker_Thumbnail
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Sticker_Height, kn) {
					currentKey = ffj_t_Sticker_Height
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Sticker_Width, kn) {
					currentKey = ffj_t_Sticker_Width
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Sticker_FileID, kn) {
					currentKey = ffj_t_Sticker_FileID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Stickerno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Sticker_FileID:
					goto handle_FileID

				case ffj_t_Sticker_Width:
					goto handle_Width

				case ffj_t_Sticker_Height:
					goto handle_Height

				case ffj_t_Sticker_Thumbnail:
					goto handle_Thumbnail

				case ffj_t_Sticker_FileSize:
					goto handle_FileSize

				case ffj_t_Stickerno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_FileID:

	/* handler: uj.FileID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.FileID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Width:

	/* handler: uj.Width type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Width = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Height:

	/* handler: uj.Height type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Height = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Thumbnail:

	/* handler: uj.Thumbnail type=tgbotapi.PhotoSize kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Thumbnail = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Thumbnail == nil {
			uj.Thumbnail = new(PhotoSize)
		}

		err = uj.Thumbnail.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileSize:

	/* handler: uj.FileSize type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.FileSize = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Update) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Update) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"update_id":`)
	fflib.FormatBits2(buf, uint64(mj.UpdateID), 10, mj.UpdateID < 0)
	if mj.Message != nil {
		buf.WriteString(`,"message":`)

		{

			err = mj.Message.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"message":null`)
	}
	if mj.EditedMessage != nil {
		buf.WriteString(`,"edited_message":`)

		{

			err = mj.EditedMessage.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"edited_message":null`)
	}
	if mj.ChannelPost != nil {
		buf.WriteString(`,"channel_post":`)

		{

			err = mj.ChannelPost.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"channel_post":null`)
	}
	if mj.EditedChannelPost != nil {
		buf.WriteString(`,"edited_channel_post":`)

		{

			err = mj.EditedChannelPost.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"edited_channel_post":null`)
	}
	if mj.InlineQuery != nil {
		buf.WriteString(`,"inline_query":`)

		{

			err = mj.InlineQuery.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"inline_query":null`)
	}
	if mj.ChosenInlineResult != nil {
		buf.WriteString(`,"chosen_inline_result":`)

		{

			err = mj.ChosenInlineResult.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"chosen_inline_result":null`)
	}
	if mj.CallbackQuery != nil {
		buf.WriteString(`,"callback_query":`)

		{

			err = mj.CallbackQuery.MarshalJSONBuf(buf)
			if err != nil {
				return err
			}

		}
	} else {
		buf.WriteString(`,"callback_query":null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Updatebase = iota
	ffj_t_Updateno_such_key

	ffj_t_Update_UpdateID

	ffj_t_Update_Message

	ffj_t_Update_EditedMessage

	ffj_t_Update_ChannelPost

	ffj_t_Update_EditedChannelPost

	ffj_t_Update_InlineQuery

	ffj_t_Update_ChosenInlineResult

	ffj_t_Update_CallbackQuery
)

var ffj_key_Update_UpdateID = []byte("update_id")

var ffj_key_Update_Message = []byte("message")

var ffj_key_Update_EditedMessage = []byte("edited_message")

var ffj_key_Update_ChannelPost = []byte("channel_post")

var ffj_key_Update_EditedChannelPost = []byte("edited_channel_post")

var ffj_key_Update_InlineQuery = []byte("inline_query")

var ffj_key_Update_ChosenInlineResult = []byte("chosen_inline_result")

var ffj_key_Update_CallbackQuery = []byte("callback_query")

func (uj *Update) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Update) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Updatebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Updateno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_Update_ChannelPost, kn) {
						currentKey = ffj_t_Update_ChannelPost
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Update_ChosenInlineResult, kn) {
						currentKey = ffj_t_Update_ChosenInlineResult
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Update_CallbackQuery, kn) {
						currentKey = ffj_t_Update_CallbackQuery
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffj_key_Update_EditedMessage, kn) {
						currentKey = ffj_t_Update_EditedMessage
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Update_EditedChannelPost, kn) {
						currentKey = ffj_t_Update_EditedChannelPost
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_Update_InlineQuery, kn) {
						currentKey = ffj_t_Update_InlineQuery
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_Update_Message, kn) {
						currentKey = ffj_t_Update_Message
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffj_key_Update_UpdateID, kn) {
						currentKey = ffj_t_Update_UpdateID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Update_CallbackQuery, kn) {
					currentKey = ffj_t_Update_CallbackQuery
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Update_ChosenInlineResult, kn) {
					currentKey = ffj_t_Update_ChosenInlineResult
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Update_InlineQuery, kn) {
					currentKey = ffj_t_Update_InlineQuery
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Update_EditedChannelPost, kn) {
					currentKey = ffj_t_Update_EditedChannelPost
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Update_ChannelPost, kn) {
					currentKey = ffj_t_Update_ChannelPost
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Update_EditedMessage, kn) {
					currentKey = ffj_t_Update_EditedMessage
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Update_Message, kn) {
					currentKey = ffj_t_Update_Message
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Update_UpdateID, kn) {
					currentKey = ffj_t_Update_UpdateID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Updateno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Update_UpdateID:
					goto handle_UpdateID

				case ffj_t_Update_Message:
					goto handle_Message

				case ffj_t_Update_EditedMessage:
					goto handle_EditedMessage

				case ffj_t_Update_ChannelPost:
					goto handle_ChannelPost

				case ffj_t_Update_EditedChannelPost:
					goto handle_EditedChannelPost

				case ffj_t_Update_InlineQuery:
					goto handle_InlineQuery

				case ffj_t_Update_ChosenInlineResult:
					goto handle_ChosenInlineResult

				case ffj_t_Update_CallbackQuery:
					goto handle_CallbackQuery

				case ffj_t_Updateno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_UpdateID:

	/* handler: uj.UpdateID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.UpdateID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Message:

	/* handler: uj.Message type=tgbotapi.Message kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Message = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Message == nil {
			uj.Message = new(Message)
		}

		err = uj.Message.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EditedMessage:

	/* handler: uj.EditedMessage type=tgbotapi.Message kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.EditedMessage = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.EditedMessage == nil {
			uj.EditedMessage = new(Message)
		}

		err = uj.EditedMessage.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChannelPost:

	/* handler: uj.ChannelPost type=tgbotapi.Message kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.ChannelPost = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.ChannelPost == nil {
			uj.ChannelPost = new(Message)
		}

		err = uj.ChannelPost.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_EditedChannelPost:

	/* handler: uj.EditedChannelPost type=tgbotapi.Message kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.EditedChannelPost = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.EditedChannelPost == nil {
			uj.EditedChannelPost = new(Message)
		}

		err = uj.EditedChannelPost.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InlineQuery:

	/* handler: uj.InlineQuery type=tgbotapi.InlineQuery kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.InlineQuery = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.InlineQuery == nil {
			uj.InlineQuery = new(InlineQuery)
		}

		err = uj.InlineQuery.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ChosenInlineResult:

	/* handler: uj.ChosenInlineResult type=tgbotapi.ChosenInlineResult kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.ChosenInlineResult = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.ChosenInlineResult == nil {
			uj.ChosenInlineResult = new(ChosenInlineResult)
		}

		err = uj.ChosenInlineResult.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CallbackQuery:

	/* handler: uj.CallbackQuery type=tgbotapi.CallbackQuery kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.CallbackQuery = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.CallbackQuery == nil {
			uj.CallbackQuery = new(CallbackQuery)
		}

		err = uj.CallbackQuery.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *User) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *User) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "id":`)
	fflib.FormatBits2(buf, uint64(mj.ID), 10, mj.ID < 0)
	buf.WriteByte(',')
	if len(mj.FirstName) != 0 {
		buf.WriteString(`"first_name":`)
		fflib.WriteJsonString(buf, string(mj.FirstName))
		buf.WriteByte(',')
	}
	if len(mj.LastName) != 0 {
		buf.WriteString(`"last_name":`)
		fflib.WriteJsonString(buf, string(mj.LastName))
		buf.WriteByte(',')
	}
	if len(mj.UserName) != 0 {
		buf.WriteString(`"username":`)
		fflib.WriteJsonString(buf, string(mj.UserName))
		buf.WriteByte(',')
	}
	if len(mj.LanguageCode) != 0 {
		buf.WriteString(`"language_code":`)
		fflib.WriteJsonString(buf, string(mj.LanguageCode))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Userbase = iota
	ffj_t_Userno_such_key

	ffj_t_User_ID

	ffj_t_User_FirstName

	ffj_t_User_LastName

	ffj_t_User_UserName

	ffj_t_User_LanguageCode
)

var ffj_key_User_ID = []byte("id")

var ffj_key_User_FirstName = []byte("first_name")

var ffj_key_User_LastName = []byte("last_name")

var ffj_key_User_UserName = []byte("username")

var ffj_key_User_LanguageCode = []byte("language_code")

func (uj *User) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *User) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Userbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Userno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'f':

					if bytes.Equal(ffj_key_User_FirstName, kn) {
						currentKey = ffj_t_User_FirstName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_User_ID, kn) {
						currentKey = ffj_t_User_ID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_User_LastName, kn) {
						currentKey = ffj_t_User_LastName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_User_LanguageCode, kn) {
						currentKey = ffj_t_User_LanguageCode
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffj_key_User_UserName, kn) {
						currentKey = ffj_t_User_UserName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_User_LanguageCode, kn) {
					currentKey = ffj_t_User_LanguageCode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_User_UserName, kn) {
					currentKey = ffj_t_User_UserName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_User_LastName, kn) {
					currentKey = ffj_t_User_LastName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_User_FirstName, kn) {
					currentKey = ffj_t_User_FirstName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_User_ID, kn) {
					currentKey = ffj_t_User_ID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Userno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_User_ID:
					goto handle_ID

				case ffj_t_User_FirstName:
					goto handle_FirstName

				case ffj_t_User_LastName:
					goto handle_LastName

				case ffj_t_User_UserName:
					goto handle_UserName

				case ffj_t_User_LanguageCode:
					goto handle_LanguageCode

				case ffj_t_Userno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: uj.ID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.ID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FirstName:

	/* handler: uj.FirstName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.FirstName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LastName:

	/* handler: uj.LastName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.LastName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UserName:

	/* handler: uj.UserName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.UserName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LanguageCode:

	/* handler: uj.LanguageCode type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.LanguageCode = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *UserProfilePhotos) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *UserProfilePhotos) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"total_count":`)
	fflib.FormatBits2(buf, uint64(mj.TotalCount), 10, mj.TotalCount < 0)
	buf.WriteString(`,"photos":`)
	if mj.Photos != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Photos {
			if i != 0 {
				buf.WriteString(`,`)
			}
			if v != nil {
				buf.WriteString(`[`)
				for i, v := range v {
					if i != 0 {
						buf.WriteString(`,`)
					}

					{

						err = v.MarshalJSONBuf(buf)
						if err != nil {
							return err
						}

					}
				}
				buf.WriteString(`]`)
			} else {
				buf.WriteString(`null`)
			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_UserProfilePhotosbase = iota
	ffj_t_UserProfilePhotosno_such_key

	ffj_t_UserProfilePhotos_TotalCount

	ffj_t_UserProfilePhotos_Photos
)

var ffj_key_UserProfilePhotos_TotalCount = []byte("total_count")

var ffj_key_UserProfilePhotos_Photos = []byte("photos")

func (uj *UserProfilePhotos) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *UserProfilePhotos) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_UserProfilePhotosbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_UserProfilePhotosno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'p':

					if bytes.Equal(ffj_key_UserProfilePhotos_Photos, kn) {
						currentKey = ffj_t_UserProfilePhotos_Photos
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_UserProfilePhotos_TotalCount, kn) {
						currentKey = ffj_t_UserProfilePhotos_TotalCount
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_UserProfilePhotos_Photos, kn) {
					currentKey = ffj_t_UserProfilePhotos_Photos
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_UserProfilePhotos_TotalCount, kn) {
					currentKey = ffj_t_UserProfilePhotos_TotalCount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_UserProfilePhotosno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_UserProfilePhotos_TotalCount:
					goto handle_TotalCount

				case ffj_t_UserProfilePhotos_Photos:
					goto handle_Photos

				case ffj_t_UserProfilePhotosno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_TotalCount:

	/* handler: uj.TotalCount type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.TotalCount = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Photos:

	/* handler: uj.Photos type=[][]tgbotapi.PhotoSize kind=slice quoted=false*/

	{
		/* Falling back. type=[][]tgbotapi.PhotoSize kind=slice */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &uj.Photos)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Venue) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Venue) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "location":`)

	{

		err = mj.Location.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteString(`,"title":`)
	fflib.WriteJsonString(buf, string(mj.Title))
	buf.WriteString(`,"address":`)
	fflib.WriteJsonString(buf, string(mj.Address))
	buf.WriteByte(',')
	if len(mj.FoursquareID) != 0 {
		buf.WriteString(`"foursquare_id":`)
		fflib.WriteJsonString(buf, string(mj.FoursquareID))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Venuebase = iota
	ffj_t_Venueno_such_key

	ffj_t_Venue_Location

	ffj_t_Venue_Title

	ffj_t_Venue_Address

	ffj_t_Venue_FoursquareID
)

var ffj_key_Venue_Location = []byte("location")

var ffj_key_Venue_Title = []byte("title")

var ffj_key_Venue_Address = []byte("address")

var ffj_key_Venue_FoursquareID = []byte("foursquare_id")

func (uj *Venue) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Venue) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Venuebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Venueno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_Venue_Address, kn) {
						currentKey = ffj_t_Venue_Address
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffj_key_Venue_FoursquareID, kn) {
						currentKey = ffj_t_Venue_FoursquareID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffj_key_Venue_Location, kn) {
						currentKey = ffj_t_Venue_Location
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_Venue_Title, kn) {
						currentKey = ffj_t_Venue_Title
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Venue_FoursquareID, kn) {
					currentKey = ffj_t_Venue_FoursquareID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_Venue_Address, kn) {
					currentKey = ffj_t_Venue_Address
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Venue_Title, kn) {
					currentKey = ffj_t_Venue_Title
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Venue_Location, kn) {
					currentKey = ffj_t_Venue_Location
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Venueno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Venue_Location:
					goto handle_Location

				case ffj_t_Venue_Title:
					goto handle_Title

				case ffj_t_Venue_Address:
					goto handle_Address

				case ffj_t_Venue_FoursquareID:
					goto handle_FoursquareID

				case ffj_t_Venueno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Location:

	/* handler: uj.Location type=tgbotapi.Location kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			state = fflib.FFParse_after_value
			goto mainparse
		}

		err = uj.Location.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Title:

	/* handler: uj.Title type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Title = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Address:

	/* handler: uj.Address type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Address = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FoursquareID:

	/* handler: uj.FoursquareID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.FoursquareID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Video) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Video) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "file_id":`)
	fflib.WriteJsonString(buf, string(mj.FileID))
	buf.WriteString(`,"width":`)
	fflib.FormatBits2(buf, uint64(mj.Width), 10, mj.Width < 0)
	buf.WriteString(`,"height":`)
	fflib.FormatBits2(buf, uint64(mj.Height), 10, mj.Height < 0)
	buf.WriteString(`,"duration":`)
	fflib.FormatBits2(buf, uint64(mj.Duration), 10, mj.Duration < 0)
	buf.WriteByte(',')
	if mj.Thumbnail != nil {
		if true {
			buf.WriteString(`"thumb":`)

			{

				err = mj.Thumbnail.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
			buf.WriteByte(',')
		}
	}
	if len(mj.MimeType) != 0 {
		buf.WriteString(`"mime_type":`)
		fflib.WriteJsonString(buf, string(mj.MimeType))
		buf.WriteByte(',')
	}
	if mj.FileSize != 0 {
		buf.WriteString(`"file_size":`)
		fflib.FormatBits2(buf, uint64(mj.FileSize), 10, mj.FileSize < 0)
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Videobase = iota
	ffj_t_Videono_such_key

	ffj_t_Video_FileID

	ffj_t_Video_Width

	ffj_t_Video_Height

	ffj_t_Video_Duration

	ffj_t_Video_Thumbnail

	ffj_t_Video_MimeType

	ffj_t_Video_FileSize
)

var ffj_key_Video_FileID = []byte("file_id")

var ffj_key_Video_Width = []byte("width")

var ffj_key_Video_Height = []byte("height")

var ffj_key_Video_Duration = []byte("duration")

var ffj_key_Video_Thumbnail = []byte("thumb")

var ffj_key_Video_MimeType = []byte("mime_type")

var ffj_key_Video_FileSize = []byte("file_size")

func (uj *Video) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Video) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Videobase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Videono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffj_key_Video_Duration, kn) {
						currentKey = ffj_t_Video_Duration
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffj_key_Video_FileID, kn) {
						currentKey = ffj_t_Video_FileID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Video_FileSize, kn) {
						currentKey = ffj_t_Video_FileSize
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffj_key_Video_Height, kn) {
						currentKey = ffj_t_Video_Height
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_Video_MimeType, kn) {
						currentKey = ffj_t_Video_MimeType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_Video_Thumbnail, kn) {
						currentKey = ffj_t_Video_Thumbnail
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'w':

					if bytes.Equal(ffj_key_Video_Width, kn) {
						currentKey = ffj_t_Video_Width
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Video_FileSize, kn) {
					currentKey = ffj_t_Video_FileSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Video_MimeType, kn) {
					currentKey = ffj_t_Video_MimeType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Video_Thumbnail, kn) {
					currentKey = ffj_t_Video_Thumbnail
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Video_Duration, kn) {
					currentKey = ffj_t_Video_Duration
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Video_Height, kn) {
					currentKey = ffj_t_Video_Height
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Video_Width, kn) {
					currentKey = ffj_t_Video_Width
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Video_FileID, kn) {
					currentKey = ffj_t_Video_FileID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Videono_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Video_FileID:
					goto handle_FileID

				case ffj_t_Video_Width:
					goto handle_Width

				case ffj_t_Video_Height:
					goto handle_Height

				case ffj_t_Video_Duration:
					goto handle_Duration

				case ffj_t_Video_Thumbnail:
					goto handle_Thumbnail

				case ffj_t_Video_MimeType:
					goto handle_MimeType

				case ffj_t_Video_FileSize:
					goto handle_FileSize

				case ffj_t_Videono_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_FileID:

	/* handler: uj.FileID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.FileID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Width:

	/* handler: uj.Width type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Width = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Height:

	/* handler: uj.Height type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Height = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Duration:

	/* handler: uj.Duration type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Duration = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Thumbnail:

	/* handler: uj.Thumbnail type=tgbotapi.PhotoSize kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

			uj.Thumbnail = nil

			state = fflib.FFParse_after_value
			goto mainparse
		}

		if uj.Thumbnail == nil {
			uj.Thumbnail = new(PhotoSize)
		}

		err = uj.Thumbnail.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
		if err != nil {
			return err
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MimeType:

	/* handler: uj.MimeType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.MimeType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileSize:

	/* handler: uj.FileSize type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.FileSize = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

func (mj *Voice) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *Voice) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "file_id":`)
	fflib.WriteJsonString(buf, string(mj.FileID))
	buf.WriteString(`,"duration":`)
	fflib.FormatBits2(buf, uint64(mj.Duration), 10, mj.Duration < 0)
	buf.WriteByte(',')
	if len(mj.MimeType) != 0 {
		buf.WriteString(`"mime_type":`)
		fflib.WriteJsonString(buf, string(mj.MimeType))
		buf.WriteByte(',')
	}
	if mj.FileSize != 0 {
		buf.WriteString(`"file_size":`)
		fflib.FormatBits2(buf, uint64(mj.FileSize), 10, mj.FileSize < 0)
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_Voicebase = iota
	ffj_t_Voiceno_such_key

	ffj_t_Voice_FileID

	ffj_t_Voice_Duration

	ffj_t_Voice_MimeType

	ffj_t_Voice_FileSize
)

var ffj_key_Voice_FileID = []byte("file_id")

var ffj_key_Voice_Duration = []byte("duration")

var ffj_key_Voice_MimeType = []byte("mime_type")

var ffj_key_Voice_FileSize = []byte("file_size")

func (uj *Voice) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *Voice) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_Voicebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_Voiceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'd':

					if bytes.Equal(ffj_key_Voice_Duration, kn) {
						currentKey = ffj_t_Voice_Duration
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffj_key_Voice_FileID, kn) {
						currentKey = ffj_t_Voice_FileID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_Voice_FileSize, kn) {
						currentKey = ffj_t_Voice_FileSize
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_Voice_MimeType, kn) {
						currentKey = ffj_t_Voice_MimeType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_Voice_FileSize, kn) {
					currentKey = ffj_t_Voice_FileSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Voice_MimeType, kn) {
					currentKey = ffj_t_Voice_MimeType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_Voice_Duration, kn) {
					currentKey = ffj_t_Voice_Duration
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_Voice_FileID, kn) {
					currentKey = ffj_t_Voice_FileID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_Voiceno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_Voice_FileID:
					goto handle_FileID

				case ffj_t_Voice_Duration:
					goto handle_Duration

				case ffj_t_Voice_MimeType:
					goto handle_MimeType

				case ffj_t_Voice_FileSize:
					goto handle_FileSize

				case ffj_t_Voiceno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_FileID:

	/* handler: uj.FileID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.FileID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Duration:

	/* handler: uj.Duration type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Duration = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MimeType:

	/* handler: uj.MimeType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.MimeType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FileSize:

	/* handler: uj.FileSize type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.FileSize = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}
